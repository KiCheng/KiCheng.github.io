<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>01-SpringMVC入门 | KiCheng's Blog</title><meta name="author" content="KiCheng"><meta name="copyright" content="KiCheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpringMVC是隶属于Spring框架的一部分吗，是对Servlet进行了封装。SpringMVC是处于Web层的框架，所以其主要的作用就是用来接收前端发过来的请求和数据然后经过处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="01-SpringMVC入门">
<meta property="og:url" content="https://kicheng.github.io/2023/06/05/01-SpringMVC%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="KiCheng&#39;s Blog">
<meta property="og:description" content="SpringMVC是隶属于Spring框架的一部分吗，是对Servlet进行了封装。SpringMVC是处于Web层的框架，所以其主要的作用就是用来接收前端发过来的请求和数据然后经过处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kicheng.github.io/img/logo.jpg">
<meta property="article:published_time" content="2023-06-05T02:39:50.000Z">
<meta property="article:modified_time" content="2023-06-11T03:20:41.000Z">
<meta property="article:author" content="KiCheng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kicheng.github.io/img/logo.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "01-SpringMVC入门",
  "url": "https://kicheng.github.io/2023/06/05/01-SpringMVC%E5%85%A5%E9%97%A8/",
  "image": "https://kicheng.github.io/img/logo.jpg",
  "datePublished": "2023-06-05T02:39:50.000Z",
  "dateModified": "2023-06-11T03:20:41.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "KiCheng",
      "url": "https://kicheng.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="https://kicheng.github.io/2023/06/05/01-SpringMVC%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '01-SpringMVC入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="KiCheng's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/logo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">KiCheng's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">01-SpringMVC入门</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">01-SpringMVC入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-05T02:39:50.000Z" title="发表于 2023-06-05 10:39:50">2023-06-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-11T03:20:41.000Z" title="更新于 2023-06-11 11:20:41">2023-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringMVC/">SpringMVC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>SpringMVC是隶属于Spring框架的一部分吗，是对Servlet进行了封装。SpringMVC是处于Web层的框架，所以其主要的作用就是用来接收前端发过来的请求和数据然后经过处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容。</p>
<span id="more"></span>

<h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><h3 id="Web架构"><a href="#Web架构" class="headerlink" title="Web架构"></a>Web架构</h3><p>现在web程序大都基于三层架构来实现：</p>
<img src="image-20230605105629968.png" alt="image-20230605105629968" style="zoom:67%;" />

<ul>
<li><p>浏览器发送一个请求给后端服务器，后端服务器现在是使用Servlet来接收请求和数据；</p>
</li>
<li><p>如果所有的处理都交给Servlet来处理的话，所有的东西都耦合在一起，对后期的维护和扩展极为不利；将后端服务器Servlet拆分成三层，分别是web、service和dao；</p>
<ul>
<li>web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端；</li>
<li>service层主要负责业务逻辑的处理；</li>
<li>dao层主要负责连接数据库，进行数据的增删改查操作；</li>
</ul>
</li>
<li><p>servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求；针对web层进行了优化，采用了MVC设计模式，将其设计为controller、view和model：</p>
<img src="image-20230605110015709.png" alt="image-20230605110015709" style="zoom:67%;" />

<ul>
<li><p>controller负责请求和数据的接收，接收后将其转发给service进行业务处理；</p>
</li>
<li><p>service根据需要调用dao对数据进行增删改查；</p>
</li>
<li><p>dao把数据处理完后将结果交给service，service再交给controller；</p>
</li>
<li><p><font color="red"><strong>同步请求：</strong></font>controller根据需求组装成Model和View，Model和View组合起来生成页面转发给前端浏览器（这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操作）；</p>
<p>现在更多使用的是<font color="red"><strong>异步请求</strong></font>方式，后端不需要返回view视图，而是将数据以json格式返回</p>
</li>
</ul>
</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC是一种基于Java实现MVC模型的轻量级Web框架，相比于Servlet使用更加简单、开发更加便捷。</p>
<p>SpringMVC主要负责的就是：① controller如何接收请求和数据；② 如何将请求和数据转发给业务层；③ 如何将响应数据转换成json发回到前端。</p>
<h2 id="SpringMVC入门案例"><a href="#SpringMVC入门案例" class="headerlink" title="SpringMVC入门案例"></a>SpringMVC入门案例</h2><p>SpringMVC是一个Web框架，是用来替换Servlet的，在JavaWeb中如何使用Servlet进行开发呢？忘记的话看前面的文章【<a href="https://kicheng.github.io/2023/03/28/03-Servlet/">JavaWeb_Servlet</a>】</p>
<p>SpringMVC的制作流程与Servlet几乎一致：</p>
<p>1、创建Maven结构的web工程</p>
<p>2、设置tomcat服务器：tomcat插件</p>
<p>3、导入坐标（SpringMVC+Servlet）</p>
<p>4、定义处理请求的功能类（Controller）</p>
<p>5、设置请求映射</p>
<p>6、将SpringMVC设定加载到tomcat容器中</p>
<h3 id="SpringMVC实现流程"><a href="#SpringMVC实现流程" class="headerlink" title="SpringMVC实现流程"></a>SpringMVC实现流程</h3><p>步骤1：创建webapp内核的Maven项目</p>
<p>步骤2：导入依赖坐标（Servlet、SpringMVC）</p>
<p>​    注意导入的版本，建议使用JDK8以及5.3.0以下的SpringMVC版本配置，否则后面会出现奇奇怪怪的bug…到现在不知道如何解决jdk17不兼容的问题，后面做大项目的时候一定解决这个问题！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果不设置默认是compile在编译、运行、测试时均有效；如果运行有效的话就会和tomcat中的servlet-api包发生冲突 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.24.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤3：创建SpringMvcConfig配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：创建Controller类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;springMVC&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    Controller要注意的点有如下几个：</p>
<p>（1）<code>@Controller</code>将其作为Bean交给Spring管理；</p>
<p>（2）<code>@RequestMapping(&quot;/save&quot;)</code>指定request请求访问的地址，相当于Servlet中的<code>WebServlet</code>；</p>
<p>（3）<code>@ResponseBody</code>指定后端返回的response响应是json数据；</p>
<p>步骤5：使用Servlet容器启动配置类替换web.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//加载springmvc配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化WebApplicationContext对象</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//加载指定配置类</span></span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置由springmvc控制器处理的请求映射路径(设置为接收所有路径)</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载spring配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    配置类要继承这个<code>AbstractDispatcherServletInitializer</code>类；并且初始化时所需的对象和前面的不同，是<code>AnnotationConfigWebApplicationContext</code>。</p>
<p>步骤6：配置Tomcat环境</p>
<p>我一般是习惯用IDEA自带的Tomcat插件，唯一的缺点是只能用Tomcat7，但是Tomcat7和JDK17已经不兼容了，所以我这里降低版本到JDK8了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤7：运行Tomcat服务器，在浏览器访问<code>/save</code></p>
<p><img src="image-20230605164950934.png" alt="image-20230605164950934"></p>
<h3 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h3><p>将SpringMVC的使用过程总共分两个阶段来分析，分别是启动服务器初始化过程和单次请求过程。</p>
<img src="image-20230605165432219.png" alt="image-20230605165432219" style="zoom: 50%;" />

<h4 id="启动服务器初始化"><a href="#启动服务器初始化" class="headerlink" title="启动服务器初始化"></a>启动服务器初始化</h4><p>1、服务器启动，执行ServletInitConfig类，初始化web容器（功能类似于以前的web.xml）</p>
<p>2、执行createServletApplicationContext方法，创建了WebApplicationContext对象，加载SpringMvcConfig配置类来初始化SpringMVC的容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化WebApplicationContext对象</span></span><br><span class="line"><span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line"><span class="comment">//加载指定配置类</span></span><br><span class="line">ctx.register(SpringMvcConfig.class);</span><br></pre></td></tr></table></figure>

<p>3、加载SpringMvcConfig配置类，执行@ComponentScan加载对应的bean，扫描指定包及其子包下所有类上的注解，这里是<code>@Controller</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br></pre></td></tr></table></figure>

<p>4、加载Controller类，每个@RequestMapping的名称对应一个具体的方法：建立了<code>/save</code>和save方法的对应关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;springMVC&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、执行getServletMappings方法，设定SpringMVC拦截请求的路径规则：<code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单次请求过程"><a href="#单次请求过程" class="headerlink" title="单次请求过程"></a>单次请求过程</h4><p>1、发送请求 <a target="_blank" rel="noopener" href="http://localhost:8080/springmvc_01_quickstart/save">http://localhost:8080/springmvc_01_quickstart/save</a></p>
<p>2、web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</p>
<p>3、解析请求路径<code>/save</code>，由<code>/save</code>匹配执行对应的方法save()</p>
<p>4、检测到有<code>@ResponseBody</code>直接将save()方法的返回值作为响应体返回给请求方</p>
<h3 id="Bean加载控制"><a href="#Bean加载控制" class="headerlink" title="Bean加载控制"></a>Bean加载控制</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>之前我们创建过SpringConfig配置类，在MVC中也创建了SpringMvcConfig配置类，它们都需要加载资源，它们分别都加载哪些内容呢？</p>
<blockquote>
<p>我们目前写过的Config配置类有：ServletInitConfig, SpringConfig, SpringMvcConfig, JdbcConfig, MybatisConfig。</p>
</blockquote>
<p>controller目录存放的是SpringMVC的controller类、service目录存放的是service接口和实现类、dao目录存放的是dao/Mapper接口。controller、service和dao这些类都需要被容器管理成bean对象，SpringMVC加载表现层bean，也就是controller包下的类；Spring控制业务层service的bean和功能bean（DataSource, SqlSessionFactoryBean, MapperScannerConfigurer等），我们需要让Spring和SpringMVC分开加载各自的内容。</p>
<p>在SpringMVC的配置类SpringMvcConfig中使用注解<code>@ComponentScan</code>，我们只需要将其扫描范围设置到controller即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring的配置类SpringConfig中使用注解<code>@ComponentScan </code>，当时扫描的范围中其实是已经包含了controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为功能不同，所以我们需要避免Spring错误加载到SpringMVC的bean。</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230605192715499.png" alt="image-20230605192715499" style="zoom:67%;" />

<h4 id="设置Bean加载控制"><a href="#设置Bean加载控制" class="headerlink" title="设置Bean加载控制"></a>设置Bean加载控制</h4><p>方式一：修改Spring配置类，设定扫描范围为精准范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述只是通过例子说明可以精确指定让Spring扫描对应的包结构，真正在做开发的时候，因为Dao最终是交给MapperScannerConfigurer对象来进行扫描处理的，我们只需要将其扫描到service包即可。</p>
</blockquote>
<p>方式二：修改Spring配置类，排除掉controller包中的bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.Lijiacheng&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(  // 设置扫描加载bean时，排除的过滤规则</span></span><br><span class="line"><span class="meta">                type = FilterType.ANNOTATION,  // 设置排除规则，当前使用按照bean定义时的注解类型进行排除</span></span><br><span class="line"><span class="meta">                classes = Controller.class  // 设置具体排除的注解类</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，通过getBean获取Controller类，如果获取不到就说明在SpringConfig配置类中排除成功了。</p>
<blockquote>
<p>需要把SpringMvcConfig配置类上的<code>@ComponentScan</code>注解注释掉才可以测试成功。因为SpringConfig类中扫描的包是com.Lijiacheng下除了controller包，config中的SpringMvcConfig就会被扫描到，里面又有一个<code>@ComponentScan</code>又将controller类扫描进来了。</p>
</blockquote>
<p>最后一点也很重要，有了SpringConfig配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletInitConfig配置类中的最后一个函数，将Spring配置也加载进来，很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">      ctx.register(SpringConfig.class);</span><br><span class="line">      <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>简化ServletInitConfig配置类开发</strong>（以后用它更简单，不过上面的是老母子）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bean加载控制总结</strong></p>
<p><code>@ComponentScan</code>有个很重要的属性：<code>excludeFilters</code>排除扫描路径中加载的bean，需要指定类别（type）和具体项（classes）；<code>includeFilter</code>相反。</p>
<h2 id="SpringMVC的请求与响应"><a href="#SpringMVC的请求与响应" class="headerlink" title="SpringMVC的请求与响应"></a>SpringMVC的请求与响应</h2><p>SpringMVC是web层的框架，主要的作用是接收请求、响应结果，所以这一部分是学习SpringMVC的重点内容。</p>
<h3 id="设置请求映射路径"><a href="#设置请求映射路径" class="headerlink" title="设置请求映射路径"></a>设置请求映射路径</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230606101301421.png" alt="image-20230606101301421" style="zoom:77%;" />

<p>开启Tomcat服务器，发生报错：</p>
<p><img src="image-20230606102344014.png" alt="image-20230606102344014"></p>
<p>意思是<code>/save</code>已经是bookController这个bean的方法进行匹配了，而另一个UserController这个bean也有一个<code>/save</code>，出现了request请求的匹配模糊。</p>
<h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>前面说到报错，是因为两个Controller中出现了重复的请求路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =====================================</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User delete...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决思路其实也很好想到：为不同模块设置模块名作为请求路径前缀。</p>
<p>对于BookController的save，将其访问路径设置 <a target="_blank" rel="noopener" href="http://localhost:8080/springmvc_03_request_mapping/book/save%EF%BC%9B%E5%AF%B9%E4%BA%8EUserController%E7%9A%84save%EF%BC%8C%E5%B0%86%E5%85%B6%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE">http://localhost:8080/springmvc_03_request_mapping/book/save；对于UserController的save，将其访问路径设置</a> <a target="_blank" rel="noopener" href="http://localhost:8080/springmvc_03_request_mapping/User/save%E3%80%82">http://localhost:8080/springmvc_03_request_mapping/User/save。</a></p>
<h4 id="设置映射路径"><a href="#设置映射路径" class="headerlink" title="设置映射路径"></a>设置映射路径</h4><p>类上也可以添加<code>@RequestMapping</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =====================================</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User delete...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606105142414.png" alt="image-20230606105142414"></p>
<blockquote>
<p><code>@RequestMapping</code>注解value属性前面加不加<code>/</code>都可以，这一点和Servlet有所不同！</p>
</blockquote>
<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>请求路径设置好后，只要确保页面发送请求地址和后台Controller类中配置的路径一致，就可以接收到前端的请求，接收到请求后，如何接收页面传递的参数。请求参数的传递与接收是和请求方式有关系的，目前比较常见的两种请求方式POST和GET。</p>
<h4 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230606114451105.png" alt="image-20230606114451105" style="zoom:77%;" />

<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p><strong>GET发送单个参数</strong></p>
<p>客户端发送请求与参数：</p>
<img src="image-20230606115900208.png" alt="image-20230606115900208" style="zoom:80%;" />

<p>服务端接收参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里controller方法的形参负责接收来自客户端的请求参数（<font color="blue">注意形参名要和请求参数名一致！</font>）</p>
<p><img src="image-20230606120718965.png" alt="image-20230606120718965"></p>
<p>客户端接收到的返回数据：</p>
<p><img src="image-20230606120053621.png" alt="image-20230606120053621"></p>
<p><strong>GET发送多个参数</strong></p>
<p>发送请求与参数：</p>
<img src="image-20230606122327297.png" alt="image-20230606122327297" style="zoom:80%;" />

<p>服务端接收参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name, Integer age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 age =====&gt;&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606122229281.png" alt="image-20230606122229281"></p>
<p><strong>GET请求中文乱码问题</strong></p>
<p>如果我们传递的请求参数中有中文，你会发现接收到的参数会出现中文乱码问题。</p>
<p>出现乱码的原因相信大家都清楚（忘了的话回去看JavaWeb的博客），Tomcat8以后的版本已经处理了中文乱码的问题，但是IDEA中的Tomcat插件目前只更新到Tomcat7，所以需要修改pom.xml中<strong>tomcat插件的配置</strong>来解决<font color="red">GET请求</font>中文乱码问题。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span>  <span class="comment">&lt;!--访问路径编解码字符集--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230606122858098.png" alt="image-20230606122858098"></p>
<p><strong>POST发送参数</strong></p>
<p>发送请求与参数：post的请求参数在请求体上</p>
<img src="image-20230606123252732.png" alt="image-20230606123252732" style="zoom:80%;" />

<p>接收参数和GET完全一致！</p>
<p><strong>POST请求中文乱码问题</strong></p>
<p>解决方案：在ServletInitConfig中配置过滤器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 乱码处理 */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Filter[] getServletFilters()&#123;</span><br><span class="line">      <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">      filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606161430634.png" alt="image-20230606161430634"></p>
<blockquote>
<p>CharacterEncodingFilter是在spring-web包中，而spring-web包又在SpringMVC包里。</p>
</blockquote>
<h3 id="五种类型的参数传递"><a href="#五种类型的参数传递" class="headerlink" title="五种类型的参数传递"></a>五种类型的参数传递</h3><p>前面我们已经能够使用GET或POST来发送请求和数据，所携带的数据都是比较简单的数据，接下来在这个基础上，我们来研究一些比较复杂的参数传递：普通参数、POJO类型参数、嵌套POJO类型参数、数组类型参数、集合类型参数。</p>
<h4 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h4><p>普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数。</p>
<p>能接收到参数的前提是：这两个值必须一致！</p>
<img src="image-20230606162700080.png" alt="image-20230606162700080" style="zoom:80%;" />

<p>那如果方法形参和请求参数名不一致怎么办？</p>
<p><img src="image-20230606163422184.png" alt="image-20230606163422184"></p>
<p>使用<code>@RequestParam</code>注解：写上<code>@RequestParam</code>注解框架就不需要自己去解析注入，能提升框架处理性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username, Integer age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + username);</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 age =====&gt;&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="POJO类型参数"><a href="#POJO类型参数" class="headerlink" title="POJO类型参数"></a>POJO类型参数</h4><p>简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候我们可以考虑使用POJO数据类型。</p>
<p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）。</p>
<p>先看看前面封装的pojo类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="comment">// ...后部分省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送请求和参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）：</p>
<img src="image-20230606164837627.png" alt="image-20230606164837627" style="zoom:80%;" />

<p>服务器接收参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的pojo参数传递 user =====&gt;&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606165101676.png" alt="image-20230606165101676"></p>
<h4 id="嵌套POJO类型参数"><a href="#嵌套POJO类型参数" class="headerlink" title="嵌套POJO类型参数"></a>嵌套POJO类型参数</h4><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数。</p>
<p>发送请求和参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）：</p>
<img src="image-20230606171638166.png" alt="image-20230606171638166" style="zoom:80%;" />

<p>服务器接收参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/containPojoParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">containPojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的嵌套pojo参数传递 user =====&gt;&quot;</span> + user.toString());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606171728620.png" alt="image-20230606171728620"></p>
<h4 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h4><p>数组参数：请求参数名与形参对象属性名<strong>相同</strong>且请求参数为多个，定义数组类型即可接收参数。</p>
<p>发送请求和参数（请求参数名必须一致才能封装到一个数组当中）：</p>
<img src="image-20230606172710261.png" alt="image-20230606172710261" style="zoom:80%;" />

<p>服务器接收参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的数组参数传递 likes =====&gt;&quot;</span> + Arrays.toString(likes));</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;arrayParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606172647070.png" alt="image-20230606172647070"></p>
<h4 id="集合类型数据"><a href="#集合类型数据" class="headerlink" title="集合类型数据"></a>集合类型数据</h4><p>发送请求和参数：</p>
<p><img src="image-20230606184441837.png" alt="image-20230606184441837"></p>
<p>服务器接收参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的列表参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;arrayParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>出现报错：</p>
<p><img src="image-20230606184417780.png" alt="image-20230606184417780"></p>
<p>错误的原因是：SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错。</p>
<p>解决方案：<code>RequestParam</code>注解（对于简单数据类型使用数组会比集合更简单些）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的列表参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p><code>RequestParam</code>注解用在SpringMVC控制器方法形参定义前面：情况1——简单数据类型参数名和请求参数名不一致时进行映射；情况2——对于List列表形参前要加该注释将其标明为非POJO对象。</p>
<h3 id="JSON数据传输参数"><a href="#JSON数据传输参数" class="headerlink" title="JSON数据传输参数"></a>JSON数据传输参数</h3><p>前面我们说过，现在比较流行的开发方式为异步调用。前后端以异步方式进行交换，传输的数据使用的是JSON，所以前端如果发送的是JSON数据，后端该如何接收。</p>
<p>SpringMVC接收JSON数据的实现步骤为：</p>
<ul>
<li>导入jackson包；</li>
<li>客户端发送JSON数据；</li>
<li>开启SpringMVC注解驱动，在SpringMvcConfig配置类上添加<code>@EnableWebMvc</code>注解；</li>
<li>Controller方法的参数前添加<code>@RequestBody</code>注解.</li>
</ul>
<h4 id="JSON普通数组"><a href="#JSON普通数组" class="headerlink" title="JSON普通数组"></a>JSON普通数组</h4><p>步骤1：pom.xml添加依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">2.15</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>步骤2：PostMan发送JSON数据</p>
<img src="image-20230606201238403.png" alt="image-20230606201238403" style="zoom:80%;" />

<p>步骤3：开启SpringMVC注解支持</p>
<p>​    在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：参数前添加<code>@RequestBody</code>将外部传递的json数组数据映射到形参的集合对象中作为数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/listParamForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON普通数组参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listParamForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为json数据是异步请求，参数和数据在表单中，所以不能用<code>@RequestParam</code>，而用<code>@RequestBody</code>.</p>
</blockquote>
<p><img src="image-20230606201541316.png" alt="image-20230606201541316"></p>
<h4 id="JSON对象数据"><a href="#JSON对象数据" class="headerlink" title="JSON对象数据"></a>JSON对象数据</h4><p>请求和数据的发送：</p>
<img src="image-20230606202729677.png" alt="image-20230606202729677" style="zoom:80%;" />

<p>后端接收数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pojoForJson</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON实体类对象参数传递 User =====&gt;&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color="blue">这里也不要忘记在controller方法形参对象前加上<code>@RequestBody</code>进行json类型转换。</font></p>
</blockquote>
<p><img src="image-20230606202648795.png" alt="image-20230606202648795"></p>
<h4 id="JSON对象数组"><a href="#JSON对象数组" class="headerlink" title="JSON对象数组"></a>JSON对象数组</h4><p>json对象数组即为在集合中保存多个POJO。</p>
<p>请求和数据的发送：</p>
<img src="image-20230606204127055.png" alt="image-20230606204127055" style="zoom:80%;" />

<p>后端接收数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listPojoForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listPojoForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON对象数组参数传递 users =====&gt;&quot;</span> + users);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listPojoForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230606204104084.png" alt="image-20230606204104084"></p>
<blockquote>
<p><strong><code>@RequestBody</code>与<code>@RequestParam</code>的区别：</strong></p>
<p><code>@RequestParam</code>用于接收url地址传参，表单传参【application/x-www-form-urlencoded】；<code>@RequestBody</code>用于接收json数据【application/json】.</p>
<p>后期开发中，发送json格式数据为主，<code>@RequestBody</code>应用较广；如果发送非json格式数据，选用<code>@RequestParam</code>接收请求参数。</p>
</blockquote>
<h3 id="日期类型参数传递"><a href="#日期类型参数传递" class="headerlink" title="日期类型参数传递"></a>日期类型参数传递</h3><p>前面我们处理过简单数据类型、POJO数据类型、数组和集合数据类型以及JSON数据类型，接下来我们还得处理一种开发中比较常见的一种数据类型：日期类型。</p>
<p>日期的格式有N多中输入方式，比如：2088-08-18、2088/08/18、08/18/2088……这么多日期格式，SpringMVC如何接收。</p>
<p>步骤1：编写方法接收日期数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dataParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dataParam</span><span class="params">(Date date,</span></span><br><span class="line"><span class="params">                          <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date1,</span></span><br><span class="line"><span class="params">                          <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> Date date2)</span></span><br><span class="line">  &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date =====&gt;&quot;</span> + date);</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date1(YYYY-MM-dd) =====&gt;&quot;</span> + date1);</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date2(YYYY-MM-dd HH:mm:ss)&quot;</span> + date2);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;dataParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：客户端发送请求</p>
<img src="image-20230606225853557.png" alt="image-20230606225853557" style="zoom:80%;" />

<blockquote>
<p>SpringMVC默认支持的字符串转日期的格式为yyyy/MM/dd ，而如果传递的不符合其默认格式，SpringMVC就无法进行格式转换，所以报错：<img src="image-20230606205513452.png" alt="image-20230606205513452"></p>
<p>所以使用<code>@DateTimeFormat</code>注解的<code>pattern</code>值来解决这个问题。</p>
</blockquote>
<p><img src="image-20230606225051826.png" alt="image-20230606225051826"></p>
<h3 id="参数传递的内部实现原理"><a href="#参数传递的内部实现原理" class="headerlink" title="参数传递的内部实现原理"></a>参数传递的内部实现原理</h3><p>前端传递字符串，后端使用日期Date接收；前端传递JSON数据，后端使用对象接收；前端传递字符串，后端使用Integer接收。在数据的传递过程中存在很多类型的转换，那么谁来做这个类型转换——是<strong>SpringMVC</strong>提供的很多类型转换接口和实现类。</p>
<p>在框架中，有一些类型转换接口，其中有：</p>
<ul>
<li> Converter接口：convert方法就是将从页面上接收的数据(S)转换成我们想要的数据类型(T)返回，框架中有提供很多对应Converter接口的实现类，用来实现不同数据类型之间的转换，如：请求参数年龄数据（String→Integer）、日期格式转换（String → Date）。</li>
<li>HttpMessageConverter接口：该接口是实现对象与JSON之间的转换工作（配置<code>@EnableWebMvc</code>）。</li>
</ul>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>SpringMVC接收到请求和数据后，进行一些了的处理，当然这个处理可以是转发给Service，Service层再调用Dao层完成的，不管怎样，处理完以后都需要将结果告知给用户。对于响应，主要就包含两部分内容：响应页面、响应数据（文本数据、json数据），因为异步调用是目前常用的主流方式，所以我们需要更关注的就是如何返回JSON数据。</p>
<h4 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230607100531074.png" alt="image-20230607100531074" style="zoom:80%;" />

<h4 id="响应页面（了解）"><a href="#响应页面（了解）" class="headerlink" title="响应页面（了解）"></a>响应页面（了解）</h4><p>响应页面时不能使用<code>@responseBody</code>注解，否则会把”page.jsp”当做字符串返回，这里需要返回页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用@responseBody，否则会把&quot;page.jsp&quot;当做字符串返回，这里需要返回页面</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/jumpToPage&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">jumpToPage</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;跳转页面&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230607101201195.png" alt="image-20230607101201195"></p>
<h4 id="响应文本数据"><a href="#响应文本数据" class="headerlink" title="响应文本数据"></a>响应文本数据</h4><p>响应文本时一定要使用<code>@responseBody</code>注解，返回纯文本字符串类型数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回纯文本数据&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;response text&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="image-20230607101757278.png" alt="image-20230607101757278" style="zoom:80%;" />

<h4 id="响应JSON数据"><a href="#响应JSON数据" class="headerlink" title="响应JSON数据"></a>响应JSON数据</h4><p><strong>响应POJO对象</strong></p>
<p>返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖<code>@ResponseBody</code>注解和<code>@EnableWebMvc</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toPojoJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">toPojoJson</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回json格式的对象类型&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setName(<span class="string">&quot;李嘉诚123&quot;</span>);</span><br><span class="line">      user.setAge(<span class="number">22</span>);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="image-20230607103941400.png" alt="image-20230607103941400" style="zoom:80%;" />

<p><strong>响应POJO集合对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回json对象列表的类型&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      u1.setName(<span class="string">&quot;李嘉诚&quot;</span>);</span><br><span class="line">      u1.setAge(<span class="number">21</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      u2.setName(<span class="string">&quot;廖梓汀&quot;</span>);</span><br><span class="line">      u2.setAge(<span class="number">22</span>);</span><br><span class="line">      List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">      users.add(u1);</span><br><span class="line">      users.add(u2);</span><br><span class="line">      <span class="keyword">return</span> users;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="image-20230607104901315.png" alt="image-20230607104901315" style="zoom:80%;" />

<p> <strong><code>@ResponseBody</code>总结</strong></p>
<p>位置：SpringMVC控制器方法定义上方和控制类上，写在类上则该类的所有方法都有该注解功能；</p>
<p>作用：设置当前控制器返回值作为响应体（除了返回页面之外都要加该注释）：① 方法的返回值为字符串，会将其作为文本内容直接响应给前端；② 方法的返回值为对象，会将对象转换成JSON响应给前端（通过Converter接口）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kicheng.github.io">KiCheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kicheng.github.io/2023/06/05/01-SpringMVC%E5%85%A5%E9%97%A8/">https://kicheng.github.io/2023/06/05/01-SpringMVC%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kicheng.github.io" target="_blank">KiCheng's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/logo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KiCheng</div><div class="author-info-description">杂乱无章的记事本</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><img src="/img/wechat.jpg" alt="公告图片" style="max-width:50%;"><br>This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">SpringMVC概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">Web架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC"><span class="toc-number">1.2.</span> <span class="toc-text">SpringMVC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">SpringMVC入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">SpringMVC实现流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">流程解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.1.</span> <span class="toc-text">启动服务器初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">单次请求过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E5%8A%A0%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">Bean加载控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">2.3.2.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEBean%E5%8A%A0%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">设置Bean加载控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94"><span class="toc-number">3.</span> <span class="toc-text">SpringMVC的请求与响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84"><span class="toc-number">3.1.</span> <span class="toc-text">设置请求映射路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-1"><span class="toc-number">3.1.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1"><span class="toc-number">3.1.2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84"><span class="toc-number">3.1.3.</span> <span class="toc-text">设置映射路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">请求参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.2.2.</span> <span class="toc-text">参数传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.</span> <span class="toc-text">五种类型的参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">普通参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POJO%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">POJO类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97POJO%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.3.</span> <span class="toc-text">嵌套POJO类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.4.</span> <span class="toc-text">数组类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.5.</span> <span class="toc-text">集合类型数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">JSON数据传输参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">JSON普通数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.2.</span> <span class="toc-text">JSON对象数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.3.</span> <span class="toc-text">JSON对象数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.5.</span> <span class="toc-text">日期类型参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">参数传递的内部实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94"><span class="toc-number">3.7.</span> <span class="toc-text">响应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-3"><span class="toc-number">3.7.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%A1%B5%E9%9D%A2%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">3.7.2.</span> <span class="toc-text">响应页面（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE"><span class="toc-number">3.7.3.</span> <span class="toc-text">响应文本数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94JSON%E6%95%B0%E6%8D%AE"><span class="toc-number">3.7.4.</span> <span class="toc-text">响应JSON数据</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/16/NIO%E7%BC%96%E7%A8%8B/" title="NIO编程"><img src="/2025/04/16/NIO%E7%BC%96%E7%A8%8B/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NIO编程"/></a><div class="content"><a class="title" href="/2025/04/16/NIO%E7%BC%96%E7%A8%8B/" title="NIO编程">NIO编程</a><time datetime="2025-04-16T02:28:43.000Z" title="发表于 2025-04-16 10:28:43">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/07/RPC-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" title="RPC-动态代理">RPC-动态代理</a><time datetime="2025-04-07T13:50:29.000Z" title="发表于 2025-04-07 21:50:29">2025-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/30/ZooKeeper/" title="ZooKeeper"><img src="/2025/03/30/ZooKeeper/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ZooKeeper"/></a><div class="content"><a class="title" href="/2025/03/30/ZooKeeper/" title="ZooKeeper">ZooKeeper</a><time datetime="2025-03-30T01:54:15.000Z" title="发表于 2025-03-30 09:54:15">2025-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/24/Java-NIO/" title="Java NIO"><img src="/2025/03/24/Java-NIO/cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java NIO"/></a><div class="content"><a class="title" href="/2025/03/24/Java-NIO/" title="Java NIO">Java NIO</a><time datetime="2025-03-24T01:40:02.000Z" title="发表于 2025-03-24 09:40:02">2025-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img src="/2025/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2025/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2025-02-02T03:43:52.000Z" title="发表于 2025-02-02 11:43:52">2025-02-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By KiCheng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>