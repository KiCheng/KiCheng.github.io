<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KiCheng&#39;s Blog</title>
  
  <subtitle>life and study shares</subtitle>
  <link href="https://kicheng.github.io/atom.xml" rel="self"/>
  
  <link href="https://kicheng.github.io/"/>
  <updated>2025-02-02T14:32:31.451Z</updated>
  <id>https://kicheng.github.io/</id>
  
  <author>
    <name>KiCheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式</title>
    <link href="https://kicheng.github.io/2025/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kicheng.github.io/2025/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2025-02-02T03:43:52.000Z</published>
    <updated>2025-02-02T14:32:31.451Z</updated>
    
    <content type="html"><![CDATA[<p>我理解的设计模式实际上是在某些编码场景下，针对某类问题的一种通用的设计方法和解决方案。设计模式有 23 种共分为三大类：创建型模式、结构型模式、行为型模式，这篇文章总结我用过的设计模式。</p><p><img src="17385067108922.jpg"></p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式保证<strong>一个类只有一个实例</strong>——如果你创建了一个对象，同时过一会儿后你决定再创建一个新对象，此时你会获得之前已创建的对象，而不是一个新对象；为该实例<strong>提供全局访问节点</strong>，允许在程序的任何地方访问特定对象。<br><img src="17384684245334.jpg"><br>通过「双重检查锁」支持多线程创建单例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingletonDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 禁用构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">singletonDemogetInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先判断实例是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class) &#123;</span><br><span class="line">                <span class="comment">// 再次判断, 因为可能出现某个线程拿了锁之后创建对象</span></span><br><span class="line">                <span class="comment">// 而此时其他的线程拿到了锁又执行到此处 ==&gt; 这些线程都会创建一个实例, 从而创建多个实例对象</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【应用】Spring 中管理的 Bean 默认就是单例的，所有请求共享同一个实例。极大提高了性能和资源利用率，避免了重复创建对象的开销。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>定义一个抽象工厂接口，让子类实现这个工厂，负责创建具体的「一类对象」。</p><p>【应用】Spring 中 Bean 的创建（实例化）方法就有通过「静态工厂」、「实例工厂」来实现的，此外 Spring 还提供了 <code>FactoryBean&lt;T&gt;</code> 接口，允许我们自定义工厂来创建复杂的 Bean。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>使用抽象的接口提供一个工厂的工厂，用于创建「多个产品族」中的产品。<br><img src="17384693466193.jpg"></p><p>【应用】ApplicationContext 继承了 BeanFactory，可以看作是一个 Spring 内部的抽象工厂。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>在应用程序中需要两个不同接口的类进行通信，在不修改两个接口的前提下需要通过某个中间件来完成这个衔接工作，这个中间件就是适配器。<br><img src="17384697310889.jpg"></p><p>【应用】</p><p>一）适配器 Adapter，被用于 SpringMVC 中。众所周知的是 SpringMVC 工作原理在 url 经过 HandlerMapping 查找能够处理请求的 Handler 之后，就要将请求交给实际的 Handler 进行处理，在 Handler 之前就要通过一个适配器，目的是将不同类型的 Handler(有最常见的控制层 Controller 之外还有更低级别的 HttpRequestServlet 等) 统一处理请求。</p><p>二）Java IO 中将字节流通过 InputStreamReader 适配器将字节转换为字符 FileReader。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>运行时为对象动态添加新功能，而不改变原始对象的结构。</p><p>它和继承的区别在于：装饰器是「组合」而非继承。虽然我们可以通过继承的方式给一个对象添加新行为，但是 ①对象之间的关系复杂不利于维护 ②单继承的局限性。<br><img src="17384699712067.jpg"></p><p>【应用】</p><p>一）Java IO 中对于字节流的 FilterInputStream 和 FilterOutputStream 是装饰器模式的核心，分别用于增强 InputStream 和 OutputStream 对象的功能——BufferedInputStream(字节缓冲输入流)、DataInputStream 就是 FilterInputStream 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>二）<font color="blue">【存疑】</font>ThreadLocal → InheritableThreadLocal → TransmittableThreadLocal 的升级，在不改变 ThreadLocal 原本机制的情况下，增强 ThreadLocal 的功能。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理对象代替真实对象的访问，可以在不修改原目标对象的前提下提供额外操作——无入侵式的拓展代码。又分为静态代理和动态代理，根本区别是编译时或是运行时的字节码修改。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>模式建议你将这些处理者连成一条链。链上的每个处理者都有一个成员变量来保存对于下一处理者的引用，除了处理请求外，处理者还负责沿着链传递请求。<br><img src="17384703080926.jpg"></p><p>【应用】Java 中 Web Servlet 的 Filter 过滤器。 </p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>用于「一对多」的依赖关系，当一个对象状态变化时，自动通知所有依赖它的对象。</p><p><img src="17384704447703.jpg"></p><p>【应用】Spring 中的事件监听机制。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>声明一个抽象的父类，将部分逻辑以具体方法的形式实现，然后声明一些抽象方法让子类来实现剩余的逻辑。<br>【应用】Java 中的抽象队列同步器 AQS 实现可重入锁、信号量、 CountDownLatch 倒计时器、CyclicBarrier 循环栅栏等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我理解的设计模式实际上是在某些编码场景下，针对某类问题的一种通用的设计方法和解决方案。设计模式有 23 种共分为三大类：创建型模式、结构型模式、行为型模式，这篇文章总结我用过的设计模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;17385067108922.jpg&quot;&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://kicheng.github.io/categories/Java/"/>
    
    
    <category term="设计模式" scheme="https://kicheng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal机制</title>
    <link href="https://kicheng.github.io/2025/01/27/ThreadLocal%E6%9C%BA%E5%88%B6/"/>
    <id>https://kicheng.github.io/2025/01/27/ThreadLocal%E6%9C%BA%E5%88%B6/</id>
    <published>2025-01-27T13:16:57.000Z</published>
    <updated>2025-02-02T15:37:55.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="为什么要有-ThreadLocal"><a href="#为什么要有-ThreadLocal" class="headerlink" title="为什么要有 ThreadLocal"></a>为什么要有 ThreadLocal</h3><p>为了解决多线程存在「线程安全」的问题——线程并发对同一临界区的共享资源进行访问而导致的内存数据安全问题，才引入的 ThreadLocal——每个线程拥有自己线程隔离的「本地变量」。</p><h3 id="ThreadLocal-中弱引用问题"><a href="#ThreadLocal-中弱引用问题" class="headerlink" title="ThreadLocal 中弱引用问题"></a>ThreadLocal 中弱引用问题</h3><p>要说清楚 ThreadLocal 中的弱引用机制，还要从 ThreadLocal 的设计初衷讲起。为了解决多线程线程安全问题，每一个 Thread 中都有一个 ThreadLocalMap，其中 key 为 ThreadLocal 本地变量，value 为想要存放的具体值。为了实现线程安全，不允许用户直接接触 ThreadLocalMap 向里面 put Entry，而是通过 ThreadLocal 的 API：get、set、remove 来间接操作。具体的实现是，ThreadLocalMap 作为 ThreadLocal 中的静态内部类，ThreadLocal 为 Map 提供了外层的用户封装，而将可能出现的线程冲突交由内部实现来解决。</p><p>这就造成了当使用者没有正确的通过 remove 方法将 ThreadLocal 删除而通过将 ThreadLocal 变量置为 null 时，就会造成这个 Entry 永远存在于 ThreadLocalMap 中且无法被访问和删除，进而造成 OOM 的风险。</p><p>为了避免 OOM，设计者将 ThreadLocalMap 中的 key(ThreadLocal引用) 设置为弱引用，也就是没有外部引用时会被 GC 自动回收。</p><p>但是就算是通过弱引用的设计方式，也无法完全避免 OOM 的发生。这是因为虽然 ThreadLocalMap 会通过线性探测清理、启发式清理的方式清除脏 Entry，但实际并不能保证脏 Entry 被清除。所以呼吁使用者在使用完 ThreadLocal 变量之后一定要通过 remove 手动回收。</p><h3 id="ThreadLocal-的进化"><a href="#ThreadLocal-的进化" class="headerlink" title="ThreadLocal 的进化"></a>ThreadLocal 的进化</h3><p>画个图来说明 ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal 之间的区别：<br><img src="pic1.png" alt="pic1"></p><h4 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>为了避免线程安全而维护的本地变量副本。</p><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><p>使用 ThreadLocal 时在异步场景下无法给子线程提供父线程所创建的数据副本，由此才有了 InheritableThreadLocal 登场：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">        ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">        ThreadLocal.set(<span class="string">&quot;父类数据:threadLocal&quot;</span>);</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;父类数据:inheritableThreadLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类ThreadLocal数据：&quot;</span> + ThreadLocal.get());</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类inheritableThreadLocal数据：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong><br>在 Thread 类中维护了两个 hashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>在父线程中通过<code>new Thread()</code>创建子线程时，Thread 的构造方法会复制父线程的 inheritThreadLocals 为子线程的 inheritableThreadLocals 赋值。</p><h4 id="TransmittableThreadLocal"><a href="#TransmittableThreadLocal" class="headerlink" title="TransmittableThreadLocal"></a>TransmittableThreadLocal</h4><p>在实际项目中使用异步处理都采用线程池，线程池是 Thread 复用的逻辑，而 InheritableThreadLocal 是在<code>new Thread()</code>时才进行本地变量的传递，这时候就不灵了。</p><p>因为需求由「父子线程的 ThreadLocal 值传递」变成了「<strong>任务提交给线程池时的 ThreadLocal 传递到任务执行时</strong>」。</p><blockquote><p>阿里巴巴开源组件：<a href="https://github.com/alibaba/transmittable-thread-local">https://github.com/alibaba/transmittable-thread-local</a></p></blockquote><p>TransmittableThreadLocal 类继承自 InheritableThreadLocal，就解决了在线程池以及线程复用的情况下的本地变量传递问题。</p><p><strong>TransmittableThreadLocal 使用</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例代码：<br>这里能体现出 TransmittableThreadLocal 和 InheritableThreadLocal 的区别——向线程池中提交任务时由主线程先设置 ttl 的值，在线程池中执行任务的线程能够得到传递的 ttl 值。</p><blockquote><p>保证线程池中传递值的 2 种方式：</p><ul><li>使用 TtlRunnable 和 TtlCallable 修饰传入线程池的 Runnable 和 Callable 任务；</li><li>（更推荐）使用 TtlExecutors 修饰线程池。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; ttl = <span class="keyword">new</span> <span class="title class_">TransmittableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">ttlExecutorService</span> <span class="operator">=</span> TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ttl.set(<span class="string">&quot;主线程的值：&quot;</span> + i);  <span class="comment">// 主线程修改值</span></span><br><span class="line"><span class="comment">//          executorService.execute(() -&gt; &#123;</span></span><br><span class="line">        ttlExecutorService.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- &quot;</span> + ttl.get());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 ---- 主线程的值：0</span><br><span class="line">pool-1-thread-3 ---- 主线程的值：2</span><br><span class="line">pool-1-thread-1 ---- 主线程的值：5</span><br><span class="line">pool-1-thread-2 ---- 主线程的值：1</span><br><span class="line">pool-1-thread-3 ---- 主线程的值：6</span><br><span class="line">pool-1-thread-5 ---- 主线程的值：4</span><br><span class="line">pool-1-thread-3 ---- 主线程的值：8</span><br><span class="line">pool-1-thread-2 ---- 主线程的值：9</span><br><span class="line">pool-1-thread-1 ---- 主线程的值：7</span><br><span class="line">pool-1-thread-4 ---- 主线程的值：3</span><br></pre></td></tr></table></figure><p>在线程池中线程出现复用时，如果不使用 TransmittableThreadLocal 存储本地变量副本，那在复用时会造成本地变量的「数据污染」，也就是错误地保留了该 Thread 的历史副本，导致读到错误的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h2&gt;&lt;h3 id=&quot;为什么要有-ThreadLocal&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Java 并发编程" scheme="https://kicheng.github.io/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://kicheng.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>消息队列选型</title>
    <link href="https://kicheng.github.io/2025/01/23/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B/"/>
    <id>https://kicheng.github.io/2025/01/23/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B/</id>
    <published>2025-01-23T04:57:00.000Z</published>
    <updated>2025-02-04T12:26:18.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>这是一篇对消息队列的详细总结（可能对于高可用和架构方面的总结还不够，未来会随着对知识理解的加深继续完善）。在项目中使用了 RabbitMQ，所以也记录了 RabbitMQ 的使用集成。</p><p>消息队列可以看成一个存放消息的容器，由于 Queue 是一种先进先出的数据结构，所以消息队列消费数据也是「按序」的。</p><h2 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h2><h3 id="消息队列有什么作用"><a href="#消息队列有什么作用" class="headerlink" title="消息队列有什么作用"></a>消息队列有什么作用</h3><blockquote><p>这部分来自 JavaGuide</p></blockquote><ol><li><p>异步处理<br> 将服务中一些「非核心的耗时业务」以异步方式执行，将消息加入消息队列中之后就立即返回结果，减少响应时间。<br> <img src="17367747169475.jpg"><br> 由于用户请求在将数据写入消息队列后就返回给用户，但是下游任务可能会因为各种情况而失败。<strong>所以在使用消息队列异步处理下游业务时还要进行一些流程上的修改</strong>——比如订机票、酒店时用户提交订单，后台将订单写入 MQ，不能立即返回订单提交成功，需要等待 MQ 中的订单消费者将订单出库后，再通过短信的方式通知用户。</p><blockquote><p>为了保证消息队列中的消息被消费，会将消息缓存在生产者服务器的 buffer 中，直到收到消费者服务器的成功消费通知。</p></blockquote></li><li><p>削峰 / 限流<br> 将短时间高并发产生的用户请求存储在消息队列中，然后后端服务根据自己的处理能力一点点消费这些请求，避免短时间内大量请求将后端服务打垮。也就是<strong>将后台服务系统的处理压力转移到消息队列中</strong>。<br> <img src="17367752502559.jpg"></p></li><li><p>降低系统耦合度<br> 客户端将请求打到消息队列中，服务端来处理消息，这样做的好处是需要消费的业务直接去 MQ 中拿到消息进行消费而不需要和其他业务产生耦合，提高了系统的可扩展性。也就是<strong>将本身需要串行化关联调用的模块优化为各自独立的模块</strong>。<br> <img src="17367757716339.jpg"><br> 比如说在上图的商城系统中，使用消息队列将订单服务和其他服务完成解耦，假设需要新增风控服务，只需要让其订阅这个消息，实现网站业务的可拓展性。</p></li></ol><h3 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h3><p>除了上面所说的三大作用之外，消息队列还有一些其他的使用场景。</p><ol><li>MQ 作为分布式事务的解决方案之一<br> 事务允许将事件流定义为一个原子操作。</li><li>顺序保证</li><li>延时、定时处理</li><li>数据流处理<br> 针对分布式系统产生的海量数据流，如业务日志、监控数据、用户行为等，消息队列可以实时或批量收集这些数据，并将其导入到大数据处理引擎中，实现高效的数据流管理和处理。</li></ol><h3 id="合格的消息队列要满足哪些特点"><a href="#合格的消息队列要满足哪些特点" class="headerlink" title="合格的消息队列要满足哪些特点"></a>合格的消息队列要满足哪些特点</h3><p>消息有序性、消息不丢失、消息可堆积……</p><h3 id="消息队列带来的问题"><a href="#消息队列带来的问题" class="headerlink" title="消息队列带来的问题"></a>消息队列带来的问题</h3><p>前面说了那么多使用消息队列的好处，但是凡事都有两面性，它在实际项目中也会带来一些问题，具体就要看业务中的需要。</p><ol><li>一致性问题：也就是前面说的，在实现异步处理的同时，如果下游业务没有正确的消费消息，就会导致上下游服务数据不一致的情况。</li><li>系统复杂度提高</li><li>系统可用性降低</li></ol><h2 id="消息队列选型"><a href="#消息队列选型" class="headerlink" title="消息队列选型"></a>消息队列选型</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 是采用 Erlang 语言实现 AMQP 协议的消息中间件，常用于在分布式系统中存储转发消息。</p><blockquote><p>AMQP 协议是一个<strong>应用层</strong>高级消息队列的<strong>二进制协议</strong>，它的特点是：①更好的跨语言、跨平台性； ②消息格式只能为 byte[]； ③exchange 提供 pub/sub 更多路由方式。</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>RabbitMQ 的结构如下所示：<br><img src="17375187916252.jpg"></p><ul><li><p>生产者和消费者<br>  <img src="17375290940196.jpg"></p></li><li><p>消息</p><ul><li>消息头（或标签label）<br>  生产者将消息交给 RabbitMQ，RabbitMQ 根据消息头把消息发送给相应的消费者。<ul><li>「最核心」路由键 routing-key</li><li>消息优先级 priority</li></ul></li><li>消息体(payload)</li></ul></li><li><p>交换机 Exchange<br>  消息不是直接加入消息队列 Queue 中，而是生产者将消息发送给交换器时，需要一个 RoutingKey，当 BindingKey 和 RoutingKey 相匹配时，消息才会被路由到对应的队列中。<br>  <img src="17375199166540.jpg"><br>  交换机的四种类型，对应着不同的路由策略：</p><ul><li><p>fanout<br>  无需任何路由键的判断，直接把所有发送到该 Exchange 的消息广播到所有与它绑定的 Queue 中；</p></li><li><p>direct<br>  把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中；<br>  <img src="17375293552101.jpg"></p></li><li><p>topic<br>  direct 的模糊匹配版本：规定 RoutingKey 和 BindingKey 为一个点号”.”分隔的字符串（被点号”.”分隔开的每一段独立的字符串称为一个单词）；BindingKey 有 “*”和”#”，分别用于匹配一个单词和多个单词；</p></li><li><p>headers<br>  不根据消息头的 RoutingKey 来路由消息，而是根据消息中的 header&lt;key,value&gt; 属性。性能很差，且不实用。</p></li></ul></li><li><p>消息队列 Queue<br>  多个消费者可以订阅同一个队列，这时候队列中消息会被平均分摊给多个消费者（轮询）。RabbitMQ 不支持「队列」层面的广播消费，也就是不支持一个队列的消息被多个消费者同时消费。</p></li><li><p>信道 Channel<br>  TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用「信道」的方式来传输数据。TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。</p></li></ul><h4 id="应用集成"><a href="#应用集成" class="headerlink" title="应用集成"></a>应用集成</h4><ol><li>Mac 中环境搭建，为我们搭建整套 RabbitMQ 依赖的环境，包括 erlang <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install rabbitmq</span><br></pre></td></tr></table></figure> 后台启动： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start rabbitmq</span><br></pre></td></tr></table></figure><blockquote><p>在 RabbitMQ 配置页的其他配置，可参考：<a href="https://netfilx.github.io/spring-boot/8.springboot-rabbitmq/springboot-rabbitmq">https://netfilx.github.io/spring-boot/8.springboot-rabbitmq/springboot-rabbitmq</a> </p></blockquote></li><li>项目配置 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br></pre></td></tr></table></figure> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 客户端，你的虚拟机IP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 客户端端口</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">guest</span> <span class="comment"># 默认用户名</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">guest</span> <span class="comment"># 默认密码</span></span><br></pre></td></tr></table></figure></li><li>发布消息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitmqServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">RabbitmqService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DirectExchange directExchange;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">publishDirectMsg</span><span class="params">(MessageQueueEvent&lt;T&gt; messageQueueEvent, String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.publishDirectMsg(messageQueueEvent, key, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">publishDirectMsg</span><span class="params">(MessageQueueEvent&lt;T&gt; messageQueueEvent, String key, <span class="type">boolean</span> isPersist)</span> &#123;</span><br><span class="line">        <span class="comment">// 消息头中的优先级、是否持久化等配置 </span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">        messageProperties.setDeliveryMode(isPersist? MessageDeliveryMode.PERSISTENT: MessageDeliveryMode.NON_PERSISTENT);</span><br><span class="line">        <span class="comment">// MessageConverter:将Java对象转换为RabbitMQ的消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> rabbitTemplate.getMessageConverter().toMessage(messageQueueEvent, messageProperties);</span><br><span class="line">        <span class="comment">// convertAndSend是发送的核心：指定交换机、路由键和消息本身</span></span><br><span class="line">        rabbitTemplate.convertAndSend(directExchange.getName(), key, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MessageConverter 用于将 Java 对象转换为 RabbitMQ 的消息。默认情况下，Spring Boot 使用 SimpleMessageConverter，只能发送 String 和 byte[] 类型的消息。</p></blockquote></li></ol><p>MessageQueueEvent 泛型类是我学习到的一种高级写法，因为在进入消息队列之前要将 JavaBean 序列化为 Message 对象才能被 RabbitMQ 处理，这里为了封装消息的类型<code>notifyType</code>，将 JavaBean 封装到泛型类的成员变量<code>content</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueEvent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> NotifyTypeEnum notifyType;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>消费消息——<code>@RabbitListener</code>指定queue<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitmqConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(</span></span><br><span class="line"><span class="meta">                    name = CommonConstants.MESSAGE_QUEUE_NAME_NOTIFY_EVENT,  // 队列名称queue.notify</span></span><br><span class="line"><span class="meta">                    durable = &quot;true&quot;</span></span><br><span class="line"><span class="meta">                ),</span></span><br><span class="line"><span class="meta">                // 交换机名称 direct.exchange</span></span><br><span class="line"><span class="meta">                exchange = @Exchange(name = CommonConstants.MESSAGE_QUEUE_EXCHANGE_NAME_DIRECT, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">                key = &#123;CommonConstants.MESSAGE_QUEUE_KEY_NOTIFY&#125;  // 路由键notify</span></span><br><span class="line"><span class="meta">            ),</span></span><br><span class="line"><span class="meta">        concurrency = &quot;10&quot;  // 并发消费者数量</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">listenNotifyEventQueue</span><span class="params">(MessageQueueEvent&lt;T&gt; msgEvent)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到direct.queue的消息：【&#123;&#125;】&quot;</span>, msgEvent);</span><br><span class="line">    <span class="comment">// 调用下游业务处理消息</span></span><br><span class="line">    <span class="keyword">switch</span> (msgEvent.getNotifyType())&#123;</span><br><span class="line">        <span class="keyword">case</span> PRAISE:</span><br><span class="line">        <span class="keyword">case</span> COLLECT:</span><br><span class="line">            messageQueueNotifyMsgConsumer.saveArticleNotify(objectMapper.convertValue(msgEvent, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;&gt;() &#123;&#125;));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CANCEL_PRAISE:</span><br><span class="line">        <span class="keyword">case</span> CANCEL_COLLECT:</span><br><span class="line">            messageQueueNotifyMsgConsumer.removeArticleNotify(objectMapper.convertValue(msgEvent, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;&gt;() &#123;&#125;));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>很多教程中<code>@RabbitListener</code>注解中只指定了 queue 的 Name，就像这样：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br></pre></td></tr></table></figure>因为它们是在 rabbitmq 配置界面中手动设定了交换机和队列之间的绑定关系以及 bindingKey，这里的复杂配置帮助完成自动绑定。</li></ol><h4 id="业务应用"><a href="#业务应用" class="headerlink" title="业务应用"></a>业务应用</h4><p>在开发的项目中，目前只有文章中的点赞会走 rabbitmq 消息队列，其他的操作走 Java 内置的消息机制。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((notifyType.equals(NotifyTypeEnum.PRAISE) || notifyType.equals(NotifyTypeEnum.CANCEL_PRAISE)) &amp;&amp; rabbitmqService.enabled()) &#123;</span><br><span class="line">    rabbitmqService.publishDirectMsg(<span class="keyword">new</span> <span class="title class_">MessageQueueEvent</span>&lt;&gt;(notifyType, foot), CommonConstants.MESSAGE_QUEUE_KEY_NOTIFY);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Optional.ofNullable(notifyType).ifPresent(notify -&gt; SpringUtil.publishEvent(<span class="keyword">new</span> <span class="title class_">NotifyMsgEvent</span>&lt;&gt;(<span class="built_in">this</span>, notify, foot)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kafka-流式处理平台"><a href="#Kafka-流式处理平台" class="headerlink" title="Kafka 流式处理平台"></a>Kafka 流式处理平台</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>十万级别的吞吐量：比 RabbitMQ 高一个数量级，基于 Java 开发大量使用了批量处理和异步的思想。</li><li>生态系统的兼容性。</li></ol><p><del>RabbitMQ 采用的是<strong>队列模型</strong></del>，队列模型存在的问题是：不支持「将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容」的场景。</p><blockquote><p>修正：RabbitMQ 有不同工作模式，点对点的工作模式是基于队列模型，像路由模型就是基于发布-订阅模型，但并不是基于主题 Topic 的广播消费、而是基于交换机 Exchange 的广播消费。</p></blockquote><p>而 Kafka (和 RocketMQ) 采用的<strong>发布-订阅模型</strong>就是为了解决队列模型存在的问题，发布者发布一条消息，该消息通过 Topic 主题传递给所有的订阅者。<br><img src="17375594059671.jpg"></p><p>Partition(分区) 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，提供了更好的并发能力以及容灾能力。</p><h4 id="如何保证消息有序、不丢失、不重复"><a href="#如何保证消息有序、不丢失、不重复" class="headerlink" title="如何保证消息有序、不丢失、不重复"></a>如何保证消息有序、不丢失、不重复</h4><ol><li><p>消息有序<br><img src="17375608634383.jpg"><br>每次添加消息到分区的时候都会采用尾加法，Kafka 只能为我们保证分区中的消息有序。</p><p> 为了保证同一订单 A 的创建、支付、发货的有序性，通过 Hash 将同一语义的消息们放到一个队列中，就能解决下图的问题了：<br> <img src="17375986431769.jpg"></p></li><li><p>消息不丢失<br> 1）生产者丢失消息：生产者 send 之后消息可能因为网络原因没有发送过去<br> 通过回调函数的方式异步的捕获成功或失败的响应。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(</span><br><span class="line">    result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">    ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> 同时还可以设置合理的生产者 retries 次数，通常为 3。<br> 2）消费者丢失消息：消息在分区中分配 offset，消费者拉取到分区中消息时，消费者就会自动提交 offset。</p><p> 3）Kafka 实例弄丢消息：分区中的多副本机制包含 leader 和 follower，假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</p></li><li><p>消息不重复<br> 根本原因就是当关闭了消费者的自动提交 offset，采取手动提交之后，已经消费的 offset 没有成功提交。<br> 方案一（最有效）：利用 Redis set、MySQL 主键来幂等；<br> 方案二：<br> 和消费者丢失消息的解决方案互斥，通常来说会在允许延迟的场景中采用拉取到消息即提交 offset 来解决不重复问题，消息丢失则通过数据兜底避免。</p></li></ol><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>吞吐量和 Kafka 都是十万级别的，最高档；</li><li>阿里系 Java 开发的开源项目。</li></ol><p>RocketMQ 的模型和 Kafka 是一样的，只不过将分区的概念替换成队列，功能上没有差别。<br><img src="17375970168449.jpg"><br>发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要），它仅仅是为每个消费者组维护一个 offset。</p><blockquote><p>Kafka、RocketMQ 支持广播消费（RabbitMQ是交换机层面的广播）：</p><ul><li>每个分区（队列）只能被一个消费组中的一个消费者消费：为了保证队列内消息消费的有序性，如上图所示。</li><li>如果多个消费者属于不同的消费组，则不同消费组可以并行独立地消费相同的分区（队列），从而实现广播消费的效果。</li></ul></blockquote><h4 id="RocketMQ-的分布式架构"><a href="#RocketMQ-的分布式架构" class="headerlink" title="RocketMQ 的分布式架构"></a>RocketMQ 的分布式架构</h4><p><img src="17376008617978.jpg"><br>第一、Broker 做了集群并且还进行了主从部署；</p><p>第二、为了保证 HA ，NameServer 也做了集群部署，但是请注意它是「去中心化」的。在 RocketMQ 中是通过 单个 Broker 和所有 NameServer 保持长连接 ，并且在每隔 30 秒 Broker 会向所有 Nameserver 发送心跳，心跳包含了自身的 Topic 配置信息，这个步骤就对应这上面的 Routing Info；</p><p>第三、生产者需要向 Broker 发送消息的时候，需要先从 NameServer 获取关于 Broker 的路由信息 Routing Info；</p><p>第四、消费者通过 NameServer 获取所有 Broker 的路由信息后，向 Broker 发送 Pull 请求来获取消息数据。</p><blockquote><p>RabbitMQ 是基于主从（非分布式）做高可用的，主要是采用镜像集群模式。</p></blockquote><p>【我的一些理解】<br><strong>分布式</strong>和<strong>集群</strong>都是为了「提升并发能力」的组织架构：<br>    分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。换句话说，分布式是将整个系统拆分成不同的服务，集群是将同一个服务通过多安排人手的方式来处理。</p><p><img src="17376014833793.jpg"></p><p><strong>主从</strong>是和前面两个不同的，本质区别是主从架构是「中心化」的（主节点负责所有的写入操作，并通过同步机制将数据传递给从节点），目的是「备份容灾」。而集群系统内部也可以通过主从方式来实现容灾，比如 RocketMQ 的 Broker Cluster：<br><img src="17376019176954.jpg"></p><h3 id="RabbitMQ、Kafka、RocketMQ-的比较"><a href="#RabbitMQ、Kafka、RocketMQ-的比较" class="headerlink" title="RabbitMQ、Kafka、RocketMQ 的比较"></a>RabbitMQ、Kafka、RocketMQ 的比较</h3><p><img src="17375997029823.jpg"></p><blockquote><p>• 并发量：指的是同一时间消息队列能支持的活跃连接数量（如生产者和消费者连接数）。<br>    • 吞吐量：指的是单位时间内消息队列系统能够处理的消息数量（如每秒处理百万条消息）。</p></blockquote><p>RabbitMQ 基于 Erlang 的并发模型，通过 Channel 复用 TCP 连接，大大提升了 MQ 的并发能力，可以达到「微秒」级别的时延。</p><p>Kafka 唯一的一点劣势是有可能<strong>消息重复消费（消费完成但 offset 没有提交成功）</strong>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略，这个特性天然适合大数据实时计算以及日志收集。</p><blockquote><p>Kafka 和 RocketMQ 的核心是日志存储，采用多副本同步机制，消息存储可靠性设计是它们的强项；RabbitMQ 的设计是内存优先，持久化存储需要额外配置，更注重消息传递的灵活性和低延迟。</p></blockquote><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 做消息队列的缺点有哪些？</p><blockquote><p>源自 <a href="https://www.xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-9">https://www.xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-9</a></p></blockquote><ol><li><p>消息可能会丢失</p><p> 1）Redis 中间件：会，Redis 持久化本身就可能导致消息丢失、外加主从复制时也有丢失数据的风险；<br> 2）生产者：不会，只要正确处理响应 ack 或异常，并重发消息，就不会出现丢失；<br> 3）消费者：不会，Stream 采用内部队列(Pending List)留存每个消费者读取、但还未确认的消息。</p></li><li><p>消息不可堆积</p><p> Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临 OOM 的风险。</p><p> 但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在磁盘上，当消息积压时，无非就是多占用一些磁盘空间。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h1&gt;&lt;p&gt;这是一篇对消息队列的详细总结（可能对于高可用和架构方面的总结还不够，未来会随着对知识理解的加深继续完善）。在项目中使用了 R</summary>
      
    
    
    
    
    <category term="中间件" scheme="https://kicheng.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>手写SpringBoot Starter</title>
    <link href="https://kicheng.github.io/2025/01/19/%E6%89%8B%E5%86%99SpringBoot-Starter/"/>
    <id>https://kicheng.github.io/2025/01/19/%E6%89%8B%E5%86%99SpringBoot-Starter/</id>
    <published>2025-01-19T13:09:48.000Z</published>
    <updated>2025-01-19T14:18:07.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot-自动装配"><a href="#SpringBoot-自动装配" class="headerlink" title="SpringBoot 自动装配"></a>SpringBoot 自动装配</h2><p>用我的一句话总结自动装配就是：SpringBoot 通过起步依赖和自动装配机制来简化项目的构建和开发管理。</p><h3 id="手动实现SpringBoot-Starter"><a href="#手动实现SpringBoot-Starter" class="headerlink" title="手动实现SpringBoot Starter"></a>手动实现SpringBoot Starter</h3><h4 id="步骤1-创建Maven项目"><a href="#步骤1-创建Maven项目" class="headerlink" title="步骤1 创建Maven项目"></a>步骤1 创建Maven项目</h4><p>创建新 Maven 项目，手动添加必要的 pom 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="步骤2-添加自动配置"><a href="#步骤2-添加自动配置" class="headerlink" title="步骤2 添加自动配置"></a>步骤2 添加自动配置</h4><p>在 src/main/resources/META-INF 目录下创建 spring.factories，并添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.kicheng.self_defined_starter.configuration.MyAutoConfiguration</span><br></pre></td></tr></table></figure><h4 id="步骤3-自动配置类"><a href="#步骤3-自动配置类" class="headerlink" title="步骤3 自动配置类"></a>步骤3 自动配置类</h4><p>自动配置类中用到的两个重要的注解：</p><ul><li><code>@Configuration</code>：声明配置类，负责定义和装配 Bean；</li><li><code>@EnableConfigurationProperties</code>：启用属性绑定，将配置文件中的属性映射到对应的 Java 类中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动创建bean对象注册到容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>(properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤4-配置属性类"><a href="#步骤4-配置属性类" class="headerlink" title="步骤4 配置属性类"></a>步骤4 配置属性类</h4><p>创建一个配置属性类，使用<code>@ConfigurationProperties</code>注解来绑定配置文件中的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤5-创建后端服务的Service和Controller"><a href="#步骤5-创建后端服务的Service和Controller" class="headerlink" title="步骤5 创建后端服务的Service和Controller"></a>步骤5 创建后端服务的Service和Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MyService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> MyProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyServiceImpl</span><span class="params">(MyProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyController</span><span class="params">(MyService myService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/name&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myService.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤6-发布Starter"><a href="#步骤6-发布Starter" class="headerlink" title="步骤6 发布Starter"></a>步骤6 发布Starter</h4><p>发布到 Maven 仓库，这里为了快速验证，将项目打成 jar 包并手动导入到主项目中。</p><h4 id="步骤7-使用Starter"><a href="#步骤7-使用Starter" class="headerlink" title="步骤7 使用Starter"></a>步骤7 使用Starter</h4><p>在主应用中添加 starter 依赖或手动将 jar 包导入 Maven 项目。</p><p>手动导入 jar 包的方法：<br><img src="17372941640582.jpg"></p><p>在 application.yml 中配置属性：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">KiCheng</span></span><br></pre></td></tr></table></figure><p>接口测试成功访问 yml 配置中的内容：<br><img src="17372948233075.jpg"></p><h3 id="SpringBoot-自动装配原理"><a href="#SpringBoot-自动装配原理" class="headerlink" title="SpringBoot 自动装配原理"></a>SpringBoot 自动装配原理</h3><p>实现自动装配最重要的注解是<code>@EnableAutoConfiguration</code>，底层的 AutoConfigurationImportSelector 会扫描外部引用的 jar 包的 META_INF/spring.factories 目录，收集「自动配置类」并将其导入到 Spring 容器中。<br><img src="17372956074451.jpg"></p><blockquote><p>根据 META_INF/spring.factories 配置文件中的信息自动加载指定的类或功能。</p></blockquote><h3 id="SpringBoot-启动原理"><a href="#SpringBoot-启动原理" class="headerlink" title="SpringBoot 启动原理"></a>SpringBoot 启动原理</h3><ol><li>创建 SpringApplication 实例，负责应用启动和初始化；</li><li>从 application.yml 中加载配置文件和环境变量；</li><li>创建上下文环境 ApplicationContext，加载 Bean 完成依赖注入；</li><li>启动内嵌的 Tomcat 服务器；</li><li>发布启动完成事件。</li></ol><p>启动类利用 Java 反射获取启动类的对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run(SelfDefinedStarterApplication.class, args);</span><br></pre></td></tr></table></figure><p>其中启动类中最重要的<code>@SpringBootApplication</code>注解包含了<code>@Configuration</code>、<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>三大注解，它们的作用就不在这里重复了，只是提一下只是因为这个注解和上面的启动过程息息相关。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringBoot-自动装配&quot;&gt;&lt;a href=&quot;#SpringBoot-自动装配&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 自动装配&quot;&gt;&lt;/a&gt;SpringBoot 自动装配&lt;/h2&gt;&lt;p&gt;用我的一句话总结自动装配就是：Spr</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://kicheng.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://kicheng.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL是如何存储数据的</title>
    <link href="https://kicheng.github.io/2025/01/14/MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84/"/>
    <id>https://kicheng.github.io/2025/01/14/MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84/</id>
    <published>2025-01-14T06:57:39.000Z</published>
    <updated>2025-01-14T08:12:23.351Z</updated>
    
    <content type="html"><![CDATA[<p>执行一条 select 语句，在 MySQL 中发生了什么？<br><img src="b74310ed702399a83b23acf5ce93190a.png" alt="b74310ed702399a83b23acf5ce93190a"></p><h2 id="MySQL-数据文件存放在哪"><a href="#MySQL-数据文件存放在哪" class="headerlink" title="MySQL 数据文件存放在哪"></a>MySQL 数据文件存放在哪</h2><p><img src="17368381859980.jpg"><br><img src="17368381964026.jpg"></p><h2 id="InnoDB-数据组织方式"><a href="#InnoDB-数据组织方式" class="headerlink" title="InnoDB 数据组织方式"></a>InnoDB 数据组织方式</h2><h3 id="InnoDB-的行记录"><a href="#InnoDB-的行记录" class="headerlink" title="InnoDB 的行记录"></a>InnoDB 的行记录</h3><p>作为 MySQL 用来存储数据的默认存储引擎 InnoDB，在内部到底是如何存储的呢？<br>InnoDB 总共有四种数据记录的行格式，其中只需要知道 Compact 和 Dynamic，Compact 是一种紧凑的行格式，目的是能在数据页中尽可能多的存储更多记录，Dynamic 作为 5.7 版本之后默认的行格式是由 Compact 发展来的。</p><p><img src="17368384820245.jpg"></p><ol><li><p>记录的额外信息</p><ul><li>变长字段长度列表：先找出所有变长字段，对变长字段列逆序存放<br><img src="17368387171968.jpg"></li><li>NULL 值列表：先找出所有允许 null 的字段，用比特 0 表示不为 NULL，用比特 1 表示为 NULL，仍然对这些字段列逆序存放<br><img src="17368390733834.jpg"></li></ul><blockquote><p>为什么要对变长字段长度列表和 NULL 列表进行「逆序排列」？因为连接不同行记录的指针指向行记录的位置是记录头信息和真实数据之间的位置，这样的好处是向左可以读到记录的额外信息，向右可以直接读到真实数据。而逆序存放的目的是<strong>使位置靠前的记录的真实数据和数据对应的字段长度可以同时在一个 CPU Cache Line 中，提高 CPU 缓存的命中率，提升访问性能</strong>。</p></blockquote><ul><li>记录头信息：固定的默认 5 字节，存放着我们耳熟能详的一些字段，比如 delete_mask, record_type, next_record。</li></ul></li><li><p>记录的真实数据</p><ul><li>表中除了值为 NULL 外所有字段的列数据 <blockquote><p>既然本来就要存储变长数据，为什么在前面还要单独记录变长字段的列表呢？<strong>变长字段的长度是不固定的，直接存储字段值会导致无法准确判断一个字段的结束位置。</strong></p></blockquote></li><li>默认生成的隐藏列<br>  <img src="17368398775575.jpg"><ul><li>row_id 不是必须的，只有数据表中没有主键且没有 UNIQUE 字段时，MySQL 才会为我们生成，作为行记录排序的依据。</li><li>transaction_id 记录最后一次对该记录修改的事务id。</li><li>roll_pointer 存储 MVCC 历史版本数据。</li></ul></li></ul></li></ol><p>一个数据页的大小是 16KB = 16384 字节，而一个数据行最长可以为 65535 字节，所以当一个数据页中的剩余空间无法存储一条数据记录的完整信息时，Compact 会这样做：<br><img src="17368413135757.jpg"><br>这里就简单提一下，实际上还涉及到内存碎片等问题。</p><h3 id="InnoDB-的数据页"><a href="#InnoDB-的数据页" class="headerlink" title="InnoDB 的数据页"></a>InnoDB 的数据页</h3><p><strong>数据页</strong><br>链表中的节点按照主键值从小到大的顺序连接而成：<br><img src="17368407501231.jpg"><br><strong>页目录</strong><br>将所有正常记录（包括最大、最小）划分为几个组；每个组最后一个记录为“带头大哥”，其 n_owned 属性表示组内的记录数；“带头大哥”在页面中的地址偏移量存储为一个 2 Bytes 的槽 slot，用作页目录：<br><img src="17368409051119.jpg"></p><blockquote><p>每个分组的记录条数规定：最小记录所在分组只能有一条记录、最大记录所在分组只能在 1<del>8 条之间、剩下的分组记录只能在 4</del>8 条之间。</p></blockquote><p>根据页目录的数据查找：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li><li>通过记录的 next_record 属性遍历该槽所在的组中的各个记录。</li></ol><h3 id="InnoDB-的索引"><a href="#InnoDB-的索引" class="headerlink" title="InnoDB 的索引"></a>InnoDB 的索引</h3><p>索引是什么？它是一种<strong>用于快速查询、检索数据的数据结构</strong>。</p><p>为什么要建立索引：</p><ol><li>在单个数据页中查找数据：以「非主键列」作为搜索条件，无法通过页目录进行二分查找定位行记录。</li><li>在很多数据页中查找数据：无论是主键列还是非主键列，无法快速定位到记录所在的页，只能沿着<strong>双向链表</strong>从第一个数据页顺序遍历。</li></ol><p>笼统的来说，索引的优点就是<strong>加快检索数据的速度，减少 IO 次数</strong>。</p><p><strong>索引方案的设计</strong></p><ol><li><p>大原则：下一个数据页中行记录的主键值必须大于上一个数据页中的所有行记录的主键值。<br> <img src="17368417220157.jpg"></p></li><li><p>给所有数据页也像数据页内部一样建立一个目录项，目录项包括：①页中记录「最小主键值」；②页号。<br> <img src="17368417331382.jpg"></p></li></ol><p>在 InnoDB 中复用数据页结构来存储目录项，形成 B+ 树数据结构：<br><img src="17368416021890.jpg"><br>InnoDB 根据主键的查询方案（以主键索引为例）：</p><ol><li>确定存储目录项的页：从根节点开始，对目录页「逐层采用二分查找」定位记录行所在的那条目录项记录。</li><li>确定记录行所在的叶子数据页。</li><li>通过数据页的页目录采用「二分查找」定位记录行所在位置。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;执行一条 select 语句，在 MySQL 中发生了什么？&lt;br&gt;&lt;img src=&quot;b74310ed702399a83b23acf5ce93190a.png&quot; alt=&quot;b74310ed702399a83b23acf5ce93190a&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;MyS</summary>
      
    
    
    
    <category term="MySQL" scheme="https://kicheng.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://kicheng.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器</title>
    <link href="https://kicheng.github.io/2025/01/11/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://kicheng.github.io/2025/01/11/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2025-01-11T13:00:41.000Z</published>
    <updated>2025-01-12T09:32:04.671Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h2><p>JVM的垃圾回收机制一共分为两步：第一步先识别出不再使用的内存空间，第二步回收这些内存空间。</p><p>判断对象死亡的方式：<br>1、引用计数法 → 无法解决对象之间循环引用<br>2、可达性分析法<br><img src="17366008593092.jpg"></p><p>回收内存空间的方法：<br>1、标记-清除算法 → 产生内存碎片<br>2、复制算法（为了解决内存碎片问题：可用内存减少一半） → 对于存活时间久的对象需要频繁的复制，所以更适合存活时间短的新生代对象<br>3、标记-整理算法（整理开销大） → 更适合不需要频繁GC的老年代<br>4、分代收集算法：对堆内存分为新生代和老年代，应用不同的垃圾回收策略，提高回收效率。</p><blockquote><p>介绍完这么多，终于可以引出今天的主题，也就是垃圾收集器。如果说垃圾回收算法是方法论，收集器就是依据方法论的具体实现。JVM垃圾收集器分为分代收集（CMS）和分区收集（G1、ZGC），下面就来一一介绍。</p></blockquote><p><img src="17366017466723.jpg"></p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS(Concurrent Mark Sweep)垃圾收集器，从名字也可以看出它是基于标记-清除算法的并发收集器。它的最大特点是：以获取最短回收停顿时间(STW)为目标，所以说CMS非常适合在注重用户体验的应用当中使用。</p><blockquote><p>CMS可以说是HotSpot中第一款真正意义的并发收集器——第一次实现了（一定程度）垃圾回收线程和用户线程的同时工作。</p></blockquote><p>之所以CMS能够控制STW的控制，本质在于对可达性分析算法的改进——三色标记算法，以此实现垃圾回收线程和用户线程的并发执行，极大降低了系统响应时间。</p><h4 id="CMS-垃圾回收过程"><a href="#CMS-垃圾回收过程" class="headerlink" title="CMS 垃圾回收过程"></a>CMS 垃圾回收过程</h4><p><img src="17366022021784.jpg"></p><p>1、初始标记<br>短暂地 stop 其他线程，只标记 GC Roots 引用；<br>2、并发标记（CMS极大降低GC停顿的原因）<br>引用链扫描，但无法保证可达性分析结果可靠；</p><blockquote><p>因为用户线程可能更新引用域，GC 线程无法保证对这些引用的可达分析实时性，故可能导致漏标和多标。</p></blockquote><p>3、重新标记<br>stop 其他线程，对并发标记做出的可达性分析进行校正；</p><blockquote><p>这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</p></blockquote><p>4、并发清除<br>GC 线程对未标记的内存空间区域清扫。</p><h4 id="CMS-特点总结"><a href="#CMS-特点总结" class="headerlink" title="CMS 特点总结"></a>CMS 特点总结</h4><p>优点：并发收集、GC停顿低；<br>但缺点也很明显：<br>① 标记-清除算法本身带来的内存碎片问题；<br>② 对 CPU 资源敏感，在 CPU 核数低时占用大，没有考虑吞吐量问题；</p><blockquote><p>这里的吞吐量指 CPU运行代码时间 / CPU总消耗时间，是衡量 GC 对 CPU 利用率的指标。 </p></blockquote><p>③ 无法处理浮动垃圾。</p><blockquote><p>浮动垃圾：在 CMS 回收过程中应用还在产生垃圾，这些垃圾只能在下次 GC 中回收。</p></blockquote><p>尽管 CMS 从未被 JDK 当作默认的垃圾收集器，并且在 JDK9 标记为过时，JDK14 正式移除，但是它开创了 GC 并发收集的先河。</p><hr><p>前面都是一些为了应对面试而复习的八股，下面的一些内容才是我想写这篇博客的初衷。</p><h4 id="CMS-和-G1-是如何做到并发标记的"><a href="#CMS-和-G1-是如何做到并发标记的" class="headerlink" title="CMS 和 G1 是如何做到并发标记的"></a>CMS 和 G1 是如何做到并发标记的</h4><p><strong>三色标记算法</strong><br>CMS 将对象分为三种颜色：<br>1、黑色：扫描完它以及全部引用的对象；<br>2、灰色（中间状态）：扫描过对象本身、但还没有扫描完它全部引用的对象；<br>3、白色：还没扫描过的对象。</p><p>标记的过程大致为：<br>1、开始时，所有对象都为白色，未扫描状态；<br>2、将 GC Roots 直接关联的对象设为灰色；<br>3、遍历灰色对象所用引用——对象本身设为黑色、其引用都设为灰色；<br>4、重复步骤3，直到没有灰色对象；<br>5、结束时，黑色对象存活，白色对象回收。</p><p>上面的三色标记看起来也没什么了不起，当遇到其他用户线程并发改变对象引用关系时，也会产生错误。请耐心一点继续往下看。</p><p><strong>多标</strong><br>有一种情况是：假设 GC 线程已经在遍历 B，但此时用户线程执行了<code>A.B == null</code>切断了 A→B 的引用：如果可以按照最新的可达性分析 B、D、E 对象都可以被回收了，但由于 B 已经是灰色，它仍然会被当做存活对象继续遍历。「结果是」 B、D、E 变成浮动垃圾，只有下一次 GC 才能回收。</p><p><img src="17366051605911.jpg"></p><p><strong>漏标</strong><br>另外一种情况是：仍然假设 GC 线程已经遍历到 B 了，而此时用户线程执行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.D == null;</span><br><span class="line">A.D == xx;  // A到D的引用被建立</span><br></pre></td></tr></table></figure><p>GC 线程继续工作，由于此时 B 不可达 D，而可达 D 的 A 已经变为黑色，所以 D 最终会被标记为白色，当作垃圾清理。「结果是」本不应该回收的对象被垃圾回收，造成程序崩溃。 </p><p><img src="17366050763451.jpg"></p><p>正像前面说的那样，三色标记法会在用户线程并发时造成存活对象的多标和漏标，多标问题会产生浮动垃圾在下一次 GC 清理就好了，相对来说还没那么严重，但是漏标会将本应存活的对象当作垃圾回收内存，导致程序崩溃。</p><p>经上面的流程我们很容易分析得到，漏标的发生必须同时满足如下两个条件：<br>1、有至少一个黑色对象在被标记后又指向了一个白色对象；<br>2、所有灰色对象在自己引用扫描完成之前，删除了对白色对象的引用；</p><p>换言之，我们只需要破坏以上任意一个条件，就可以避免漏标情况发生。由此引出的两个解决方案：CMS 采用的「增量更新」、G1 采用的「原始快照」。</p><p><strong>增量更新</strong><br>CMS 采用的是增量更新方法，即破坏第一个条件：有至少一个黑色对象被标记后又指向了一个白色对象。<br>既然黑色对象在指向白色对象后，自己又不可被重新遍历，那我们可以顺势将黑色对象的引用记录下来，在后续「重新标记」阶段再以该黑色对象为根对其引用重新扫描。<br>这种方式的缺点是需要耗费一定时间重新扫描这些黑色对象，不过真正发生引用变化的黑色对象往往还是少数。</p><p><strong>原始快照</strong><br>G1 采用的是原始快照方法，即破坏第二个条件：所有灰色对象在自己引用扫描完成之前，删除了对白色对象的引用。<br>既然灰色对象在扫描引用的过程中对白色对象的引用被删除，那我们可以顺势将灰色对象引用的白色对象的引用记录下来，在后续「重新标记」阶段再以白色对象为根对其引用重新扫描。<br>这种方式的缺点是会产生浮动垃圾。因为当用户线程取消引用时可能是真的需要将对应的白色对象回收，这时候重新标记时以白色对象为根会把本该回收的对象复活。不过对于这种浮动垃圾的问题是可以接受的，下一次 GC 回收就好了。</p><blockquote><p>有些文章中会将三色标记中两种解决漏标问题的方案称为「基于写屏障」的bulabula，这里的写屏障可不是 JUC 中对内存的写屏障，而是类似于 AOP 的一种附加操作，也就是记录引用的过程。</p></blockquote><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1(Garbage-First)垃圾收集器，它是一款面向服务器（针对多核 CPU 和大内存）的垃圾收集器，它最大的特点是：在满足 GC 停顿时间要求的同时，还具备着极高的吞吐量。</p><blockquote><p>根据经验，在大部分的大型内存(6G以上)服务器上，无论是吞吐量还是 STW时间，G1 的性能都是要优于 CMS。</p></blockquote><p>G1 作为 JDK9 以来默认的垃圾收集器，有以下优势：</p><ul><li>并行与并发：充分利用多核优势缩短 GC 停顿时间，并且仍然可以像 CMS 那样通过并发的方式在某些时刻让 Java 程序继续运行；</li><li>分代收集：尽管 G1 属于分区收集器，但它分区的依据仍然保留了分代的概念；<br><img src="17366666545944.jpg"></li><li>空间整合：解决 CMS 标记-清除中内存碎片的问题，采用标记-整理算法实现的垃圾收集器；</li><li>可预测的停顿：这是 G1 相比于 CMS 的很重要的优势，G1 在追求低停顿的同时通过可以预测的 STW 预测模型，让使用者明确指定在 M 毫秒的时间片内，垃圾收集消耗的时间不超过 N 毫秒。</li></ul><p>G1 的原理：<br><img src="17366676347431.jpg"></p><h4 id="G1-垃圾回收过程"><a href="#G1-垃圾回收过程" class="headerlink" title="G1 垃圾回收过程"></a>G1 垃圾回收过程</h4><p>1、初始标记<br>2、并发标记（CMS 采用增量更新、G1 采用原始快照）<br>3、最终标记<br>4、筛选回收（局部上是复制算法，全局上是整理算法）<br>选择回收价值高的 Region，复制存活对象到新区域，回收旧区域内存。</p><h4 id="G1-中三种-GC-模式"><a href="#G1-中三种-GC-模式" class="headerlink" title="G1 中三种 GC 模式"></a>G1 中三种 GC 模式</h4><p><img src="17366679761721.jpg"></p><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>ZGC(The Z Garbage Collector)垃圾收集器，它是一款面向于超大内存、低延迟的垃圾收集器，它的设计目标是：在不超过 10ms 的停顿时间下，支持 TB 级别内存容量；ZGC 能够支持 TB 级内存的原因是它的 GC 停顿时间不会随着堆大小或者活跃对象的大小而增加。</p><p>G1 在 YoungGC 和 MixedGC 中都采用了复制算法：<br><img src="17366691962163.jpg"></p><blockquote><p>对象转移阶段，把活跃对象复制到新的内存地址上；重定位阶段，因为转移导致对象地址发生了变化，在重定位阶段，所有指向对象旧地址的引用都要调整到对象新的地址上。</p></blockquote><p>G1 在复制时对象转移阶段和重定位阶段要处理所有存活的对象，并且对象转移阶段将对象转移到新地址上是 STW 的，G1 的性能瓶颈就在这。ZGC 对复制算法进行优化，在标记、对象转移、重定位三个阶段（几乎）都是并发的，这也是 ZGC 停顿时间小于 10ms 的关键。</p><h4 id="ZGC-是如何将对象复制阶段实现并发的"><a href="#ZGC-是如何将对象复制阶段实现并发的" class="headerlink" title="ZGC 是如何将对象复制阶段实现并发的"></a>ZGC 是如何将对象复制阶段实现并发的</h4><p>ZGC 是通过「指针染色」 + 「读屏障」使得所有线程在并发条件下就指针的颜色（状态）达成一致，来实现并发的复制对象，从而大大降低 GC 停顿。<br><strong>指针染色</strong><br>在一个指针中除了有储存指向对象实际内存的地址之外，还可以存储对象的一些元数据信息，比如：对象是否被移动了、对象是否存活、对象是否被锁定等状态信息。</p><p><strong>读屏障</strong><br>和前面说过的写屏障一样，是一种在程序运行时插入到对象访问操作前后的特殊检查。每当在 GC 线程或用户线程中一个对象被访问时（除GC Roots）：</p><ul><li>检查指针染色</li><li>处理移动的对象：如果指针显示对象在垃圾回收过程中已经被移动到新的位置，读屏障将确保返回到对象的新位置<blockquote><p>确保一致性：保证在并发移动对象时内存访问的一致性，从而减少 GC 停顿的需要。</p></blockquote></li></ul><p>正是采用指针染色+读屏障的方式，在访问对象时就能及时记录和处理引用关系的变化，这样 GC 就无需停顿来扫描除 GC Roots 之外的对象。由此也可以呼应 ZGC 的一个特点—— ZGC 的 GC 停顿不随着堆内存或者存活对象大小的增长而增长，因为 STW 停顿只和 GC Roots 有关。</p><p>参考文章<br><a href="https://javabetter.cn/jvm/gc-collector.html">https://javabetter.cn/jvm/gc-collector.html</a><br><a href="https://mp.weixin.qq.com/s/Ywj3XMws0IIK-kiUllN87Q">https://mp.weixin.qq.com/s/Ywj3XMws0IIK-kiUllN87Q</a><br><a href="https://www.cnblogs.com/chanshuyi/p/head-first-of-triple-color-marking-algorithm.html">https://www.cnblogs.com/chanshuyi/p/head-first-of-triple-color-marking-algorithm.html</a><br><a href="https://zhuanlan.zhihu.com/p/340530051">https://zhuanlan.zhihu.com/p/340530051</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;JVM垃圾收集器&quot;&gt;&lt;a href=&quot;#JVM垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;JVM垃圾收集器&quot;&gt;&lt;/a&gt;JVM垃圾收集器&lt;/h2&gt;&lt;p&gt;JVM的垃圾回收机制一共分为两步：第一步先</summary>
      
    
    
    
    <category term="Java虚拟机" scheme="https://kicheng.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://kicheng.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>springboot访问本地资源</title>
    <link href="https://kicheng.github.io/2024/11/22/springboot%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90/"/>
    <id>https://kicheng.github.io/2024/11/22/springboot%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90/</id>
    <published>2024-11-22T01:40:40.000Z</published>
    <updated>2025-01-22T01:49:15.893Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot映射本地图片，外界可通过网络路径发送 HTTP 请求访问该图片。</p><p>在工作中，我们会把图片保存到服务器本地的某个目录下，然后前端 image 标签的 src 属性，填写网络路径即可访问到该图片，这该如何配置呢？有两种方法：</p><ol><li>第一种方法，我们可以修改 application.yml 文件 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    web:</span><br><span class="line">        resources:</span><br><span class="line">        # 支持本地图片上传之后的链接，其中 file:///d的用于win系统，后面的file: 适用于mac/linux系统</span><br><span class="line">        static-locations:</span><br><span class="line">            - classpath:/static/</span><br><span class="line">            - file:///d:/tmp/storage/</span><br><span class="line">            - file:/tmp/storage/</span><br></pre></td></tr></table></figure> 这个方法有个弊端，在某些场景下，可能会无效，比如你的项目中写了某些过滤器等原因。另外，使用yml配置，也会使你静态访问路径失效</li><li>第二种方法，添加 webConfig 配置类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConf</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">        <span class="comment">//通过image访问本地的图片</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/image/**&quot;</span>).addResourceLocations(<span class="string">&quot;file:/tmp/storage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SpringBoot映射本地图片，外界可通过网络路径发送 HTTP 请求访问该图片。&lt;/p&gt;
&lt;p&gt;在工作中，我们会把图片保存到服务器本地的某个目录下，然后前端 image 标签的 src 属性，填写网络路径即可访问到该图片，这该如何配置呢？有两种方法：&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://kicheng.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://kicheng.github.io/2024/09/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://kicheng.github.io/2024/09/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2024-09-25T12:05:44.000Z</published>
    <updated>2024-09-25T12:14:39.948Z</updated>
    
    <content type="html"><![CDATA[<p>线程池的核心思想就是实现线程的复用，避免线程反复创建和销毁带来的性能开销。这里主要介绍了基本的 ThreadPoolExecutor 以及用于定时循环任务的 ScheduledThreadPoolExecutor ，而且线程池是面试的重点。</p><span id="more"></span><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>线程池的核心思想就是实现线程的复用，避免线程反复创建和销毁带来的性能开销。</p><p>Java 通过 ThreadPoolExecutor 来创建线程池，其核心参数如下：</p><p><img src="image-17.png"></p><p><img src="image-20.png" alt="初始化状态下的线程池"></p><h2 id="线程池-execute-工作-x20"><a href="#线程池-execute-工作-x20" class="headerlink" title="线程池 execute 工作&#x20;"></a>线程池 execute 工作&#x20;</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="image-19.png" alt="execute 方法的实现"></p><p>线程在线程池内部被封装成内部类 Worker 创建的对象。&#x20;</p><p><img src="image-23.png"></p><p>在线程池的 execute 方法中是通过 addWorker 方法来创建线程并执行任务的，Worker 会将线程和任务一同封装到 Worker 对象中，在通过 runWorker 方法来执行任务。</p><p><img src="image-22.png" alt="runWorker 方法部分实现"></p><p>在 runWorker 方法内部，通过 while 循环保证执行完任务的线程不被销毁，而是复用不断地 getTask 获取任务，只要能获取到任务就会调用 run 方法继续执行。</p><blockquote><p>每次在执行任务时，都会对 Worker 进行加锁，执行完任务再解锁，这样就可以<strong>通过 Worker 的加锁状态判断当前线程是否在执行任务</strong>（调用 Worker 的 tryLock）。</p></blockquote><p>通过 getTask 获取任务时，可以设置获取任务的线程的超时退出机制：</p><p><img src="image-18.png"></p><p>当线程池线程数已经超过了核心线程数 or 允许超时退出，会调用阻塞队列的 poll 方法传入 keepAliveTime 参数，等待 keepAliveTime 时间后如果仍然没有获取任务则返回 null，当 getTask 返回 null 时线程就会退出了。反之则调用阻塞队列的 take 方法无限期的等待任务的到来。</p><p>通过 getTask 方法的超时等待退出机制的流程总结如下：</p><p><img src="image-15.png"></p><h2 id="线程池的5种状态"><a href="#线程池的5种状态" class="headerlink" title="线程池的5种状态"></a>线程池的5种状态</h2><p>在线程池运行过程中，大多数操作都需要判断当前线程池处于什么状态，再决定是否继续执行操作。</p><p><img src="image-16.png"></p><p>将上述五个状态的状态转换总结为下面的流程图：</p><p><img src="image-21.png"></p><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>就是上面说到的 shutdown 方法 和shutdownNow 方法。</p><p>其中 shutdown 方法中断所有闲置（已经不从任务队列中获取任务）的工作线程——通过 Worker 调用 tryLock 方法判断线程是否工作。</p><p><img src="image-10.png"></p><p>在更改线程池状态的过程中通过加锁来保证状态更新的原子性，防止在多线程环境中有其他线程对线程池进行更改或提交新任务等。</p><p>而 shutdownNow 方法中，则会将任务队列中的 task 都移除，直接进入 STOP 状态。</p><p><img src="image-11.png"></p><h2 id="线程池的使用场景"><a href="#线程池的使用场景" class="headerlink" title="线程池的使用场景"></a>线程池的使用场景</h2><p>使用了 JDK 内部提供的 Executors 工具类来快速创建线程池。</p><ol><li><p>模拟 Web 服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NTHREADS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 接受请求 -- 每一个请求都是一个新线程</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理请求</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;处理请求: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executor.execute(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>并行计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParallelCalculation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NTHREADS</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Callable&lt;Double&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Double <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 模拟数值计算</span></span><br><span class="line">                <span class="keyword">return</span> Math.random() * <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Double&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            results.add(executor.submit(task));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Double&gt; result : results) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(result.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟处理异步任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTask</span> &#123;</span><br><span class="line"><span class="comment">//    private static final int NTHREADS = 1;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread executes task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sub thread executes async task...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sub thread finishes async task...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        executor.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread continues executing task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过 Executors 工具类来创建线程池有多种方案，但是不推荐：</p><ul><li><p>固定线程数量的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span></span><br></pre></td></tr></table></figure><p>newFixedThreadPool 线程池由于使用了 LinkedBlockingQueue，<strong>队列的容量默认无限大</strong>，实际使用中出现任务过多时会导致内存溢出。</p></li><li><p>单个线程数量的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>接近无限大线程数量的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>    </span><br></pre></td></tr></table></figure><p>newCachedThreadPool 线程池由于<strong>核心线程数无限大</strong>，当任务过多的时候会导致创建大量的线程，可能机器负载过高导致服务宕机。</p></li><li><p>带定时调度功能的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="实际项目中合理使用线程池"><a href="#实际项目中合理使用线程池" class="headerlink" title="实际项目中合理使用线程池"></a>实际项目中合理使用线程池</h2><h3 id="线程数"><a href="#线程数" class="headerlink" title="线程数"></a>线程数</h3><p><img src="image-1.png"></p><blockquote><p>Java 中用来获取 CPU 核心数的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure></blockquote><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>建议自定义，可以设置线程的名称，方便日志查询。</p><h3 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h3><p>在构造时可以传入参数来限制任务队列的大小，防止任务数量过多而导致内存溢出。</p><p>利用自定义线程池来改造升级前面 web 服务器、并行计算、异步任务处理的例子。</p><ol><li><p>模拟 web 服务器</p><p><strong>Web服务器通常需要处理 I/O 操作</strong>，比如网络I/O，因此它们被视为 I/O 密集型任务。因此，我们将线程数设置为 2 * CPU 核心数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CPU_COUNT</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">2</span> * CPU_COUNT;</span><br><span class="line">    <span class="comment">// 只有在任务队列满了之后才会创建非核心线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">2</span> * CPU_COUNT + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            <span class="number">60L</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">/* ... */</span>&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>并行计算</p><p>并行计算任务主要用于计算，没有 I/O 阻塞，所以它们是** CPU 密集型**的。线程数设置为CPU核心数 + 1。</p></li><li><p>异步任务处理</p><p>异步任务通常涉及到 I/O 操作，比如数据库查询或文件读写，因此它们被视为** I/O 密集型任务**。因此，我们将线程数设置为2 * CPU核心数。</p></li></ol><h1 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h1><p>定时任务类。指定延迟时间后执行任务 or 周期性执行任务。</p><p><img src="image-3.png"></p><p>相对于 ExecutorService 接口，ScheduledExecutorService 接口增加了几个与定时相关的方法。</p><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><ul><li><p>schedule 方法</p><p><img src="image-8.png"></p></li></ul><p><img src="image-9.png" alt="接口和类关系图"></p><p><img src="image-12.png"></p><ul><li><p>scheduleAtFixedRate 方法（新增定时周期）</p><p>以后每隔 period 时长再次执行任务。注意，period 是从任务开始执行算起的。</p></li></ul><p><img src="image-2.png"></p><ul><li><p>scheduleWithFixedDelay 方法（新增定时周期）</p><p>以后每当任务执行完成后，等待 delay 时长，再次执行任务。</p><p><img src="image.png"></p></li><li><p>delayedExecute 方法</p><p>定时任务执行的主要方法，前面两个定时方法都用到了它。通过检查线程池中的状态，将任务加入到等待队列当中，底层调用 addWorker 方法启动并执行任务。</p></li></ul><h2 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h2><p>在 ScheduledThreadPoolExecutor 中来保存等待的任务。</p><p>DelayedWorkQueue 是一个无界<strong>优先队列</strong>，使用<strong>数组存储</strong>，底层使用<strong>堆结构</strong>来实现优先队列的功能。</p><p><img src="image-4.png"></p><p>假设，索引值从 0 开始，子节点的索引值为 k，父节点的索引值为 p，则：</p><p><img src="image-5.png"></p><p>在延迟等待队列中的线程逻辑身份：</p><p><img src="image-6.png"></p><p><img src="image-7.png"></p><blockquote><p>condition的 available 的作用：等待和唤醒机制，每个 leader 在执行任务之前会唤醒一个 follower 线程使其称为新的 leader 等待下一个定时任务的到来。</p></blockquote><p>DelayedWorkQueue 是一个优先级队列（插入删除的时间复杂度是 O(logN) ），它可以保证每次出队的任务都是当前队列中执行时间最靠前）。</p><p><strong>take 方法</strong></p><p>这里的 take 方法和前面线程池介绍的 getTask 方法的区别是：getTask 方法循环从队列中取任务，取出来就执行了；但是这里的定时队列可能取出来的任务还没有到预期的执行时间，所以在 take 中要保证到指定的执行时间才能被取走。</p><p><img src="image-13.png"></p><p>在定时等待队列中选取 leader，作用是为了<strong>减少不必要的等待时间</strong>。leader 只等待下一个任务到来的时间间隔，其他 followers 无限期等待（我的理解是：每次只唤醒一个线程成为新 leader，而不是通过定时等待 delay 后所有线程都唤醒，造成系统资源的浪费和频繁地上下文切换）。</p><p><img src="image-14.png" alt="如果不设计 leader 的话会造成无效的阻塞"></p><p><strong>offer 方法</strong></p><p>实现向延迟队列插入一个任务的操作，并保证整个队列仍然满足最小堆的性质（通过比较新插入节点和 parent 节点的延迟时间）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;线程池的核心思想就是实现线程的复用，避免线程反复创建和销毁带来的性能开销。这里主要介绍了基本的 ThreadPoolExecutor 以及用于定时循环任务的 ScheduledThreadPoolExecutor ，而且线程池是面试的重点。&lt;/p&gt;</summary>
    
    
    
    <category term="Java并发" scheme="https://kicheng.github.io/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发编程" scheme="https://kicheng.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kicheng.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>通知等待Condition</title>
    <link href="https://kicheng.github.io/2024/09/25/Condition%E5%92%8CLockSupport/"/>
    <id>https://kicheng.github.io/2024/09/25/Condition%E5%92%8CLockSupport/</id>
    <published>2024-09-25T11:55:44.000Z</published>
    <updated>2024-09-25T12:07:24.201Z</updated>
    
    <content type="html"><![CDATA[<p>ConditonObject 是 Condition 接口的实现类，用来做线程同步的通知等待，最重要的是它维护了一个单向的等待队列，要明确它和 AQS 队列的关系。此外还介绍了 LockSupport 类，Condition 的 await 底层就是通过 LockSupport 实现的。</p><span id="more"></span><h2 id="等待通知-Condition"><a href="#等待通知-Condition" class="headerlink" title="等待通知 Condition"></a>等待通知 Condition</h2><p>Condition 的等待队列是一个不带头节点的链式队列，而 AQS 的同步队列是带头节点的。</p><p><img src="image-8.png" alt="Condition 的等待队列"></p><p><img src="image-5.png" alt="AQS 的同步队列"></p><blockquote><p>多个 Condition 对象的多个等待队列有什么用？</p><p><img src="image-7.png"></p></blockquote><blockquote><p>同步队列和等待队列的关系：</p><ol><li><p>调用 Condition 的 await 方法，会使当前持有锁的线程进入同步队列，并释放锁，线程进入等待状态。相当于将同步队列的头节点（占用线程）移动到等待队列的尾部。</p></li><li><p>调用 Condition 的 signal 方法，唤醒该线程，相当于将等待队列的头节点移动到同步队列的尾部。</p></li></ol></blockquote><p>Condition 是个接口，它的实现类是 ConditionObject，是 AQS 的子类。</p><h3 id="Condition-的-await-方法"><a href="#Condition-的-await-方法" class="headerlink" title="Condition 的 await 方法"></a>Condition 的 await 方法</h3><p>当前线程调用 Condtion.await() 方法后，会加入等待队列然后释放 lock ，直到被唤醒或线程出现中断。</p><p><img src="image-9.png"></p><h4 id="如何将当前线程加入等待队列"><a href="#如何将当前线程加入等待队列" class="headerlink" title="如何将当前线程加入等待队列"></a>如何将当前线程加入等待队列</h4><p>首先将等待队列中<code>waitStatus!=-2</code>（只有 waitStatus 为 Condition 的线程才能在等待队列当中）的节点从队列中删除，然后通过尾插法将当前线程封装为 Node 插入到等待队列当中。</p><h4 id="当前线程释放锁的过程"><a href="#当前线程释放锁的过程" class="headerlink" title="当前线程释放锁的过程"></a>当前线程释放锁的过程</h4><p>调用 AQS 的 release 方法释放同步状态，并唤醒同步队列头节点的后继节点引用的线程。</p><h4 id="怎样从-await-方法中退出"><a href="#怎样从-await-方法中退出" class="headerlink" title="怎样从 await 方法中退出"></a>怎样从 await 方法中退出</h4><ol><li>想要退出 await 方法，第一个前提条件就是要退出 while 循环：</li></ol><p><img src="image-3.png"></p><p>退出 while 循环有两种可能：要么当前等待线程被中断，要么由于调用了 Condition.signal / signalAll 方法唤醒线程（当前线程从等待队列移动到同步队列）。</p><ul><li><p>退出 while 循环之后</p><p><img src="image-2.png"></p></li></ul><p><strong>await 原理</strong></p><p>调用 Condition.await 方法的线程必须是已经获得 lock 的线程，也就是当前线程是同步队列中的头节点，调用该方法会使当前线程封装的 Node 尾插到等待队列中。</p><p><img src="image-4.png"></p><h3 id="Condition-的-signal-signalAll-方法"><a href="#Condition-的-signal-signalAll-方法" class="headerlink" title="Condition 的 signal/signalAll 方法"></a>Condition 的 signal/signalAll 方法</h3><p>调用 Condition 中的 signal 方法可以将等待队列中等待时间最长（由于<strong>等待队列是先进先出</strong>的，所以等待时间最长的是头节点）的节点移动到同步队列中，使得该节点有机会获得 lock。</p><p>signal 方法只会对等待队列的头节点进行操作，而 signalAll 方法则是通过一个 while 循环将等待队列所有节点移动到同步队列中。</p><p><img src="image.png"></p><p><strong>Condition 的简单使用</strong></p><p>Condition 就和 Object 一样，只是一个调用 await / wait 方法的一个对象（接口）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionSignal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">waiter</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">signalThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">signaller</span>());</span><br><span class="line">        waitThread.start();</span><br><span class="line">        signalThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">waiter</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;当前条件不满足等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;条件满足，开始执行后续工作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">signaller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程阻塞唤醒类-LockSupport"><a href="#线程阻塞唤醒类-LockSupport" class="headerlink" title="线程阻塞唤醒类 LockSupport"></a>线程阻塞唤醒类 LockSupport</h2><p>synchronized 会使线程阻塞，线程会进入 BLOCKED 状态，而调用 LockSupprt 类的方法阻塞线程会使线程进入到 WAITING 状态。</p><p><img src="image-1.png"></p><blockquote><p>park 阻塞的线程不仅仅会被 unpark 唤醒，还可能会被线程中断（<code>Thread.interrupt</code>）唤醒，而且不会抛出 InterruptedException 异常，所以建议在 park 后自行判断线程中断状态。</p></blockquote><p><strong>LockSupport 的优点</strong></p><p><img src="image-6.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ConditonObject 是 Condition 接口的实现类，用来做线程同步的通知等待，最重要的是它维护了一个单向的等待队列，要明确它和 AQS 队列的关系。此外还介绍了 LockSupport 类，Condition 的 await 底层就是通过 LockSupport 实现的。&lt;/p&gt;</summary>
    
    
    
    <category term="Java并发" scheme="https://kicheng.github.io/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发编程" scheme="https://kicheng.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kicheng.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>可重入锁 ReentrantLock、ReentrantReadWriteLock</title>
    <link href="https://kicheng.github.io/2024/09/24/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <id>https://kicheng.github.io/2024/09/24/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</id>
    <published>2024-09-24T13:11:44.000Z</published>
    <updated>2024-09-25T09:07:05.129Z</updated>
    
    <content type="html"><![CDATA[<p>可重入锁支持重入性，表示能够对共享资源重复加锁，即当前线程获取该锁后再次获取不会被阻塞，主要介绍了 ReentrantLock、ReentrantReadWriteLock 两种。</p><span id="more"></span><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>支持重入性，表示能够对共享资源重复加锁，即当前线程获取该锁后再次获取不会被阻塞。</p><p>ReentrantLock 是通过抽象队列同步器 AQS 在 API 程序级别实现的，其内部类 Sync 继承了 AQS 抽象类，是 Lock 接口的默认实现。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul><li><p>在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以内部类 Sync 的 nonfairTryAcquire 方法为例</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.若被占有，检查占有线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">// 3.再次获取，计数加一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于锁会被获取 n 次，那么只有锁在被释放同样的 n 次之后，该锁才算是完全释放成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.同步状态减1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>前面是以非公平锁的锁获取和释放为例，在 ReentrantLock 中支持公平锁和非公平锁两种模式。在非公平锁获取时只是简单获取了当前状态并<strong>没有考虑同步队列中线程等待</strong>的情况；而公平锁每次只能是<strong>同步队列的第一个节点获取到锁</strong>。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reentrant</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的无参构造是非公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();  <span class="comment">// 加锁</span></span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">        lock.unlock();  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Reentrant</span> <span class="variable">reentrant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reentrant</span>();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                reentrant.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + reentrant.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 ReentrantLock 加锁必须在 try 代码块之前获取，且在加锁之前不能有异常抛出，否则 finally 中无法释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxxLock</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    doOthers();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与-synchronized-比较"><a href="#与-synchronized-比较" class="headerlink" title="与 synchronized 比较"></a>与 synchronized 比较</h3><ul><li><p>获取和释放锁的机制不同：ReentrantLock 必须手动释放锁，通常在 finally 块中调用 unlock 方法确保锁被正确释放；synchronized 在执行完同步代码块后由 JVM 手动释放。</p></li><li><p>锁类型不同：synchronized 是非公平锁，而 ReentrantLock 提供两种锁。</p></li><li><p>底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。</p></li><li><p>ReentrantLock 通常提供更好的性能。</p><ul><li><p>ReentrantLock 可以通过 tryLock 方法非阻塞式的获取锁。</p></li><li><p>ReentrantLock 可以终端获得的锁。</p></li></ul><p><img src="image.png"></p></li><li><p>ReentrantLock 可以实现多路选择通知（可以绑定多个 Condition），而synchronized 只能通过 wait 和 notify/notifyAll 方法唤醒一个线程或者唤醒全部线程（单路通知）。</p></li></ul><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>读写锁，允许多个读线程同时访问，但只允许一个写线程访问，这种锁在读多写少的场景下可以极大提升性能。是 ReadWriteLock 接口的默认实现。</p><blockquote><p>前面的 synchronized 和 ReentrantLock 都是独占锁，同一时刻只允许一个线程访问；而在很多只有读数据的业务场景下独占锁性能太低，所以引入读写锁。</p></blockquote><p><strong>读写锁特性</strong></p><ol><li><p>公平性选择：支持非公平性（默认）和公平的锁获取方式，非公平的吞吐量优于公平；</p></li><li><p>重入性：读锁获取后能够再次获取，写锁获取后能够再次获取写锁 or 读锁（锁降级）；</p></li><li><p>锁降级：获取写锁之后又获取读锁，最终写锁完成释放，实现写锁降级为读锁，允许其他线程并发读取。</p><p><img src="image-1.png"></p></li></ol><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><h4 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h4><p>同一时刻，ReentrantReadWriteLock 的写锁是不能被多个线程获取的，很显然 ReentrantReadWriteLock 的写锁是独占式锁。</p><p>实现写锁的获取是通过重写 AQS 的 tryAcquire 方法实现的，源码：</p><p><img src="image-2.png"></p><p><strong>写锁的 tryAcquire 主要逻辑是：</strong>当读写锁的读锁已经被读线程获取 or 写锁被其他写线程获取，则写锁失败；否则成功并支持重入，增加写状态，同时通过 CAS 保证线程安全。</p><h4 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h4><p>实现写锁的释放是通过重写 AQS 的 tryRelease 方法实现的，源码：</p><p><img src="image-6.png"></p><blockquote><p>因为读写锁的 state 字段的低 16 位表示写状态，所以释放锁时可以用当前同步状态直接减去写状态。</p></blockquote><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>读锁在同一时刻可以被多个线程获取，也就是一种共享锁。实现共享式同步语义需要重写 AQS 的 tryAcquireShared 方法和 tryReleaseShared 方法。</p><h4 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h4><p>重写 AQS 的 tryAcquireShared 方法，源码：</p><p><img src="image-8.png"></p><p><strong>读锁的 tryAcquireShared 主要逻辑是：</strong>当写锁已经被其他线程获取时，再获取读锁则获取失败；否则可以获取成功，利用 CAS 更新同步状态。</p><h4 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h4><p>重写 AQS 的 tryReleaseShared 方法，源码：</p><p><img src="image-7.png"></p><h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>读写锁支持锁降级，所谓锁降级是：先获取写锁，再获取读锁，最后释放写锁的顺序，能够使得写锁降级为读锁（但不支持锁升级）。</p><blockquote><p>ReentrantReadWriteLock 如何保证写锁和读锁在同一线程时的数据安全问题？</p><p><img src="image-5.png"></p></blockquote><h3 id="读写锁的应用"><a href="#读写锁的应用" class="headerlink" title="读写锁的应用"></a>读写锁的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantRWCase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processCacheData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取读锁</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 必须在获取写锁之前释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    <span class="comment">// 重新检查状态，因为另一个线程可能有获取写锁并在我们之前更改状态</span></span><br><span class="line">                    data = fetchDataFromDatabase();</span><br><span class="line">                    cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 在释放写锁之前获取写锁，准备降级为读锁</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放写锁，此时保持读锁，完成锁降级</span></span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                use(data);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rwl.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用数据: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">fetchDataFromDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟从数据库获取数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReentrantRWCase</span>().processCacheData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-4.png"></p><h3 id="读写锁的优点"><a href="#读写锁的优点" class="headerlink" title="读写锁的优点"></a>读写锁的优点</h3><p><img src="image-3.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可重入锁支持重入性，表示能够对共享资源重复加锁，即当前线程获取该锁后再次获取不会被阻塞，主要介绍了 ReentrantLock、ReentrantReadWriteLock 两种。&lt;/p&gt;</summary>
    
    
    
    <category term="Java并发" scheme="https://kicheng.github.io/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发编程" scheme="https://kicheng.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kicheng.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>volatile和synchronized关键字</title>
    <link href="https://kicheng.github.io/2024/09/23/volatile%E4%B8%8Esynchronized/"/>
    <id>https://kicheng.github.io/2024/09/23/volatile%E4%B8%8Esynchronized/</id>
    <published>2024-09-23T12:09:44.000Z</published>
    <updated>2024-09-25T09:05:00.978Z</updated>
    
    <content type="html"><![CDATA[<p>之所以把 volatile 和 synchronized 放在一起是因为二者都是关键字，而 synchronized 相比 volatile 除了提供内存可见性外还提供了锁的作用，也就是在同一时刻只允许一个线程访问共享资源，保证了线程安全性。</p><span id="more"></span><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>当使用 volatile 关键字修饰一个变量，Java 内存模型会插入一个<strong>内存屏障</strong>，确保执行到 volatile 变量的时候前面的语句全都执行完，后面的语句全都没有执行， 且前面的语句对 volatile 变量及后面的语句是可见的。</p><p>volatile 可以<strong>保证可见性</strong>，但不保证原子性：</p><ul><li><p>当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新到主内存中去；</p></li><li><p>这个写操作会导致其他线程中的 volatile 变量缓存无效（修改对其他线程立即可见）。</p></li></ul><p><strong>保证可见性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="type">volatile</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">      a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">      flag = <span class="literal">true</span>;             <span class="comment">//2 ，如果没有volatile修饰flag变量就无法保证1-&gt;2</span></span><br><span class="line">  &#125;</span><br><span class="line">  Public <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  a * a;        <span class="comment">//4</span></span><br><span class="line">          System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无法保证原子性</strong>，因为<code>inc++</code>本身不是一个原子操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">volatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">volatileTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">volatileTest</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">// 保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;inc output:&quot;</span> + test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解决可见性的同时解决原子性（后面会学）：</p><p>① synchronized 关键字； ② 重入锁 ReentrantLock； ③ 原子类 AtomicInteger。</p></blockquote><p><strong>单例模式的双重锁</strong></p><p>单例模式的双重锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Penguin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Penguin</span> <span class="variable">m_penguin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免直接通过 new 初始化对象，构造方法应为 private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Penguin</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Penguin <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 用于避免每次调用 getInstance 都需要同步</span></span><br><span class="line">        <span class="keyword">if</span> (m_penguin == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Penguin.class) &#123;</span><br><span class="line">                <span class="comment">// 用于避免在高并发情况下多线程同时创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (m_penguin == <span class="literal">null</span>) &#123;</span><br><span class="line">                    m_penguin = <span class="keyword">new</span> <span class="title class_">Penguin</span>();  <span class="comment">// volatile防止重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_penguin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>m_penguin = new Penguin();</code>并不是一个原子操作，分为三个子步骤：</p><ul><li><p>为 Penguin 对象分配内存</p></li><li><p>将对象赋值给引用 m_penguin</p></li><li><p>调用构造方法初始化成员变量</p></li></ul><p>所以为了防止 JVM 对三个子步骤重排序，使用 volatile 关键字。</p><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="synchronized-x20"><a href="#synchronized-x20" class="headerlink" title="synchronized&#x20;"></a>synchronized&#x20;</h3><p>synchronized 的两大作用：</p><ul><li><p>在同一个时刻只有一个线程可以执行某个方法或某个代码块（存在共享数据的操作）；</p></li><li><p>保证一个线程的变化（共享数据的变化）立即被其他线程所见，实现可见性（完全代替 volatile 关键字）。</p></li></ul><p><strong>三种应用方式</strong></p><ol><li>synchronized 同步方法</li></ol><p>为当前对象 (this) 加锁，进入同步代码前要获取当前对象的锁。</p><p>当创建两个对象时，虽然有同步方法，但是由于两个对象存在两个不同的对象锁，因为 t1 和 t2 使用的是不同的锁，无法保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 两个新实例</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Function</span>());</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Function</span>());</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(<span class="string">&quot;static, i output:&quot;</span> + i);</span><br></pre></td></tr></table></figure><p>为了解决这种情况，也就是让对象锁唯一，只能将 synchronized 将静态方法同步。</p><ul><li>synchronized 同步静态方法</li></ul><p>为当前类的 Class 对象加锁（不属于某个对象，且 Class 类锁和 实例对象锁互不影响）。</p><ul><li>synchronized 同步代码块</li></ul><p>有时候编写的方法代码量很大，而需要同步的代码块只有一小部分，将方法同步大题小做，所以只需对需要同步的代码块执行同步。</p><p>将 synchronized 作用于调用的实例对象 this，this 就是锁的对象，当线程进入同步代码块时就会要求当前线程持有实例对象的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用同步代码块对变量i进行同步操作,锁对象为instance</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CodeBlock</span> <span class="variable">block</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeBlock</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(block);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(block);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized 中的 happens-before 规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MonitorExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;  <span class="comment">//1</span></span><br><span class="line">        a++;                             <span class="comment">//2</span></span><br><span class="line">    &#125;                                    <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;  <span class="comment">//4</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;                       <span class="comment">//5</span></span><br><span class="line">    &#125;                                    <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-8.png"></p><p>synchronized 会防止临界区内的代码和外部代码发生重排序，writer 和 reader 之间存在 happens-before 关系，保证了执行顺序和内存可见性。</p><p>synchronized 属于可重入锁</p><p><img src="image-7.png"></p><p>在线程中首先通过同步代码块获取了 this 实例对象锁，然后调用的<code>increase()</code>方法获取的对象锁也是 this，由于 synchronized 的可重入性，两个获取锁请求临界资源都会成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        <span class="comment">//this,当前实例对象锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            increase();  <span class="comment">// synchronized的可重入性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>synchronized 关键字加在静态方法上，等价于通过同步代码块获取 this.getClass()对象。</p></blockquote><h3 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h3><blockquote><p>Java 6 之后引入了偏向锁和轻量级锁，之前的锁都是重量级锁。</p></blockquote><p><img src="image-11.png" alt="synchronized 的锁状态"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p>大多数情况下锁不仅不存在多线程竞争，而总是由同一线程多次获得。</p></blockquote><p>偏向锁在没有资源竞争（该锁没有被其他线程访问）的前提下消除了同步语句，极大提升了程序的运行性能。</p><p><strong>实现原理</strong></p><blockquote><p>Java 对象的对象头的第一个字宽，Mark Word：储存对象的 hashCode 和锁信息。</p></blockquote><p>一个线程第一次进入同步块时，会在对象头和栈帧的锁记录里存储锁的偏向线程 ID，当下次线程进入这个同步块时，会检查锁的 Mark Word 里是否存放的自己的线程 ID。</p><p>如果不是，则说明有其他的线程来竞争偏向锁，这时候如果原先的线程不存在了，会将 Mark Word 中的线程 ID 改为当前线程；如果原先的线程仍然存在，则暂停原先的线程，偏向锁升级为轻量级锁进行锁竞争。</p><p><img src="image-12.png"></p><p><strong>撤销偏向锁</strong></p><p>等到线程竞争才释放锁。当偏向锁升级为轻量级锁时，要暂停偏向锁的线程，重置偏向锁标识，这个过程的开销很大：</p><p><img src="image-4.png"></p><p>如果程序里的锁通常处于竞争状态，那么偏向锁不是一个好的选择。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>多个线程在不同时段获取同一把锁，不存在锁竞争的情况，也就没有线程阻塞。</p><p>JVM 为每个线程在当前线程的栈帧中创建存储锁记录的空间，Displayed Mark Word。如果一个线程获取锁时发现是轻量级锁，会将锁的 Mark Word 复制到自己的 Displayed Mark Word 里面（存的是未改变前的 Mark Word 的副本）。</p><p><strong>工作原理</strong></p><p>当一个线程要获取锁时，它会复制对象的 Mark Word 到自己线程的栈中，并通过 CAS 操作尝试修改对象头的 Mark Word。如果成功，表示该线程获取了锁；如果失败，表示另一个线程已经持有了该锁，当前线程就尝试自旋来获取锁，如果自旋失败那么这个线程就会阻塞，同时锁升级为重量级锁。</p><blockquote><p>自旋：一般通过循环消耗 CPU 时间，不断尝试获取锁。</p></blockquote><p><strong>轻量级锁的释放</strong></p><p>当前线程会使用 CAS 将 Displayed Mark Word 的内容副本复制回锁的 Mark Word 中，如果没有竞争则复制会成功；如果有其他线程因为自旋失败而导致轻量级锁被升级为重量级锁，复制会失败，此时会释放锁并唤醒被阻塞的线程。</p><p><img src="image-9.png" alt="轻量级锁工作原理"></p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。</p><blockquote><p>当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</p></blockquote><h3 id="锁的升级流程"><a href="#锁的升级流程" class="headerlink" title="锁的升级流程"></a>锁的升级流程</h3><p>每个线程在准备获取共享资源时，</p><ol><li><p>检查 Mark Word 里面是否放了自己的线程 ID，如果有则当前线程持有偏向锁；</p></li><li><p>如果 Mark Word 里面没有自己的线程 ID，锁升级，并通过 Mark Word 里面的线程 ID 通知持有偏向锁的线程暂停，之前线程将 Mark Word 中线程 ID 置空<strong>（准备升级为轻量级锁）</strong>；</p></li><li><p>两个线程都把锁对象的 HashCode 复制到自己的 Displayed Mark Word 中，然后通过 CAS 操作将锁对象的 Mark Word 内容修改为自己的 Displayed Mark Word 地址的方式来竞争轻量级锁；</p></li><li><p>成功的执行 CAS 获取轻量级锁，失败的进入自旋；</p></li><li><p>自旋线程在自旋中成功获取锁——之前持有锁的线程执行完成并释放了共享资源，则整个线程仍处于轻量级锁状态，如果自旋失败则<strong>升级为重量级锁</strong>；</p></li><li><p>自旋的线程进行阻塞，等待之前持有轻量级锁的线程完成锁释放并唤醒自己。</p></li></ol><p><strong>重量级锁：</strong>当另外一个线程执行到同步块的时候，由于它没有对应 monitor 的所有权，就会被阻塞，此时控制权只能交给操作系统，由操作系统来负责线程间的调度和线程的状态变更，造成频繁的上下文切换。</p><p><strong>轻量级锁：</strong>如果 CPU 通过 CAS 就能处理好加锁、释放锁，这样就不会有上下文的切换。</p><p><strong>偏向锁：</strong>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，同一个线程反复获取锁，如果还按照 CAS 的方式获取锁，也是有一定代价的。</p><h3 id="不同场景下的锁策略"><a href="#不同场景下的锁策略" class="headerlink" title="不同场景下的锁策略"></a>不同场景下的锁策略</h3><ul><li><p>偏向锁：无竞争的情况下，只有一个线程进入临界区，采用偏向锁</p></li><li><p>轻量级锁：多个线程可以交替进入临界区，采用轻量级锁</p></li><li><p>重量级锁：多线程同时进入临界区，交给操作系统互斥量来处理</p></li></ul><h2 id="CAS-x20"><a href="#CAS-x20" class="headerlink" title="CAS&#x20;"></a>CAS&#x20;</h2><ul><li><p>悲观锁：认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加锁，以保证临界区的程序同一时间只有一个线程在执行。</p></li><li><p>乐观锁：认为对共享资源的访问没有冲突，无需加锁也无需等待，一旦线程之间发生冲突，通过 CAS 保证线程执行的安全性。</p></li></ul><p>CAS 有三个值：① <strong>V</strong> 要更新的变量(var)；② <strong>E</strong> 预期值(expected)；③ <strong>N</strong> 新值(new)。</p><p>CAS 意为 compare and swap，比较并交换，判断 V 是否等于 E，如果是则将 V 更新为 N，如果不是则说明已经有其他线程更新了 V，当前线程放弃更新。</p><p><img src="image-5.png" alt="CAS 比较并交换的例子"></p><p><strong>CAS 原理</strong></p><p>Java 中 Unsafe 类中的 native 方法交给底层 JVM 使用 C 语言或 C++ 来实现 。对 CAS 的实现是通过 C++ 实现的，它的具体实现和操作系统、CPU 都有关系。</p><h3 id="CAS-的原子性"><a href="#CAS-的原子性" class="headerlink" title="CAS 的原子性"></a>CAS 的原子性</h3><p><strong>CAS 是一条 CPU 的原子指令</strong>，从 CPU 层面保证了它的原子性。当多个线程同时使用 CAS 操作一个变量只有一个胜出，其余都会失败（失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作）。</p><p>以 AtomicInteger 类的<code>getAndAdd(int delta)</code>方法为例，AtomicInteger 类的方法是调用 Unsafe 类的方法实现的：</p><p><img src="image-10.png" alt="Unsafe类的方法"></p><p><img src="image-6.png"></p><h3 id="CAS-的三大问题"><a href="#CAS-的三大问题" class="headerlink" title="CAS 的三大问题"></a>CAS 的三大问题</h3><p><strong>ABA 问题</strong></p><p>就是一个值原来是 A，变成了 B，又变回了 A，实际上的值更新了两次，但是 CAS 检测不出来。</p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。</p><p><img src="image-3.png"></p><p><img src="image-1.png" alt="atomic包下的AtomicStampedReference类"></p><p><strong>长时间自旋</strong></p><p>CAS 不成功会进行自旋，如果自旋长时间不成功会占用大量的 CPU 资源。</p><p>解决思路是让 JVM 支持处理器提供的 pause 指令。</p><p><img src="image-2.png"></p><p><strong>多个共享变量的原子操作</strong></p><p>当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性。</p><p>解决方案通常有两种：</p><ol><li>使用 AtomicReference 类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</li></ol><p><img src="image.png"></p><ul><li>使用锁，锁内的临界区代码可以保证只有当前线程能操作。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之所以把 volatile 和 synchronized 放在一起是因为二者都是关键字，而 synchronized 相比 volatile 除了提供内存可见性外还提供了锁的作用，也就是在同一时刻只允许一个线程访问共享资源，保证了线程安全性。&lt;/p&gt;</summary>
    
    
    
    <category term="Java并发" scheme="https://kicheng.github.io/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发编程" scheme="https://kicheng.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://kicheng.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型(JMM)</title>
    <link href="https://kicheng.github.io/2024/09/20/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kicheng.github.io/2024/09/20/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-09-20T14:09:44.000Z</published>
    <updated>2024-09-20T14:09:11.358Z</updated>
    
    <content type="html"><![CDATA[<p>Java 内存模型（Java Memory Model，JMM）是个抽象的概念，负责 Java 并发中每个线程工作内存和共享主存之间的交互。JMM 很重要，也是后端程序员面试的重点。</p><span id="more"></span><p>Java 内存模型（Java Memory Model，JMM）是个抽象的概念，负责 Java 并发中每个线程工作内存和共享主存之间的交互。</p><p><img src="image-12.png"></p><p>JMM 定义了线程与主存之间的抽象关系：</p><p><img src="image-8.png"></p><p><strong>线程间通信</strong>必须经过主存：① 线程 A 将本地内存 A 中更新过的共享变量刷新到主存中；② 线程 B 到主存中去读取线程 A 之前更新过的共享变量。</p><p><img src="image-6.png"></p><blockquote><p>说到 JMM 正好复习一下跟它很像的 <strong>Java 运行时内存区域</strong></p></blockquote><p>Java 运行时内存区域描述的是在 JVM 运行时，如何具体地将内存划分为不同的区域：</p><p><img src="image-7.png"></p><p>JMM 意在解决 Java 多线程并发编程中主内存和工作内存之间如何安全执行操作的问题：</p><p><img src="image-11.png"></p><p><strong>JMM 的指令重排</strong></p><p>计算机在执行程序时为了性能，编译器和处理器往往会对指令进行重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line">d = e - f ;</span><br></pre></td></tr></table></figure><p>加载完 b 和 c，可以一起把 e 和 f 都加载了，这样再去执行两个 add 操作就减少了停顿，而且对程序（串行）是无影响的。也就是说，<strong>重排序可以保证程序在串行条件下语义一致，但无法保证在多线程条件下的语义也一致。</strong></p><blockquote><p>指令重排序有三类:</p><ul><li><p>编译器优化重排</p></li><li><p>处理器执行并行重排</p></li><li><p>内存系统重排</p></li></ul></blockquote><p><strong>JMM 和顺序一致性模型</strong></p><p>如果程序是正确同步的（不包含数据竞争），程序的执行将具备顺序一致性。即程序的执行结果和在<strong>顺序一致性模型</strong>（理想化的参考模型）中的执行结果相同。</p><blockquote><p>正确同步：使用volatile、final、synchronized等关键字实现的正确流程下的同步。</p></blockquote><p>顺序一致性模型的两大特性：</p><p><img src="image-2.png"></p><p>为了解释上述两大特性（假设正确使用了同步）A 线程的 3 个操作执行后释放锁，B 线程获取同一个锁。那么在顺序一致性模型中的执行效果如下所示：</p><p><img src="image-1.png" alt="正确使用同步"></p><p>就算没有正确使用同步，操作的执行整体上无序，但是对于每个线程来说都按照了程序的执行顺序，且每个线程都只能看到如下的这个执行顺序（操作立刻对所有线程可见）：</p><p><img src="image-4.png" alt="不正确使用同步"></p><p>但是 <strong>JMM 中没有顺序一致性</strong>的保证。</p><p><img src="image-9.png"></p><p>在 JMM 中，比如当前线程 A 把写过的数据缓存在本地内存中，在没有刷新到主存之前线程 B 是对该更改不可见的，所以线程 A 和线程 B 看到的执行顺序是不同的。</p><p>JMM 中处在临界区内的代码可以发生重排序而对外部线程不可见，也就是说在不改变程序执行结果（单线程程序和正确同步了的多线程程序）的前提下提高了执行效率，为编译器和处理器的优化打开了方便。</p><p>对于<strong>未同步的线程</strong>：</p><p><img src="image.png" alt="未同步多线程的最小安全性"></p><p><img src="image-10.png"></p><p>JMM 提供了** happens-before 规则<strong>，保证了</strong>强内存可见性**。</p><blockquote><p>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量值，另一个线程能够立刻看到修改值。</p></blockquote><p><img src="image-5.png"></p><p>也就是说，</p><ul><li><p>符合 happens-before 规则，限定了操作 A 和操作 B 的理论执行顺序，就意味着内存可见性的保证。</p></li><li><p>在符合 happens-before 规则的前提下，A 和 B 可能会被 JMM 允许重排序，也可能不被允许，这取决于是否会改变程序的执行结果。</p></li></ul><p>常见的符合 happens-before 关系：</p><ul><li><p>同一个线程中的每一个操作</p></li><li><p>对同一个锁的解锁操作总是 happens-before 对该锁的加锁</p></li><li><p>对 volatile 修饰的变量的写总是 happens-before 对该变量的读</p></li><li><p>A -&gt; B 且 B -&gt; C，总是有传递性 A -&gt; C</p></li><li><p>start 规则</p></li><li><p>join 规则&#x20;</p></li></ul><p><img src="image-3.png"></p><p>比如对上述单线程中的 A、B、C 操作，JMM 对两类重排序有不同的策略：</p><ul><li><p>不会改变程序执行结果的重排序：A -&gt; B，JMM 对编译器和处理器不做要求，允许这种重排序；</p></li><li><p>会改变程序执行结果的重排序：A -&gt; C，JMM 要求编译器和处理器禁止这种重排序。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 内存模型（Java Memory Model，JMM）是个抽象的概念，负责 Java 并发中每个线程工作内存和共享主存之间的交互。JMM 很重要，也是后端程序员面试的重点。&lt;/p&gt;</summary>
    
    
    
    <category term="Java并发" scheme="https://kicheng.github.io/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发编程" scheme="https://kicheng.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="java" scheme="https://kicheng.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5830-Lab6</title>
    <link href="https://kicheng.github.io/2024/09/18/MIT6.5830-Lab6/"/>
    <id>https://kicheng.github.io/2024/09/18/MIT6.5830-Lab6/</id>
    <published>2024-09-18T11:09:44.000Z</published>
    <updated>2024-10-08T07:00:30.875Z</updated>
    
    <content type="html"><![CDATA[<p>MIT6.5830 的数据库课程。Lab6 主要是完成数据库的 STEAL / NO FORCE 策略，也就是基于 undo log 的日志回滚和基于 redo log 的崩溃恢复。</p><span id="more"></span><p><img src="image.png"></p><blockquote><p>Undo log是什么</p></blockquote><p>每当InnoDB引擎要对一条记录进行修改、删除、新增时，要把回滚时需要的信息都记录到undo log里，比如：</p><ul><li><p>在<strong>插入</strong>一条记录时，要把这条记录的主键记录下来，方便回滚时根据主键将对应的记录删除；</p></li><li><p>在<strong>删除</strong>一条记录时，要把这条记录的所有内容都记录下来，方便回滚时把这些内容组成的记录插入回去；</p></li><li><p>在<strong>更新</strong>一条记录时，要把更新列的旧值记录下来，方便回滚时把该记录的旧值复原回去。</p></li></ul><p><img src="image-1.png"></p><blockquote><p>Redo log是什么</p></blockquote><p>为什么要有Redo log：</p><p>首先明确一下MySQL在查询、更新中的流程：当BufferPool中没有对应的数据页时，首先将数据页从磁盘读取到BufferPool（内存）中，如果需要增删改操作，只需要修改BufferPool中的数据，并将BufferPool中的数据页设置为脏页，<strong>为了减少磁盘I/O</strong>，不会立刻将脏页写入磁盘，后续由后台线程选择一个合适时机将脏页写入磁盘。</p><p>BufferPool提高了读写效率，但是BufferPool是基于内存的，一旦断电重启，没来得及落盘的脏页数据就会丢失。</p><p>为了防止断电数据丢失的问题，每当更新一条数据时，InnoDB引擎就会更新内存+对这个页的修改以redo log的形式记录下来，这就算更新完成了。（我的理解：如果每次把脏页直接刷新到磁盘，就算在数据页中只涉及一条记录的更新也会被标记为脏页，这样大大增加了磁盘I/O的开销，所以通过redo log以简短方式记录下来，而且顺序写相比随机写更高效）</p><p>redo日志的格式：对<strong>表空间X</strong>的<strong>数据页Y</strong>的<strong>偏移Z</strong>做了<strong>A修改</strong>。</p><p>每当一个事务完成提交，会产生多条上述格式的redo log日志，只需要在事务提交时先将redo log持久化到磁盘中即可；当系统出现崩溃时，可以在MySQL重启后根据磁盘中的redo log日志内容将所有数据恢复到最新状态。</p><p>Ques：若是在redo log还没有持久化到磁盘中已经出现系统崩溃呢？</p><p><img src="image-2.png"></p><blockquote><p>redo log和undo log区别</p></blockquote><p>这两种都属于InnoDB存储引擎的日志，区别在于:</p><ul><li><p>undo log 发生在事务执行过程中，记录了此次<strong>事务开始前</strong>的数据状态，记录的是更新<strong>之前</strong>的值。</p></li><li><p>redo log 发生在事务结束后，记录了此次<strong>事务完成后</strong>的数据状态，记录的是更新<strong>之后</strong>的值。</p></li></ul><p><img src="image-3.png"></p><h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><p>在Lab4中为了简化实现，数据库在 BufferPool 中实现的是 NO STEAL / FORCE 策略。在 Lab6 中要实现基于日志的中止回滚（undo log）和基于日志的崩溃恢复（redo log）。</p><p>现在 DBMS 常用的都是 STEAL / NO FORCE 策略，因此都需要记录 undo log 和 redo log。&#x20;</p><ul><li><p>BufferPool 是在内存上，由于断电等故障会造成数据丢失，因此需要回滚事务到提交前的状态需要 undo 日志，来实现 STEAL。对于已经提交的事务也不需要强制将数据立即刷入磁盘，而是通过记录的 redo 日志实现 NO FORCE。</p></li><li><p>对于日志的 NO FORCE 还有一个优点是将磁盘的随机写改为顺序写（将数据直接写入磁盘需要大量的随机 I/O，而实现 redo log 只需要追加一条日志改变为顺序 I/O）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionId tid)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchElementException, IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Database.getBufferPool()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            preAppend();</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">            raf.seek(tidToFirstLogRecord.get(tid.getId()));  <span class="comment">// 指向tid事务相关的第一个日志记录位置</span></span><br><span class="line">            HashSet&lt;PageId&gt; rollbackPages = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  <span class="comment">// 记录已经回滚的page，避免同一个页面被多次回滚</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">curType</span> <span class="operator">=</span> raf.readInt();  <span class="comment">// 读取日志类型</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">curTid</span> <span class="operator">=</span> raf.readLong();  <span class="comment">// 读取事务id</span></span><br><span class="line">                    <span class="keyword">switch</span> (curType) &#123;</span><br><span class="line">                        <span class="keyword">case</span> BEGIN_RECORD:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> ABORT_RECORD:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> COMMIT_RECORD:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> UPDATE_RECORD:</span><br><span class="line">                            <span class="type">Page</span> <span class="variable">beforeImg</span> <span class="operator">=</span> readPageData(raf);  <span class="comment">// 更改前的页面状态</span></span><br><span class="line">                            <span class="type">Page</span> <span class="variable">afterImg</span> <span class="operator">=</span> readPageData(raf);  <span class="comment">// 更改后的页面状态</span></span><br><span class="line">                            <span class="keyword">if</span> (curTid == tid.getId() &amp;&amp; !rollbackPages.contains(beforeImg.getId())) &#123;</span><br><span class="line">                                rollbackPages.add(beforeImg.getId());</span><br><span class="line">                                <span class="type">DbFile</span> <span class="variable">file</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(beforeImg.getId().getTableId());</span><br><span class="line">                                file.writePage(beforeImg);</span><br><span class="line">                                Database.getBufferPool().removePage(afterImg.getId());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CHECKPOINT_RECORD:</span><br><span class="line">                            <span class="type">int</span> <span class="variable">keySize</span> <span class="operator">=</span> raf.readInt();</span><br><span class="line">                            <span class="keyword">while</span> (keySize-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="type">long</span> <span class="variable">key</span> <span class="operator">=</span> raf.readLong();</span><br><span class="line">                                <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> raf.readLong();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 略过offset</span></span><br><span class="line">                    raf.readLong();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">                    <span class="comment">// 读取到文件末尾</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><p>日志中的 CHECKPOINT 会导致数据强制刷盘，而 CHECKPOINT 的触发条件也仅仅是周期性的定时检查，因此在 CHECKPOINT 阶段可能有未提交的事务也有已提交的事务，前者需要 undo 回滚，后者需要 redo 恢复。</p><ul><li><p>处理未提交的事务利用 beforeImage 进行 undo 回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> tid :beforeImgs.keySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!committed.contains(tid)) &#123;</span><br><span class="line">        <span class="comment">// 未提交的事务</span></span><br><span class="line">        List&lt;Page&gt; pages = beforeImgs.get(tid);</span><br><span class="line">        <span class="keyword">for</span> (Page undo : pages) &#123;</span><br><span class="line">            Database.getCatalog().getDatabaseFile(undo.getId().getTableId()).writePage(undo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理已提交事务利用 afterImage 进行 redo 恢复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> tid : committed) &#123;</span><br><span class="line">    <span class="comment">// 已提交的事务</span></span><br><span class="line">    <span class="keyword">if</span> (afterImgs.containsKey(tid)) &#123;</span><br><span class="line">        List&lt;Page&gt; pages = afterImgs.get(tid);</span><br><span class="line">        <span class="keyword">for</span> (Page redo : pages) &#123;</span><br><span class="line">            Database.getCatalog().getDatabaseFile(redo.getId().getTableId()).writePage(redo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>完整实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Database.getBufferPool()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            recoveryUndecided = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">            raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(logFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            Map&lt;Long, List&lt;Page&gt;&gt; beforeImgs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            Map&lt;Long, List&lt;Page&gt;&gt; afterImgs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            HashSet&lt;Long&gt; committed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="type">long</span> <span class="variable">recoverOffset</span> <span class="operator">=</span> getRecoverOffset();</span><br><span class="line">            <span class="keyword">if</span>(recoverOffset != -<span class="number">1L</span>)&#123;</span><br><span class="line">                raf.seek(recoverOffset);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">curType</span> <span class="operator">=</span> raf.readInt();</span><br><span class="line">                    <span class="type">long</span> <span class="variable">curTid</span> <span class="operator">=</span> raf.readLong();</span><br><span class="line">                    <span class="keyword">switch</span> (curType)&#123;</span><br><span class="line">                        <span class="keyword">case</span> COMMIT_RECORD:</span><br><span class="line">                            committed.add(curTid);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> CHECKPOINT_RECORD:</span><br><span class="line">                            <span class="comment">// 检查点记录用于崩溃恢复，暂时略过</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">keySize</span> <span class="operator">=</span> raf.readInt();</span><br><span class="line">                            <span class="keyword">while</span> (keySize-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                raf.readLong();</span><br><span class="line">                                raf.readLong();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> UPDATE_RECORD:</span><br><span class="line">                            <span class="type">Page</span> <span class="variable">beforeImg</span> <span class="operator">=</span> readPageData(raf);</span><br><span class="line">                            <span class="type">Page</span> <span class="variable">afterImg</span> <span class="operator">=</span> readPageData(raf);</span><br><span class="line">                            List&lt;Page&gt; undoList = beforeImgs.getOrDefault(curTid,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                            List&lt;Page&gt; redoList = afterImgs.getOrDefault(curTid,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                            undoList.add(beforeImg);</span><br><span class="line">                            redoList.add(afterImg);</span><br><span class="line">                            beforeImgs.put(curTid,undoList);</span><br><span class="line">                            afterImgs.put(curTid,redoList);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 略过offset</span></span><br><span class="line">                    raf.readLong();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (EOFException e)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理未提交的事务利用before进行undo</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> tid :beforeImgs.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!committed.contains(tid)) &#123;</span><br><span class="line">                    List&lt;Page&gt; pages = beforeImgs.get(tid);</span><br><span class="line">                    <span class="keyword">for</span> (Page undo : pages) &#123;</span><br><span class="line">                        Database.getCatalog().getDatabaseFile(undo.getId().getTableId()).writePage(undo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  处理已提交事务利用after进行redo</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> tid : committed) &#123;</span><br><span class="line">                <span class="keyword">if</span> (afterImgs.containsKey(tid)) &#123;</span><br><span class="line">                    List&lt;Page&gt; pages = afterImgs.get(tid);</span><br><span class="line">                    <span class="keyword">for</span> (Page redo : pages) &#123;</span><br><span class="line">                        Database.getCatalog().getDatabaseFile(redo.getId().getTableId()).writePage(redo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;MIT6.5830 的数据库课程。Lab6 主要是完成数据库的 STEAL / NO FORCE 策略，也就是基于 undo log 的日志回滚和基于 redo log 的崩溃恢复。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://kicheng.github.io/categories/MySQL/"/>
    
    
    <category term="database" scheme="https://kicheng.github.io/tags/database/"/>
    
    <category term="mysql" scheme="https://kicheng.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5830-Lab5</title>
    <link href="https://kicheng.github.io/2024/09/08/MIT6.5830-Lab5/"/>
    <id>https://kicheng.github.io/2024/09/08/MIT6.5830-Lab5/</id>
    <published>2024-09-08T11:09:44.000Z</published>
    <updated>2024-09-19T07:31:10.457Z</updated>
    
    <content type="html"><![CDATA[<p>MIT6.5830 的数据库课程。Lab5 主要是完成 InnoDB 的索引，完成 B+ 树的查询、插入、删除操作。</p><span id="more"></span><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="InnoDB存储数据"><a href="#InnoDB存储数据" class="headerlink" title="InnoDB存储数据"></a>InnoDB存储数据</h2><p>InnoDB是以数据页（默认16KB）为单位进行I/O读写的。</p><p><img src="image-30.png"></p><p>多个数据页之间是以双向链表结构连接（逻辑上的连续）的，数据页中的指针存在于File Header文件头。</p><p><img src="image-28.png"></p><h3 id="数据页中的数据检索"><a href="#数据页中的数据检索" class="headerlink" title="数据页中的数据检索"></a>数据页中的数据检索</h3><p>数据页的作用是存储数据，重点就是User Records用户记录部分：数据页中的<strong>记录</strong>按照主键顺序组成<strong>单向链表</strong>。单向链表的特点是插入和删除非常方便，但是检索效率低——因此数据页中需要有一个页目录，起到快捷索引的功能。</p><p><img src="image-25.png"></p><p>上图要注意的细节：</p><ul><li><p>每个分组最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段；</p></li><li><p>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量被按照顺序存储为槽slot，每个槽相当于指针指向了不同组的最后一条记录；</p></li></ul><p>通过页目录来索引记录时，由于页目录的槽是按顺序存储的，可以使用二分法快速定位要查询的记录在哪个槽的分组；再遍历槽所在分组的所有记录。</p><p><img src="image-29.png"></p><p>为什么槽slot存储的不是一个分组里的最小记录？</p><blockquote><p>记录分组中记录的规定：</p><p><img src="image-27.png"></p></blockquote><h3 id="B-树的数据检索"><a href="#B-树的数据检索" class="headerlink" title="B+树的数据检索"></a>B+树的数据检索</h3><p>在多个数据页之间，需要考虑如何建立索引才能方便的定位到指定的页，磁盘的I/O次数对索引的使用效率至关重要——<strong>InnoDB 采用了 B+ 树作为索引</strong>。</p><blockquote><ol><li><p>矮胖的 B+ 树需要的磁盘I/O次数更少</p></li><li><p>B+ 树（相对于B树）更加适合关键字的范围查找</p></li></ol></blockquote><p>B树和B+树的对比</p><p><img src="image-23.png"></p><p>B+ 树的每个节点都是一个数据页，通过上图可以看出B+树的特点：</p><ul><li><p>只有叶子节点才存放数据，非叶子节点只存放目录项作为索引；</p></li><li><p>同层的节点按照索引键大小排序构成一个双向链表，便于范围查询。（依据什么）</p></li></ul><p><img src="image-24.png"></p><h2 id="B-树的增删查操作"><a href="#B-树的增删查操作" class="headerlink" title="B+树的增删查操作"></a>B+树的增删查操作</h2><blockquote><p>B+树对于非叶子节点的子节点和索引的个数，定义方式可能会有不同，有的是说<strong>非叶子节点的子节点的个数为 M 阶，而索引的个数为 M-1</strong>（这个是维基百科里的定义），因此下面关于 B+树数据结构操作都是基于这个。但是在前面介绍 B+树时，说的是<strong>非叶子节点中有多少个子节点，就有多少个索引</strong> ，主要是 MySQL 用到的 B+树就是这个特性。</p></blockquote><p><img src="image.png" alt="mysql中用到的B+树（非叶子节点子节点个数=索引个数）"></p><h3 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h3><p>因为B树的每个节点既存索引又存记录，所以相较于B+树平均时间复杂度更低。但是在相同的数据量情况下，B+树的非叶子节点可以存储更多的索引，所以B+树更加矮胖，查询底层节点所需的磁盘I/O更小。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><blockquote><p>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大或最小。</p></blockquote><ol><li><p>若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</p></li><li><p>针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于 m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前 m/2 个记录，右结点包含剩下的记录，将第 m/2+1 个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点，右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</p></li><li><p>针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前 (m-1)/2 个key，右结点包含后 m-(m-1)/2 的个key，将第 m/2 个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</p></li></ol><p><img src="image-26.png" alt="例如5阶B+树的节点2 ≤ key的数量 ≤ 4"></p><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ol><li><p>删除叶子结点中对应的key，删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束，否则执行第二步。</p></li><li><p>若兄弟节点的key有富余，向兄弟节点借一个记录，同时用借到的key替换父节点中的key。</p></li><li><p>若兄弟节点中没有富余的key，则当前节点和兄弟节点合并为一个新的叶子节点，并删除父节点中key（父节点中的这个key两边的孩子指针就变成了一个指针）。</p></li><li><p>若索引类型节点的key个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束，否则执行第五步。</p></li><li><p>若兄弟节点有富余，父节点key下移，兄弟节点key上移，删除结束。</p></li><li><p>若兄弟节点也没有富余，则当前节点和兄弟节点以及父节点的下移key合并为一个新节点。</p></li></ol><p>删除22：</p><p><img src="image-20.png"></p><p>删除15：</p><p><img src="image-21.png"></p><p>删除7：</p><p><img src="image-22.png"></p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助。而 B 树没有将所有的叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，涉及到更多节点的磁盘I/O，范围查询效率远不如B+树。</p><p><strong>InnoDB选用 B+ 树的原因（前面也反复提及）</strong></p><ul><li><p>B+ 树的磁盘读写I/O代价更低</p></li><li><p>B+ 树的查询效率更加稳定</p></li><li><p>B+ 树便于范围查询（数据库查询的常态）</p></li></ul><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><blockquote><p>实现findLeafPage()方法，递归返回需要的叶子节点。</p></blockquote><p><img src="image-17.png"></p><p><img src="image-16.png"></p><p>lab中给出的outline:</p><ul><li><p>给定值1，此函数应返回第一个叶页。同样，给定值8，该函数应返回第二页。而在某种case下，如果给我们一个键值6。可能有重复的键，所以两个叶页上可能都有6。在这种情况下，函数应该返回第一个（左）叶页。</p><p><img src="image-19.png"></p></li><li><p>递归的搜索页面，直到搜索到所需的叶子节点页面。如果 BTreePageId.LEAF 则表明这是叶子页面退出递归，否则则是内部页面，需要遍历内部页面中的entrys，并与每个key值做比较，递归进入到下一层的节点。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BTreeLeafPage <span class="title function_">findLeafPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages, BTreePageId pid, Permissions perm,</span></span><br><span class="line"><span class="params">                                   Field f)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 共有四种节点类型: ROOT_PTR、INTERNAL、LEAF、HEADER</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> pid.pgcateg();  <span class="comment">// 返回这个页面的类别</span></span><br><span class="line">    <span class="comment">// 叶子节点直接返回该节点的pid页面，同时也是递归结束的条件</span></span><br><span class="line">    <span class="keyword">if</span> (type == BTreePageId.LEAF) &#123;</span><br><span class="line">        <span class="keyword">return</span> (BTreeLeafPage) getPage(tid, dirtypages, pid, perm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非叶子节点直接使用READ权限遍历entries</span></span><br><span class="line">    <span class="type">BTreeInternalPage</span> <span class="variable">internalPage</span> <span class="operator">=</span> (BTreeInternalPage) getPage(tid, dirtypages, pid, Permissions.READ_ONLY);</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; it = internalPage.iterator();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        entry = it.next();</span><br><span class="line">        <span class="comment">// 如果f为空，递归查找左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> findLeafPage(tid, dirtypages, entry.getLeftChild(), perm, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entry.getKey().compare(Op.GREATER_THAN_OR_EQ, f)) &#123;</span><br><span class="line">            <span class="keyword">return</span> findLeafPage(tid, dirtypages, entry.getLeftChild(), perm, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一层节点为叶子节点，且内部节点的entry不应该为空</span></span><br><span class="line">    <span class="keyword">assert</span> entry != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLeafPage(tid, dirtypages, entry.getRightChild(), perm, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-15.png"></p><p><img src="image-11.png"></p><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><blockquote><p>完成B+树的插入操作，实现splitLeafPage()方法和splitInternalPage()方法。</p></blockquote><p>Exercise1中的任务可以查找我们应该插入元组的正确叶页，但是每个页面的插槽数量有限，尝试将元组插入已满的叶页会导致该页面分裂，以便元组在均匀分布在两个页面当中。</p><p><img src="image-18.png"></p><ul><li><p>叶节点的分裂需要复制一份<strong>数据的备份</strong>到父节点。而内部节点不需要刻意维护数据在底层，所以其分裂的key是被<strong>挤到</strong>父节点的。</p></li><li><p>叶子节点的分裂还需要维护两个节点之间的指针指向。</p></li></ul><ol><li><p><code>splitLeafPage()</code>：当叶子节点中的元组数量等于N时，将其拆分为两个叶节点，并返回插入tuple所在的page。</p><p><img src="image-12.png" alt="lab中的outline提示"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BTreeLeafPage <span class="title function_">splitLeafPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages, BTreeLeafPage page, Field field)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 1、先处理子节点</span></span><br><span class="line">    <span class="comment">// 创建一个右叶子结点，并进行均匀分配</span></span><br><span class="line">    <span class="type">BTreeLeafPage</span> <span class="variable">newRightPage</span> <span class="operator">=</span> (BTreeLeafPage) getEmptyPage(tid, dirtypages, BTreePageId.LEAF);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numTuples</span> <span class="operator">=</span> page.getNumTuples();</span><br><span class="line">    Iterator&lt;Tuple&gt; reverseIt = page.reverseIterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numTuples / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> reverseIt.next();</span><br><span class="line">        page.deleteTuple(tuple);</span><br><span class="line">        newRightPage.insertTuple(tuple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// leftNode &lt;=&gt; page &lt;=&gt; rightNode 需要变成 leftNode &lt;=&gt; (page &lt;=&gt; newRightPage) &lt;=&gt; rightNode</span></span><br><span class="line">    <span class="type">BTreePageId</span> <span class="variable">rightSiblingId</span> <span class="operator">=</span> page.getRightSiblingId();  <span class="comment">// 获取该页右侧同级的id</span></span><br><span class="line">    <span class="type">BTreeLeafPage</span> <span class="variable">rightNode</span> <span class="operator">=</span> rightSiblingId == <span class="literal">null</span> ? <span class="literal">null</span> : (BTreeLeafPage) getPage(tid, dirtypages, rightSiblingId, Permissions.READ_ONLY);</span><br><span class="line">    <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode.setLeftSiblingId(newRightPage.getId());</span><br><span class="line">        newRightPage.setRightSiblingId(rightNode.getId());</span><br><span class="line">        dirtypages.put(rightNode.getId(), rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">    page.setRightSiblingId(newRightPage.getId());</span><br><span class="line">    newRightPage.setLeftSiblingId(page.getId());</span><br><span class="line">    dirtypages.put(newRightPage.getId(), newRightPage);</span><br><span class="line">    dirtypages.put(page.getId(), page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、再处理父节点</span></span><br><span class="line">    <span class="comment">// &quot;复制&quot;中间节点并插入父节点中，并设置指针</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">midKey</span> <span class="operator">=</span> newRightPage.iterator().next().getField(keyField);</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">insertEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeEntry</span>(midKey, page.getId(), newRightPage.getId());</span><br><span class="line">    <span class="comment">// 获取具有读写权限的父页面，如果父节点中key的数量到达了n-1，则会调用splitInternalPage()方法继续递归，最终返回一个可以插入新key的内部节点页面</span></span><br><span class="line">    <span class="type">BTreeInternalPage</span> <span class="variable">parentPage</span> <span class="operator">=</span> getParentWithEmptySlots(tid, dirtypages, page.getParentId(), field);</span><br><span class="line">    parentPage.insertEntry(insertEntry);</span><br><span class="line">    dirtypages.put(parentPage.getId(), parentPage);</span><br><span class="line">    updateParentPointers(tid, dirtypages, parentPage);  <span class="comment">// 设置指针指向</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回应该插入新元组的叶页</span></span><br><span class="line">    <span class="keyword">if</span> (field.compare(Op.GREATER_THAN_OR_EQ, midKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> newRightPage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>splitInternalPage()</code>：当内部节点中的元组数量等于N时，将其拆分为两个内部节点</p><p><img src="image-13.png"></p><p><img src="image-14.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BTreeInternalPage <span class="title function_">splitInternalPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                                           BTreeInternalPage page, Field field)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 创建一个内部节点，并进行均匀分配</span></span><br><span class="line">    <span class="type">BTreeInternalPage</span> <span class="variable">newRightPage</span> <span class="operator">=</span> (BTreeInternalPage) getEmptyPage(tid, dirtypages, BTreePageId.INTERNAL);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numEntries</span> <span class="operator">=</span> page.getNumEntries();</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; reverseIt = page.reverseIterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numEntries / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 与分裂叶子节点不同的是内部节点的单位是Entries，用于唯一标示的则是entry中的RecordId，而插入操作则会改变RecordId</span></span><br><span class="line">        <span class="comment">// 因此需要先删除后插入</span></span><br><span class="line">        <span class="type">BTreeEntry</span> <span class="variable">entry</span> <span class="operator">=</span> reverseIt.next();</span><br><span class="line">        <span class="comment">// 删除哪个child</span></span><br><span class="line">        page.deleteKeyAndRightChild(entry);</span><br><span class="line">        newRightPage.insertEntry(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子节点&quot;挤到&quot;父节点中，并设置指针指向</span></span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">midEntry</span> <span class="operator">=</span> reverseIt.next();</span><br><span class="line">    page.deleteKeyAndRightChild(midEntry);</span><br><span class="line">    midEntry.setLeftChild(page.getId());</span><br><span class="line">    midEntry.setRightChild(newRightPage.getId());</span><br><span class="line">    <span class="type">BTreeInternalPage</span> <span class="variable">parent</span> <span class="operator">=</span> getParentWithEmptySlots(tid, dirtypages, page.getParentId(), midEntry.getKey());</span><br><span class="line">    parent.insertEntry(midEntry);</span><br><span class="line">    updateParentPointers(tid, dirtypages, page);</span><br><span class="line">    updateParentPointers(tid, dirtypages, newRightPage);</span><br><span class="line">    updateParentPointers(tid, dirtypages, parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新脏页并返回</span></span><br><span class="line">    dirtypages.put(page.getId(), page);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">    dirtypages.put(newRightPage.getId(), newRightPage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (field.compare(Op.GREATER_THAN_OR_EQ, midEntry.getKey())) &#123;</span><br><span class="line">        <span class="keyword">return</span> newRightPage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="image-5.png"></p><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><blockquote><p>完成B+树的删除操作中的节点key重分配，实现stealFromLeafPage()方法和stealFromLeftInternalPage()、stealFromRightInternalPage()方法。</p></blockquote><p>在 B+ 树的删除中，当节点中的 key 个数小于最小限制后，会进行节点之间的合并，合并中当兄弟节点有富余的 key 时会在两节点之间形成 key 的重分配。</p><p><img src="image-8.png"></p><ol><li><p><code>stealFromLeafPage()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stealFromLeafPage</span><span class="params">(BTreeLeafPage page, BTreeLeafPage sibling,</span></span><br><span class="line"><span class="params">                              BTreeInternalPage parent, BTreeEntry entry, <span class="type">boolean</span> isRightSibling)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    Iterator&lt;Tuple&gt; siblingIt = isRightSibling ? sibling.iterator() : sibling.reverseIterator();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sourceNumTuples</span> <span class="operator">=</span> page.getNumTuples();</span><br><span class="line">    <span class="type">int</span> <span class="variable">siblingTuplesNum</span> <span class="operator">=</span> sibling.getNumTuples();</span><br><span class="line">    <span class="type">int</span> <span class="variable">midTuplesNum</span> <span class="operator">=</span> (sourceNumTuples + siblingTuplesNum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (sourceNumTuples &lt; midTuplesNum) &#123;</span><br><span class="line">        <span class="comment">// 保证B+树节点的平衡性</span></span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">siblingTuple</span> <span class="operator">=</span> siblingIt.next();</span><br><span class="line">        sibling.deleteTuple(siblingTuple);</span><br><span class="line">        page.insertTuple(siblingTuple);</span><br><span class="line">        sourceNumTuples++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新父节点中的key</span></span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">headSibling</span> <span class="operator">=</span> siblingIt.next();</span><br><span class="line">    entry.setKey(headSibling.getField(keyField));</span><br><span class="line">    parent.updateEntry(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>stealFromLeftInternalPage()</code>：</p><p><img src="image-10.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stealFromLeftInternalPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                                      BTreeInternalPage page, BTreeInternalPage leftSibling, BTreeInternalPage parent,</span></span><br><span class="line"><span class="params">                                      BTreeEntry parentEntry)</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 先将父节点的key移动到下层内部节点中</span></span><br><span class="line">    Iterator&lt;BTreeEntry&gt; leftIt = leftSibling.reverseIterator();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">itEntry</span> <span class="operator">=</span> leftIt.next();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">oldParent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeEntry</span>(parentEntry.getKey(), itEntry.getRightChild(), page.iterator().next().getLeftChild());</span><br><span class="line">    page.insertEntry(oldParent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证B+树平衡性，进行均匀分配</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sourceEntriesNum</span> <span class="operator">=</span> page.getNumEntries();</span><br><span class="line">    <span class="type">int</span> <span class="variable">siblingEntriesNum</span> <span class="operator">=</span> leftSibling.getNumEntries();</span><br><span class="line">    <span class="type">int</span> <span class="variable">midEntriesNum</span> <span class="operator">=</span> (sourceEntriesNum + siblingEntriesNum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (sourceEntriesNum &lt; midEntriesNum) &#123;</span><br><span class="line">        leftSibling.deleteKeyAndRightChild(itEntry);</span><br><span class="line">        page.insertEntry(itEntry);</span><br><span class="line">        itEntry = leftIt.next();</span><br><span class="line">        sourceEntriesNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的父节点被旋转上去则不需担心子节点指向</span></span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">newParent</span> <span class="operator">=</span> itEntry;</span><br><span class="line">    leftSibling.deleteKeyAndRightChild(newParent);</span><br><span class="line">    parentEntry.setKey(newParent.getKey());</span><br><span class="line">    parent.updateEntry(parentEntry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置脏页</span></span><br><span class="line">    dirtypages.put(page.getId(), page);</span><br><span class="line">    dirtypages.put(leftSibling.getId(), leftSibling);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">    updateParentPointers(tid, dirtypages, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-6.png"></p></li><li><p><code>stealFromRightInternalPage()</code>：</p><p><img src="image-7.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stealFromRightInternalPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                                       BTreeInternalPage page, BTreeInternalPage rightSibling, BTreeInternalPage parent,</span></span><br><span class="line"><span class="params">                                       BTreeEntry parentEntry)</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 先将父节点的key移动到下层内部节点中</span></span><br><span class="line">    Iterator&lt;BTreeEntry&gt; rightIt = rightSibling.iterator();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">itEntry</span> <span class="operator">=</span> rightIt.next();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">oldParent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeEntry</span>(parentEntry.getKey(), page.reverseIterator().next().getRightChild(), itEntry.getLeftChild());</span><br><span class="line">    page.insertEntry(oldParent);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sourceEntriesNum</span> <span class="operator">=</span> page.getNumEntries();</span><br><span class="line">    <span class="type">int</span> <span class="variable">siblingEntriesNum</span> <span class="operator">=</span> rightSibling.getNumEntries();</span><br><span class="line">    <span class="type">int</span> <span class="variable">midEntriesNum</span> <span class="operator">=</span> (sourceEntriesNum + siblingEntriesNum) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 保证B+树平衡性，进行均匀分配</span></span><br><span class="line">    <span class="keyword">while</span> (sourceEntriesNum &lt; midEntriesNum) &#123;</span><br><span class="line">        rightSibling.deleteKeyAndLeftChild(itEntry);</span><br><span class="line">        page.insertEntry(itEntry);</span><br><span class="line">        itEntry = rightIt.next();</span><br><span class="line">        sourceEntriesNum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的父节点被旋转上去</span></span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">newParent</span> <span class="operator">=</span> itEntry;</span><br><span class="line">    rightSibling.deleteKeyAndLeftChild(newParent);</span><br><span class="line">    parentEntry.setKey(newParent.getKey());</span><br><span class="line">    parent.updateEntry(parentEntry);</span><br><span class="line">    <span class="comment">// 设置脏页</span></span><br><span class="line">    dirtypages.put(page.getId(), page);</span><br><span class="line">    dirtypages.put(rightSibling.getId(), rightSibling);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">    updateParentPointers(tid, dirtypages, page);</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure></li></ol><h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><blockquote><p>完成B+树的删除操作中的合并操作，实现mergeLeafPages()方法和mergeInternalPages()方法。</p></blockquote><p>在删除中当兄弟节点没有key富余时，需要将该节点与兄弟节点合并，叶子节点和内部节点的合并策略不同之处在于叶子节点删除上层key，内部节点将上层key移到下面一齐合并。</p><p><img src="image-9.png"></p><ol><li><p><code>mergeLeafPages()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeLeafPages</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                           BTreeLeafPage leftPage, BTreeLeafPage rightPage, BTreeInternalPage parent, BTreeEntry parentEntry)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    Iterator&lt;Tuple&gt; rightIt = rightPage.iterator();</span><br><span class="line">    <span class="comment">// 将右节点的key全部移动到左节点中进行节点合并</span></span><br><span class="line">    <span class="keyword">while</span> (rightIt.hasNext()) &#123;</span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">next</span> <span class="operator">=</span> rightIt.next();</span><br><span class="line">        rightPage.deleteTuple(next);</span><br><span class="line">        leftPage.insertTuple(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置叶子节点之间的指针指向</span></span><br><span class="line">    <span class="type">BTreePageId</span> <span class="variable">newRightNode</span> <span class="operator">=</span> rightPage.getRightSiblingId();</span><br><span class="line">    <span class="keyword">if</span> (newRightNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        leftPage.setRightSiblingId(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        leftPage.setRightSiblingId(newRightNode);</span><br><span class="line">        <span class="type">BTreeLeafPage</span> <span class="variable">newRightPage</span> <span class="operator">=</span> (BTreeLeafPage) getPage(tid, dirtypages, newRightNode, Permissions.READ_WRITE);</span><br><span class="line">        newRightPage.setLeftSiblingId(leftPage.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除父节点中的key</span></span><br><span class="line">    setEmptyPage(tid, dirtypages, rightPage.getId().getPageNumber());</span><br><span class="line">    deleteParentEntry(tid, dirtypages, leftPage, parent, parentEntry);</span><br><span class="line">    dirtypages.put(leftPage.getId(), leftPage);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>mergeInternalPages()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeInternalPages</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                               BTreeInternalPage leftPage, BTreeInternalPage rightPage, BTreeInternalPage parent, BTreeEntry parentEntry)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    Iterator&lt;BTreeEntry&gt; rightIt = rightPage.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与叶子节点的区别 -- 需要将父亲节点拉下来</span></span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">pullNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeEntry</span>(parentEntry.getKey(), leftPage.reverseIterator().next().getRightChild(),</span><br><span class="line">            rightPage.iterator().next().getLeftChild());</span><br><span class="line">    leftPage.insertEntry(pullNode);</span><br><span class="line">    <span class="comment">// 将右节点的key全部移动到左节点中进行节点合并</span></span><br><span class="line">    <span class="keyword">while</span> (rightIt.hasNext()) &#123;</span><br><span class="line">        <span class="type">BTreeEntry</span> <span class="variable">next</span> <span class="operator">=</span> rightIt.next();</span><br><span class="line">        rightPage.deleteKeyAndRightChild(next);</span><br><span class="line">        leftPage.insertEntry(next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新父节点指针</span></span><br><span class="line">    updateParentPointers(tid, dirtypages, leftPage);</span><br><span class="line">    <span class="comment">// 删除父节点中的key</span></span><br><span class="line">    setEmptyPage(tid, dirtypages, rightPage.getId().getPageNumber());</span><br><span class="line">    deleteParentEntry(tid, dirtypages, leftPage, parent, parentEntry);</span><br><span class="line">    dirtypages.put(leftPage.getId(), leftPage);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="image-4.png"></p><p><img src="image-2.png"></p><p><img src="image-1.png"></p><p><img src="image-3.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MIT6.5830 的数据库课程。Lab5 主要是完成 InnoDB 的索引，完成 B+ 树的查询、插入、删除操作。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://kicheng.github.io/categories/MySQL/"/>
    
    
    <category term="database" scheme="https://kicheng.github.io/tags/database/"/>
    
    <category term="mysql" scheme="https://kicheng.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5830-Lab4</title>
    <link href="https://kicheng.github.io/2024/08/27/MIT6.5830-Lab4/"/>
    <id>https://kicheng.github.io/2024/08/27/MIT6.5830-Lab4/</id>
    <published>2024-08-27T11:09:44.000Z</published>
    <updated>2024-09-19T07:31:18.436Z</updated>
    
    <content type="html"><![CDATA[<p>MIT6.5830 的数据库课程。Lab4 主要是完成数据库事务以及锁机制，在 Lab 中只是考虑设计了 page 级别锁。</p><span id="more"></span><ul><li><p><input checked="" disabled="" type="checkbox">  Exercise1</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise2</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise3</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise4</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise5</p></li></ul><blockquote><p>为了简化工作，Lab4采用了NO STEAL/FORCE缓冲区策略，不需要记录undo log和redo log日志（Lab6中完成）：</p><ul><li><p>NO STEAL：不允许一个未提交的事务将修改更新到磁盘，即磁盘中不会存在uncommitted数据，因此无需回滚操作，不需记录undo log。</p></li><li><p>FORCE：事务在提交之后必须将所有更新立刻持久化到磁盘（产生很多随机写，效率低），但无需记录redo log。</p></li></ul></blockquote><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><strong>事务：</strong>事务是一组以原子方式执行的数据库操作（读取、插入、删除），是不可分割的。</p><p><strong>事务的四大特性（ACID）</strong></p><ul><li><p>原子性（Atomicity）：事务是一个不可分割的单位。</p></li><li><p>一致性（Consistency）：事务执行是从一个一致状态到另一个一致状态，一致指的是：① 符合数据库的约束规则（主键、外键、非空、唯一性约束等等）； ② 符合业务逻辑规则（转出金额等于转入金额、购买数量不超过库存数量等等）。</p></li><li><p>隔离性 （Isolation）：并发执行的各个事务之间互不干扰，是完全隔离的。</p></li><li><p>持久性（Durability）：事务一旦提交，（甚至系统崩溃后）对数据库中数据的改变都是永久性的。</p></li></ul><p><strong>事务的并发执行遇到的问题</strong></p><ul><li><p>（脏写）</p></li><li><p>脏读：当一个事务正在访问数据并对该数据进行修改，但是修改还未提交到数据库，此时另一个事务访问到这个数据。违反了事务的原子性、隔离性、一致性。</p><p><img src="image-25.png"></p></li><li><p>不可重复读：在一个事务中多次读取同一个数据，在该事务两次读数据之间，由于另一个事务对该数据的访问和修改导致同一事务中两次读到的数据是不一致的。违反了事务的一致性。</p><p><img src="image-21.png"></p><blockquote><p>不可重复读和脏读的区别：脏读是读到了<strong>未提交</strong>的数据（压根这个数据就不存在所以是脏数据），不可重复读是读到了<strong>已提交</strong>的数据（因为是已提交的数据一般来说是可以被接受的）。</p></blockquote></li><li><p>幻读：在一个事务中多次查询符合条件的数据记录，出现了前后两次查询数据记录数量不一致的情况。幻读主要关注的是查询结果集发生了变化，因为有新的符合条件的行被插入或删除。&#x20;</p><p><img src="image-23.png"></p><blockquote><p>不可重复读和幻读的区别：不可重复读主要关注的是<strong>同一行数据</strong>在两次读取时发生了变化；幻读主要关注的是<strong>查询结果集</strong>发生了变化。</p></blockquote></li></ul><p><img src="image-19.png"></p><p><strong>事务隔离级别</strong></p><p>在事务并发执行的过程中可能会遇到脏读、不可重复读、幻读的现象，而他们的严重程度也从大到小。因此SQL标准提出了四种隔离级别来规避这些现象（隔离级别越高，性能越低）：</p><ul><li><p>读未提交（read uncommitted）：指一个事务还没提交时，它做的变更就能被其他事务看到；</p></li><li><p>读已提交（read committed）：指一个事务提交之后，它做的变更才能被其他事务看到；</p></li><li><p><strong>可重复读</strong>（repeatable read）：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的；<strong>MySQL InnoDB 引擎的默认隔离级别</strong></p></li><li><p>串行化（serializable）：多个事务对同一条记录进行读写操作时，会按照串行化的方式——后访问的事务等待前一个事务执行完成才能继续执行。</p></li></ul><p><img src="image.png" alt="SQL标准中规定的隔离级别允许的并发问题"></p><p><strong>事务隔离级别如何实现</strong></p><ul><li><p>读未提交：因为可以读到未提交事务修改的数据，所以直接读取最新的数据就可以；</p></li><li><p>串行化：通过加读写锁的方式来避免不同事务的并行访问；</p></li><li><p>读已提交、可重复读：通过Read View（数据快照）来实现，它们的区别在于创建Read View的时机不同——读提交是在每个语句执行前都会重新生成一个Read View，而可重复读隔离级别是启动事务时生成一个Read View，然后整个事务期间都在用这个Read View。</p></li></ul><blockquote><p>什么是Read View？Read View在MVCC中又是如何工作的？</p></blockquote><blockquote><p>复习一下MVCC：</p><p>多版本并发控制，MVCC在MySQL InnoDB中的实现主要是为了提高数据库的并发性能，通过版本链来控制并发事务访问同一个记录时的行为。</p></blockquote><p><strong>Read View的4个字段：</strong></p><p><img src="image-22.png"></p><p><img src="image-24.png" alt="聚簇索引中的隐藏列trx\_id和roll\_pointer"></p><p><strong>（重点）</strong>当一个事务去访问记录时，除了自己的更新记录可见之外，还有其他几种情况：</p><p><img src="image-17.png"></p><hr><p><strong>MySQL可重复读是如何一定程度上解决幻读的？</strong></p><ul><li><p>针对快照读（普通select语句），是通过MVCC方式解决幻读的：事务开始后（执行begin语句并且在执行第一条查询语句后），会创建一个Read View，后续查询会根据这个Read View到undo log版本链中找到相应的数据，所以事务每次查询数据的结果都是一样的。</p></li><li><p>针对当前读（update、insert、delete语句），当前读在执行前都会首先查询<strong>最新版本</strong>的数据（不会到undo log中查询事务开始时的数据版本），然后再做进一步操作。</p></li></ul><p>InnoDB为了解决在可重复读隔离级别下使用当前读出现的幻读现象，引入间隙锁：</p><p><strong>在可重复读中幻读被完全解决了吗？</strong></p><ul><li><p>特殊情况1：</p><p><img src="image-20.png"></p></li><li><p>特殊情况2：</p></li></ul><p><img src="image-16.png"></p><p>要避免此类场景下的幻读出现，就是尽可能在事务A开启之后马上执行<code>select * for update</code>语句，因为它会对记录加next-key-lock锁，避免其他事务插入新记录。</p><p><strong>总结：MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p><p>AUTO-INC的轻量级锁会在主从复制场景中出现数据不一致的情形</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><blockquote><p>如何对数据库进行备份</p></blockquote><ul><li><p>对于数据库的存储引擎<strong>支持可重复读</strong>的，可以在备份数据库之前先开启事务，整个事务执行期间使用同一个Read View，这样由于MVCC的支持在备份期间是可以对数据进行更新操作的（mysqldump工具）。</p></li><li><p>对于数据库的存储引擎<strong>不支持可重复读</strong>的，只能加全局锁将整个数据库设置为只读状态，但是会造成业务停滞。</p></li></ul><p><strong>常用的行级锁和表级锁</strong></p><ul><li>排他锁（eXclusive Lock，X锁）</li></ul><p>事务T对数据对象A加上X锁，则<strong>事务T可以读A也可以修改A</strong>，其他事务不能再对数据对象A加任何锁，直到T释放A上的锁。这保证了<strong>其他事务在T释放A上的锁之前不能再读取和修改A</strong>。</p><ul><li>共享锁（Shared Lock，S锁）</li></ul><p>事务T对数据对象A加上S锁，则<strong>事务T可以读A但不能修改A</strong>，其他事务只能再对A加S锁而不能加X锁。这保证了<strong>其他事务可以读A，但在T释放A上的S锁之前不能对其做任何修改</strong>。</p><blockquote><p><strong>S锁和X锁都是行级别(row-level)的行锁</strong>，加在索引记录上的，兼容与否是对于一条记录来说的。若想对1000万条数据加锁，需要判断每条数据是否有正在上锁，这个效率非常低。这个时候就希望锁的层次有区别，例如在加S、X锁在行级时先在<strong>表级别</strong>加锁——由此引入<strong>意向锁</strong>。</p></blockquote><ul><li>意向锁（Intention Lock，I锁）</li></ul><p>加意向锁的目的是为了表明某事务正在锁定一行，表示加锁的意图。</p><p><img src="image-13.png"></p><p>二阶段锁协议</p><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>锁的粒度从大到小分为 Database -&gt; Table -&gt; Page -&gt; Tuple，而本次实验只要求实现<strong>Page级别锁</strong>。</p><p><img src="image-14.png"></p><blockquote><p>实现的排他锁和共享锁应当满足以下条件：</p><ul><li><p>在一个事务读取一个对象前，应该要有其的共享锁。</p></li><li><p>在一个事务写入一个对象前，应该要有其的排它锁。</p></li><li><p>一个对象的共享锁可以被多个事务共享。</p></li><li><p>一个对象的排它锁只能被一个事务所拥有。</p></li><li><p>如果一个事务已经拥有了一个对象的共享锁，则其拥有的锁可以被升级为排它锁。</p></li></ul></blockquote><ol><li><p>创建页面级别的锁类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PageLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TransactionId tid;  <span class="comment">// 获取锁的事务</span></span><br><span class="line">    <span class="keyword">private</span> PageId pid;  <span class="comment">// 锁所在的页面</span></span><br><span class="line">    <span class="keyword">private</span> LockType type;  <span class="comment">// 锁类型（S or X）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageLock</span><span class="params">(TransactionId tid, PageId pid, LockType type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tid = tid;</span><br><span class="line">        <span class="built_in">this</span>.pid = pid;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LockType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>锁类型LockType</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHARED_LOCK (<span class="number">0</span>, <span class="string">&quot;共享锁&quot;</span>),</span><br><span class="line">EXCLUSIVE_LOCK (<span class="number">1</span>, <span class="string">&quot;排它锁&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>LockManager锁管理类（核心）</p><ol><li><p>一个页可以有多把锁（S锁），一把锁只能存在于一个页，即锁与页是<strong>多对一</strong>的关系；</p></li><li><p>一个事务中可以获取多把锁，一把锁只能被一个事务获取，即锁与事务也是<strong>多对一</strong>的关系；</p></li></ol><p>由a和b得出来设计<strong>存储锁的数据结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConcurrentHashMap&lt;PageId, ConcurrentHashMap&lt;TransactionId, PageLock&gt;&gt; lockMap;</span><br></pre></td></tr></table></figure></li></ol><p>在LockManager中还有一些比较重要的方法：</p><ul><li><p>判断指定事务tid在指定页面pid是否存在锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果指定的事务在指定的页面上有锁，则返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">holdsLock</span><span class="params">(TransactionId tid, PageId p)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1|lab2</span></span><br><span class="line">    <span class="keyword">if</span> (lockMap.get(p) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lockMap.get(p).get(tid) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>申请锁流程</p></li></ul><p><img src="image-18.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">(PageId pageId, TransactionId tid, LockType requestLock, <span class="type">int</span> reTry)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 重传达到3次</span></span><br><span class="line">    <span class="keyword">if</span> (reTry == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于打印log</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、页面上不存在锁</span></span><br><span class="line">    <span class="keyword">if</span> (lockMap.get(pageId) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> putLock(tid, pageId, requestLock);  <span class="comment">// 直接获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、页面上存在锁</span></span><br><span class="line">    ConcurrentHashMap&lt;TransactionId, PageLock&gt; tidLocksMap = lockMap.get(pageId);</span><br><span class="line">    <span class="keyword">if</span> (tidLocksMap.get(tid) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1 页面上没有自己事务的锁</span></span><br><span class="line">        <span class="keyword">if</span> (requestLock == LockType.EXCLUSIVE_LOCK) &#123;</span><br><span class="line">            <span class="comment">// 2.1.1 请求的为X锁</span></span><br><span class="line">            wait(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> acquireLock(pageId, tid, requestLock, reTry + <span class="number">1</span>);  <span class="comment">// 不能获取页面上的X锁，等待一段时间后重试</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestLock == LockType.SHARED_LOCK) &#123;</span><br><span class="line">            <span class="comment">// 2.1.2 页面上的锁是否都是S锁：页面上的锁大于1个就都是S锁（因为X锁只能被一个事务占有）</span></span><br><span class="line">            <span class="keyword">if</span> (tidLocksMap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> putLock(tid, pageId, requestLock);  <span class="comment">// 都是读锁，直接获取</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Collection&lt;PageLock&gt; values = tidLocksMap.values();</span><br><span class="line">                <span class="comment">// values集合中只有一个元素</span></span><br><span class="line">                <span class="keyword">for</span> (PageLock value: values) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value.getType() == LockType.EXCLUSIVE_LOCK) &#123;</span><br><span class="line">                        wait(<span class="number">10</span>);</span><br><span class="line">                        <span class="keyword">return</span> acquireLock(pageId, tid, requestLock, reTry + <span class="number">1</span>);  <span class="comment">// 存在的锁为X锁，不能获取页面上的X锁，等待一段时间后重试</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> putLock(tid, pageId, requestLock);  <span class="comment">// 存在的锁为S锁，直接获取</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.2 页面上有自己事务的锁（每次获取requestLock的时候要先remove掉原来的锁）</span></span><br><span class="line">        <span class="keyword">if</span> (requestLock == LockType.SHARED_LOCK) &#123;</span><br><span class="line">            <span class="comment">// 2.2.1 请求的为S锁</span></span><br><span class="line">            tidLocksMap.remove(tid);  <span class="comment">// 先移除自己的锁</span></span><br><span class="line">            <span class="keyword">return</span> putLock(tid, pageId, requestLock);  <span class="comment">// 获取S锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.1 请求的为X锁</span></span><br><span class="line">            <span class="keyword">if</span> (tidLocksMap.get(tid).getType() == LockType.EXCLUSIVE_LOCK) &#123;</span><br><span class="line">                <span class="comment">// 判断自己的锁是否是X锁，如果是则直接获取</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 判断页面上是否还有其他事务的锁</span></span><br><span class="line">                <span class="keyword">if</span> (tidLocksMap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    wait(<span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">return</span> acquireLock(pageId, tid, requestLock, reTry + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 只有自己拥有一个读锁，进行锁升级</span></span><br><span class="line">                    tidLocksMap.remove(tid);</span><br><span class="line">                    <span class="keyword">return</span> putLock(tid, pageId, requestLock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过BufferPool的<code>getPage</code>方法获取page级别的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Page <span class="title function_">getPage</span><span class="params">(TransactionId tid, PageId pid, Permissions perm)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    LockType lockType;</span><br><span class="line">    <span class="keyword">if</span> (perm == Permissions.READ_ONLY) &#123;</span><br><span class="line">        lockType = LockType.SHARED_LOCK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lockType = LockType.EXCLUSIVE_LOCK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果获取lock失败(reTry 3次)则直接放弃事务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lockManager.acquireLock(pid, tid, lockType, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，回滚事务</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionAbortedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;Method 「getPage」获取锁发生异常！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bufferPool应直接放在直接内存</span></span><br><span class="line">    <span class="keyword">if</span> (lruCache.get(pid) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">DbFile</span> <span class="variable">file</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(pid.getTableId());</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> file.readPage(pid);  <span class="comment">// 调用HeapFile的readPage方法</span></span><br><span class="line">        lruCache.put(pid, page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruCache.get(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-12.png"></p><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><ul><li><p>HeapFile的insertTuple方法</p><p>在HeapFile的insertTuple方法中，首先要寻找页面是否存在空闲的slot，这一操作首先会获取页面上的X锁，一旦找到空闲的slot就写入。但是这种操作在S2PL协议下有时会大量占用资源：<strong>在没有空闲slot的情况下，会不断地获取每个页上的X锁而不释放</strong>。其实当页面没有空闲的slot时我们可以直接释放该页面的X锁，这虽然违反了S2PL协议，但由于我们没有对该页面上的数据进行更新，所以就算释放了页面上的X锁，也不会影响其他并发事务的操作。</p></li></ul><p><img src="image-15.png"></p><p>加入释放锁逻辑：</p><ul><li><p>HeapFile的deleteTuple方法</p><p><img src="image-10.png"></p></li></ul><p>什么时候做锁的释放逻辑</p><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><blockquote><p>完成NO STEAL策略：事务的修改必须在事务提交之后写入磁盘。</p></blockquote><p>这意味着在事务执行过程中，可以通过丢弃BufferPool中的脏页并从磁盘重新读取它们完成BufferPool的复原（回滚）来absort事务。所以脏页是完成BufferPool复原很重要的依据，<strong>因此在LRU策略中我们不能驱逐脏页</strong>。</p><ul><li>修改LRUCache中的put方法</li></ul><p><img src="image-11.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(PageId key, Page val)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="keyword">if</span> (contain(key)) &#123;</span><br><span class="line">        <span class="comment">// 更新value</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        node.val = val;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val);</span><br><span class="line">        map.put(key, newNode);</span><br><span class="line">        <span class="comment">// 添加到链表头</span></span><br><span class="line">        addToHead(newNode);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">            <span class="comment">// 移除链表尾(我们可以通过丢弃脏页并从磁盘重新读取来进行事务的回滚，因为我们不能在LRU中删除脏页)</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">removeNode</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">            <span class="comment">// 丢弃的不能是脏页，是脏页则跳过</span></span><br><span class="line">            <span class="keyword">while</span> (removeNode.val.isDirty() != <span class="literal">null</span>) &#123;</span><br><span class="line">                removeNode = removeNode.prev;</span><br><span class="line">                <span class="keyword">if</span> (removeNode == newNode || removeNode == tail) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;没有合适的页存储空间或者所有页都为脏页！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意不能删除脏页</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> removeTail();</span><br><span class="line">            map.remove(node.key);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><blockquote><p>事务结束后，调用BufferPool的transactionComplete方法，判断事务是成功完成还是失败需要回滚。</p></blockquote><ul><li><p>事务成功完成时，需要将BufferPool中的脏页全部刷新到磁盘；事务失败则需要回滚，将磁盘中的数据反向刷新到BufferPool中替换掉脏页。</p></li><li><p>释放掉事务所拥有的所有锁，完成S2PL的释放阶段。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 释放掉给定事务所有的锁   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionComplete</span><span class="params">(TransactionId tid)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1|lab2</span></span><br><span class="line">    transactionComplete(tid, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提交或中止给定的事务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionComplete</span><span class="params">(TransactionId tid, <span class="type">boolean</span> commit)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1|lab2</span></span><br><span class="line">    <span class="comment">// 1.1 事务成功则刷新页面到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (commit) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flushPages(tid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.2 事务失败则回滚将磁盘反向刷新到BufferPool</span></span><br><span class="line">        rollBack(tid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、释放tid事务上所有的锁</span></span><br><span class="line">    lockManager.releasePageByTid(tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 事务回滚</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">rollBack</span><span class="params">(TransactionId tid)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;PageId, LRUCache.Node&gt; group: lruCache.getEntrySet()) &#123;</span><br><span class="line">        <span class="type">PageId</span> <span class="variable">pageId</span> <span class="operator">=</span> group.getKey();</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> group.getValue().val;</span><br><span class="line">        <span class="keyword">if</span> (tid.equals(page.isDirty())) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tableId</span> <span class="operator">=</span> pageId.getTableId();</span><br><span class="line">            <span class="type">DbFile</span> <span class="variable">table</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(tableId);</span><br><span class="line">            <span class="type">Page</span> <span class="variable">readPage</span> <span class="operator">=</span> table.readPage(pageId);</span><br><span class="line">            <span class="comment">// 将磁盘的页面反向刷新至BufferPool完成事务回滚</span></span><br><span class="line">            lruCache.removeByKey(pageId);</span><br><span class="line"><span class="comment">//            lruCache.put(pageId, readPage);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>rollback没有将磁盘的内容反向刷新到bufferpool中为什么才能通过测试用例？</p><p><img src="image-8.png"></p></blockquote><p><img src="image-3.png"></p><p><img src="image-7.png"></p><p><img src="image-9.png"></p><p><img src="image-6.png"></p><p><img src="image-5.png"></p><p><img src="image-2.png"></p><p><img src="image-1.png"></p><p><img src="image-4.png"></p><h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h2><p>死锁就是多个并发进程因互相争夺系统资源而造成的相互等待的现象。</p><p><strong>死锁产生的四个必要条件</strong></p><ul><li><p>互斥条件：一个资源只能被一个进程获取，不允许其他进程访问；</p></li><li><p>请求和保持条件：一个进程因请求资源而发生阻塞时，不会释放自己占有的资源；</p></li><li><p>不可剥夺条件：进程已获得的资源，在未完成使用之前不能被其他进程剥夺，只能自己释放；</p></li><li><p>循环等待条件：若干进程之间形成头尾相连互相等待的环行资源。</p></li></ul><p><strong>死锁的处理方法</strong></p><ul><li><p>死锁检测与死锁恢复</p><p>在死锁之前不采取任何措施，只检测系统有没有发生死锁，发生了再采取一些措施解除死锁。</p><ul><li>死锁检测：死锁定理</li></ul><p>*</p></li><li><p>死锁预防</p></li><li><p>死锁避免</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;MIT6.5830 的数据库课程。Lab4 主要是完成数据库事务以及锁机制，在 Lab 中只是考虑设计了 page 级别锁。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://kicheng.github.io/categories/MySQL/"/>
    
    
    <category term="database" scheme="https://kicheng.github.io/tags/database/"/>
    
    <category term="mysql" scheme="https://kicheng.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5830-Lab3</title>
    <link href="https://kicheng.github.io/2024/08/22/MIT6.5830-Lab3/"/>
    <id>https://kicheng.github.io/2024/08/22/MIT6.5830-Lab3/</id>
    <published>2024-08-22T11:09:44.000Z</published>
    <updated>2024-09-19T07:26:22.627Z</updated>
    
    <content type="html"><![CDATA[<p>MIT6.5830 的数据库课程。Lab3 主要是完成数据库查询优化的成本优化器。</p><span id="more"></span><ul><li><p><input checked="" disabled="" type="checkbox">  Exercise1</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise2</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise3</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise4</p></li></ul><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p><strong>I/O成本：</strong></p><p>查询表中记录时，需要先把数据或索引加载到内存，从磁盘到内存的加载过程损耗时间。</p><p><strong>CPU成本：</strong></p><p>读取记录以及检测记录是否满足对应的搜索条件、对结果集进行排序操作损耗的时间。</p><h3 id="查询处理与查询优化"><a href="#查询处理与查询优化" class="headerlink" title="查询处理与查询优化"></a>查询处理与查询优化</h3><p>查询处理是指从数据库中提取数据所涉及的一系列活动，这些活动包括：</p><ul><li><p>语法分析与翻译：将高层数据库语言表示的查询语句翻译为能在文件系统的物理层上使用的表达形式；</p></li><li><p>优化：各种查询的优化转换；</p></li><li><p>查询的实际执行；</p></li></ul><p><img src="image-3.png"></p><blockquote><p>为了全面的说明如何执行查询，不仅要提供关系代数表达式，还要对表达式加上带指令的注释来说明如何执行每种运算。带有注释的关系代数运算称为<strong>执行源语</strong>，用于执行一个查询的原语操作序列称为<strong>查询执行计划</strong>。</p></blockquote><p>我们不能寄希望用户写出具有最高效率执行计划的查询语句，而构造具有最小执行代价的查询计划应当是系统的责任，系统的这项工作就叫做查询优化。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p><strong>基于规则的优化器（Rule-Based Optimization,RBO）</strong></p><p>硬编码在数据库中一系列的规则（比如索引的优先级大于全表扫描）来决定SQL的执行计划，无论数据表内容如何变化，执行计划也基本不会改变（RBO对数据不敏感）。</p><p>缺点：</p><ul><li><p>需要按照规则去写SQL语句，要求开发人员对RBO的规则非常了解，不熟悉规则的开发者写出的SQL性能可能非常差。</p></li><li><p>数据的量级也会影响SQL的性能。</p></li></ul><p><strong>基于代价的优化器（COST-Based Optimization,CBO）</strong></p><p>根据优化规则对关系表达式进行转换，生成多个执行计划，然后根据统计信息和代价模型计算各种执行计划的“代价COST”，从中选用COST最低的执行方案来实际执行。</p><p>CBO的主要流程：</p><ul><li><p>利用关于表的统计数据，来估计不同查询计划的cost（cost与join、selection的基数、filter的选择率和join的谓词有关）</p></li><li><p>使用数据来对join和select进行排序，选择最佳的实现方式</p></li></ul><h3 id="基数和选择性"><a href="#基数和选择性" class="headerlink" title="基数和选择性"></a>基数和选择性</h3><p><strong>基数（cardinality）</strong></p><p>某一列，不同键值的数量（主键列的基数=行数）。</p><p><strong>选择性（selectivity）</strong></p><p>选择性 = 基数 / 行数</p><p><strong>用途</strong></p><p>被当作是否建立索引的判断依据之一。基数和选择性越高的列越适合建立BTree索引，当基数和选择性都比较低时就要根据数据分布情况来决定是否建立BTree索引了。</p><blockquote><p>索引最重要的目标是尽可能地缩小匹配行的初始候选值，从而减少io提升查询性能。所以通常来说索引的选择性越高则查询效率越高，因为选择性高的索引可以让数据库在查找时过滤掉更多的行。</p></blockquote><p>CBO还使用选择率来估算对应结果集的基数。</p><p>补充</p><h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><blockquote><p>实现IntHistogram</p></blockquote><p>估计查询计划的代价最重要的依据就是数据的统计信息，lab采用为每一个字段建立直方图来对数据进行统计。</p><p><img src="image-9.png"></p><h3 id="直方图统计信息"><a href="#直方图统计信息" class="headerlink" title="直方图统计信息"></a>直方图统计信息</h3><p><strong>创建直方图</strong></p><p>步骤1：首先全表扫描一次，获取每个字段的最大值与最小值（获取区间范围）；</p><p>步骤2：再次扫描表，选择所有元组的所有字段，使用它们填充每个直方图的桶计数。</p><p><strong>计算选择率</strong></p><p>对于等值运算：<code>value=const</code>，首先需要找到包含该const值的桶，然后计算：<code>选择率=(value=const的记录数)/记录总数</code>，（假设数值在桶中是均匀分布的，<code>value=const</code>的记录数为<code>(桶高/桶宽)</code>），故选择率表示为：<code>(桶高/桶宽)/记录总数</code>。</p><p>对于非等值运算：<code>value&gt;const</code>，<code>value&gt;const</code>的记录数在直方图中由两部分构成：<code>(const, b.right]</code>的记录数<code>(h_b / w_b)*(const - b.right)</code>和<code>[b.right, max]</code>的记录数<code>后面桶高之和</code>。</p><p><img src="image.png"></p><h3 id="IntHistogram类"><a href="#IntHistogram类" class="headerlink" title="IntHistogram类"></a>IntHistogram类</h3><p><strong>参数：</strong></p><ul><li><p>直方图中的桶，统计每个桶的高度：<code>private int[] buckets;</code></p></li><li><p>直方图的最大值：<code>private int max;</code></p></li><li><p>直方图的最小值：<code>private int min;</code></p></li><li><p>直方图的桶宽度：<code>private double width;</code></p></li><li><p>直方图的记录总数：<code>private int tupleCount;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IntHistogram</span><span class="params">(<span class="type">int</span> buckets, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.buckets = <span class="keyword">new</span> <span class="title class_">int</span>[buckets];</span><br><span class="line">    <span class="built_in">this</span>.min = min;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.width = (<span class="type">double</span>) (max - min + <span class="number">1</span>) / buckets;  <span class="comment">// 注意桶宽度的设置</span></span><br><span class="line">    <span class="built_in">this</span>.tupleCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据value值获取桶的序号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) ((value - min) / width);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= buckets.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) ((value - min) / width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向直方图添加数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValue</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (v &gt;= min &amp;&amp; v &lt;= max) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(v);</span><br><span class="line">        buckets[index]++;</span><br><span class="line">        tupleCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回估计该表上特定谓词和操作数的选择性：</p><p>例如，<code>op=</code><em><code>LESS_THAN</code>且<code>v=5</code>，则比较表达式为<code>LESS_THAN 5</code>。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateSelectivity</span><span class="params">(Predicate.Op op, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> LESS_THAN:</span><br><span class="line">            <span class="keyword">if</span> (v &lt;= min) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= max) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(v);</span><br><span class="line">                <span class="type">double</span> <span class="variable">tuples</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                    tuples += buckets[i];</span><br><span class="line">                &#125;</span><br><span class="line">                tuples += (buckets[index] / width) * (v - (min + index * width));  <span class="comment">// add 直方图index桶最后一部分</span></span><br><span class="line">                <span class="keyword">return</span> tuples / tupleCount;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> GREATER_THAN:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - estimateSelectivity(Predicate.Op.LESS_THAN_OR_EQ, v);</span><br><span class="line">        <span class="keyword">case</span> EQUALS:</span><br><span class="line">            <span class="keyword">return</span> estimateSelectivity(Predicate.Op.LESS_THAN_OR_EQ, v) - estimateSelectivity(Predicate.Op.LESS_THAN, v);</span><br><span class="line">        <span class="keyword">case</span> NOT_EQUALS:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - estimateSelectivity(Predicate.Op.EQUALS, v);</span><br><span class="line">        <span class="keyword">case</span> GREATER_THAN_OR_EQ:</span><br><span class="line">            <span class="keyword">return</span> estimateSelectivity(Predicate.Op.GREATER_THAN, v - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">case</span> LESS_THAN_OR_EQ:</span><br><span class="line">            <span class="keyword">return</span> estimateSelectivity(Predicate.Op.LESS_THAN, v + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Unsupported operation: &quot;</span> + op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-8.png"></p><h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><blockquote><p>实现TableStats类</p></blockquote><p>根据tableId和每页的IO花销，构造每个字段的直方图，并利用Exercise1的方法得出每个直方图相关的选择性估计。</p><h3 id="TableStats类"><a href="#TableStats类" class="headerlink" title="TableStats类"></a>TableStats类</h3><p><strong>参数：</strong></p><ul><li><p>进行数据统计的表：<code>private HeapFile dbFile;</code></p></li><li><p>访问每页的IO开销：<code>private int ioCostPerPage;</code></p></li><li><p>表中的总记录数，用于估算表基数：<code>private int totalTuples;</code></p></li><li><p>整型字段与直方图的映射：<code>private ConcurrentHashMap&lt;Integer, IntHistogram&gt; intHistograms;</code></p></li><li><p>字符串字段与直方图的映射：<code>private ConcurrentHashMap&lt;Integer, StringHistogram&gt; stringHistograms;</code></p></li><li><p>整型字段中与该字段最大值的映射：<code>Map&lt;Integer, Integer&gt; maxMap;</code></p></li><li><p>整型字段中与该字段最小值的映射：<code>Map&lt;Integer, Integer&gt; minMap;</code></p></li><li><p>表的属性行：<code>private TupleDesc tupleDesc;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：根据给定的tableId为表各字段建立直方图</p><ul><li><p>整型字段：第一次扫描统计各个整型字段的最大最小值确定区间，第二次扫描生成各个字段的直方图</p></li><li><p>字符字段：无需通过最大最小值确定区间，所以一次扫描</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TableStats</span><span class="params">(<span class="type">int</span> tableid, <span class="type">int</span> ioCostPerPage)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; minMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; maxMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.intHistograms = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.stringHistograms = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.dbFile = (HeapFile) Database.getCatalog().getDatabaseFile(tableid);</span><br><span class="line">    <span class="built_in">this</span>.ioCostPerPage = ioCostPerPage;</span><br><span class="line">    <span class="built_in">this</span>.tupleDesc = dbFile.getTupleDesc();</span><br><span class="line"></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">    tx.start();</span><br><span class="line">    <span class="type">DbFileIterator</span> <span class="variable">child</span> <span class="operator">=</span> dbFile.iterator(tx.getId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        child.open();</span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.totalTuples += <span class="number">1</span>;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> child.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tupleDesc.numFields(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tupleDesc.getFieldType(i) == Type.INT_TYPE) &#123;</span><br><span class="line">                    <span class="comment">// int类型，需要先统计各个属性的最大最小值</span></span><br><span class="line">                    <span class="type">IntField</span> <span class="variable">field</span> <span class="operator">=</span> (IntField) tuple.getField(i);</span><br><span class="line">                    <span class="comment">// 更新最小值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">min_value</span> <span class="operator">=</span> Math.min(minMap.getOrDefault(i, Integer.MAX_VALUE), field.getValue());</span><br><span class="line">                    minMap.put(i, min_value);</span><br><span class="line">                    <span class="comment">// 更新最大值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">max_value</span> <span class="operator">=</span> Math.max(maxMap.getOrDefault(i, Integer.MIN_VALUE), field.getValue());</span><br><span class="line">                    maxMap.put(i, max_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tupleDesc.getFieldType(i) == Type.STRING_TYPE) &#123;</span><br><span class="line">                    <span class="comment">// string类型，直接构造直方图</span></span><br><span class="line">                    <span class="type">StringHistogram</span> <span class="variable">strHis</span> <span class="operator">=</span> <span class="built_in">this</span>.stringHistograms.getOrDefault(i, <span class="keyword">new</span> <span class="title class_">StringHistogram</span>(NUM_HIST_BINS));</span><br><span class="line">                    <span class="type">StringField</span> <span class="variable">field</span> <span class="operator">=</span> (StringField) tuple.getField(i);</span><br><span class="line">                    strHis.addValue(field.getValue());</span><br><span class="line">                    <span class="built_in">this</span>.stringHistograms.put(i, strHis);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int类型根据最小最大初始化直方图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tupleDesc.numFields(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minMap.get(i) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 初始化构造int型直方图</span></span><br><span class="line">                <span class="built_in">this</span>.intHistograms.put(i, <span class="keyword">new</span> <span class="title class_">IntHistogram</span>(NUM_HIST_BINS, minMap.get(i), maxMap.get(i)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新扫描表，往int直方图添加数据</span></span><br><span class="line">        child.rewind();</span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> child.next();</span><br><span class="line">            <span class="comment">// 填充直方图的数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tupleDesc.numFields(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tupleDesc.getFieldType(i) == Type.INT_TYPE) &#123;</span><br><span class="line">                    <span class="type">IntField</span> <span class="variable">field</span> <span class="operator">=</span> (IntField) tuple.getField(i);</span><br><span class="line">                    <span class="type">IntHistogram</span> <span class="variable">intHis</span> <span class="operator">=</span> <span class="built_in">this</span>.intHistograms.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (intHis == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;获得直方图失败！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    intHis.addValue(field.getValue());</span><br><span class="line">                    <span class="built_in">this</span>.intHistograms.put(i, intHis);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        child.close();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务提交失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-1.png"></p><ul><li><p>估计扫描表的IO成本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateScanCost</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 文件页数 * IO代价</span></span><br><span class="line">    <span class="keyword">return</span> dbFile.numPages() * ioCostPerPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回给定选择率的基数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">estimateTableCardinality</span><span class="params">(<span class="type">double</span> selectivityFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.totalTuples * selectivityFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回指定字段的平均选择率：<code>public double avgSelectivity(int field, Predicate.Op op)</code></p></li><li><p>返回在特定谓词和操作符下字段的选择率：<code>public double estimateSelectivity(int field, Predicate.Op op, Field constant)</code></p></li><li><p>返回表中元组行数：<code>public int totalTuples()</code></p></li></ul><p><img src="image-10.png"></p><h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h2><blockquote><p>实现JoinOptimizer类的estimateJoinCost、estimateJoinCardinality方法</p></blockquote><p>由目标也可以看出，exercise3目的是估算Join连接操作的开销以及估算Join之后的基数。</p><h3 id="JoinOptimizer类"><a href="#JoinOptimizer类" class="headerlink" title="JoinOptimizer类"></a>JoinOptimizer类</h3><p><strong>方法：</strong></p><ul><li><p>估计连接成本：<code>card1</code>是左表的基数，<code>cost1</code>是扫描左表的成本，<code>card2</code>是右表的基数，<code>cost2</code>是扫描右表的成本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">循环嵌套的连接成本如下：</span><br><span class="line">joincost(t1 join t2) = scancost(t1) + tupsNum(t1) * scancost(t2)  <span class="comment">// IO cost</span></span><br><span class="line">                   + tupsNum(t1) * tupsNum(t2)  <span class="comment">// CPU cost</span></span><br><span class="line">t1的扫描成本：cost1</span><br><span class="line">t2的扫描成本：t1中每一条数据都要和t2中所有数据进行连接，每从t1取出一条数据都要对t2进行全表扫描，</span><br><span class="line">故扫描成本是 card1*cost2</span><br><span class="line">t1与t2的连接成本：card1*card2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateJoinCost</span><span class="params">(LogicalJoinNode j, <span class="type">int</span> card1, <span class="type">int</span> card2,</span></span><br><span class="line"><span class="params">                               <span class="type">double</span> cost1, <span class="type">double</span> cost2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (j <span class="keyword">instanceof</span> LogicalSubplanJoinNode) &#123;</span><br><span class="line">        <span class="comment">// A LogicalSubplanJoinNode represents a subquery.</span></span><br><span class="line">        <span class="comment">// You do not need to implement proper support for these for Lab 3.</span></span><br><span class="line">        <span class="keyword">return</span> card1 + cost1 + cost2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Insert your code here.</span></span><br><span class="line">        <span class="keyword">return</span> cost1 + card1 * cost2 + card1 * card2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>估算两张表连接后的基数：</strong></p><ul><li><p>对于等值连接</p><ul><li>当一个属性是primary key时，把non-primary key属性的记录数作为连接后的基数。</li></ul><p><img src="image-2.png"></p><ul><li><p>当两个属性都是primary key时，去字段中记录数较小的当作基数。</p></li><li><p>没有primary key时，很难估计连接结果的基数。Lab中采用简单的估计方式，即连接后的记过基数是两表中较大的基数。</p></li></ul></li><li><p>对于非等值连接：基数也很难估计，本Lab采用两表基数乘积 * 0.3 作为非等值连接的基数估计。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">estimateTableJoinCardinality</span><span class="params">(Predicate.Op joinOp,</span></span><br><span class="line"><span class="params">      String table1Alias, String table2Alias, String field1PureName,</span></span><br><span class="line"><span class="params">      String field2PureName, <span class="type">int</span> card1, <span class="type">int</span> card2, <span class="type">boolean</span> t1pkey,</span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> t2pkey, Map&lt;String, TableStats&gt; stats,</span></span><br><span class="line"><span class="params">      Map&lt;String, Integer&gt; tableAliasToId)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">card</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 连接结果的基数</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (joinOp == Predicate.Op.EQUALS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1pkey &amp;&amp; !t2pkey) &#123;</span><br><span class="line">            card = card2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!t1pkey &amp;&amp; t2pkey) &#123;</span><br><span class="line">            card = card1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1pkey &amp;&amp; t2pkey) &#123;</span><br><span class="line">            card = Math.min(card1, card2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            card = Math.max(card1, card2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        card = (<span class="type">int</span>) (card1 * card2 * <span class="number">0.3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> card &lt;= <span class="number">0</span> ? <span class="number">1</span> : card;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-7.png"></p><h2 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h2><blockquote><p>完成JoinOptimizer类</p></blockquote><p>根据多表连接的代价，选择出代价最小的连接顺序。</p><p>对于一个复杂的连接查询，<code>r1⋈r2⋈……⋈rn</code>，对于n个关系来说存在<code>(2(n-1))! / (n-1)!</code>种不同的连接次序。随着n的增加，这个数量迅速增长。但是我们不必产生与给定表达式等价的所有表达式，假设我们希望找到以下表达式的最佳连接次序：<code>(r1⋈r2⋈r3)⋈r4⋈r5</code>，<code>r1⋈r2⋈r3</code>有12种不同的次序，其计算结果与<code>r4⋈r5</code>又有12种连接次序。基于这种思想，采用一种用于连接次序优化的<strong>动态规划DP算法</strong>。</p><h3 id="JoinOptimizer类-1"><a href="#JoinOptimizer类-1" class="headerlink" title="JoinOptimizer类"></a>JoinOptimizer类</h3><p><strong>参数：</strong></p><ul><li><p>一系列join节点的集合，而不是需要连接的表集合：<code>final List&lt;LogicalJoinNode&gt; joins;</code></p><p>比如<code>r1⋈r2⋈r3</code>，有<code>logicalJoinNode1=r1⋈r2</code>，<code>logicalJoinNode2=r2⋈r3</code>。</p></li></ul><p><strong>辅助类和方法：</strong></p><ul><li><p>CostCard类</p><ul><li><p>按照某一顺序连接的查询计划：<code>public List&lt;LogicalJoinNode&gt; plan;</code></p></li><li><p>最优连接顺序下的代价：<code>public double cost;</code></p></li><li><p>最优连接顺序下产生的基数：<code>public int card;</code></p></li></ul></li><li><p>PlanCache类：类似于DP数组</p><ul><li><p>关系集合与最优连接顺序的映射：<code>final Map&lt;Set&lt;LogicalJoinNode&gt;, List&lt;LogicalJoinNode&gt;&gt; bestOrders = new HashMap&lt;&gt;();</code></p></li><li><p>关系集合与最优连接顺序代价的映射：<code>final Map&lt;Set&lt;LogicalJoinNode&gt;, Double&gt; bestCosts = new HashMap&lt;&gt;();</code></p></li><li><p>关系集合与最优连接顺序基数的映射：<code>final Map&lt;Set&lt;LogicalJoinNode&gt;, Integer&gt; bestCardinalities = new HashMap&lt;&gt;();</code></p></li></ul></li><li><p>生成所有给定size大小的子集集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Set&lt;Set&lt;T&gt;&gt; <span class="title function_">enumerateSubsets</span><span class="params">(List&lt;T&gt; v, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    Set&lt;Set&lt;T&gt;&gt; els = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    els.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Set&lt;Set&lt;T&gt;&gt; newels = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;T&gt; s : els) &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : v) &#123;</span><br><span class="line">                Set&lt;T&gt; news = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(s);</span><br><span class="line">                <span class="keyword">if</span> (news.add(t))</span><br><span class="line">                    newels.add(news);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        els = newels;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> els;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计算子计划的查询代价：<code>private CostCard computeCostAndCardOfSubplan(Map&lt;String, TableStats&gt; stats, Map&lt;String, Double&gt; filterSelectivities, LogicalJoinNode joinToRemove, Set&lt;LogicalJoinNode&gt; joinSet, double bestCostSoFar, PlanCache pc)</code></p></li><li><p>将连接计划进行显示的图形表示：<code>private void printJoins(List&lt;LogicalJoinNode&gt; js, PlanCache pc, Map&lt;String, TableStats&gt; stats, Map&lt;String, Double&gt; selectivities)</code></p></li></ul><p><strong>方法实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;LogicalJoinNode&gt; <span class="title function_">orderJoins</span><span class="params">(</span></span><br><span class="line"><span class="params">        Map&lt;String, TableStats&gt; stats,</span></span><br><span class="line"><span class="params">        Map&lt;String, Double&gt; filterSelectivities, <span class="type">boolean</span> explain)</span></span><br><span class="line">        <span class="keyword">throws</span> ParsingException &#123;</span><br><span class="line">    <span class="comment">// Not necessary for labs 1 and 2.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">CostCard</span> <span class="variable">bestCostCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CostCard</span>();</span><br><span class="line">    <span class="type">PlanCache</span> <span class="variable">planCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlanCache</span>();</span><br><span class="line">    <span class="comment">// 思路：通过辅助方法获取每个size下最优的连接顺序，不断加入planCache中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= joins.size(); i++) &#123;</span><br><span class="line">        Set&lt;Set&lt;LogicalJoinNode&gt;&gt; subsets = enumerateSubsets(joins, i);</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;LogicalJoinNode&gt; set: subsets) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">bestCostSoFar</span> <span class="operator">=</span> Double.MAX_VALUE;</span><br><span class="line">            bestCostCard = <span class="keyword">new</span> <span class="title class_">CostCard</span>();</span><br><span class="line">            <span class="keyword">for</span> (LogicalJoinNode join: set) &#123;</span><br><span class="line">                <span class="comment">// 根据子计划找出最优方案</span></span><br><span class="line">                <span class="type">CostCard</span> <span class="variable">costCard</span> <span class="operator">=</span> computeCostAndCardOfSubplan(stats, filterSelectivities, join, set, bestCostSoFar, planCache);</span><br><span class="line">                <span class="keyword">if</span> (costCard == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bestCostSoFar = costCard.cost;</span><br><span class="line">                bestCostCard = costCard;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bestCostSoFar != Double.MAX_VALUE) &#123;</span><br><span class="line">                planCache.addPlan(set, bestCostCard.cost, bestCostCard.card, bestCostCard.plan);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (explain) &#123;</span><br><span class="line">        printJoins(bestCostCard.plan, planCache, stats, filterSelectivities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果joins传进来长度为0，则计划为空</span></span><br><span class="line">    <span class="keyword">if</span> (bestCostCard.plan != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bestCostCard.plan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-6.png"></p><h2 id="Extra-Credit"><a href="#Extra-Credit" class="headerlink" title="Extra Credit"></a>Extra Credit</h2><blockquote><p>改进子集迭代器<code>enumerateSubsets</code>方法的性能</p></blockquote><p><strong>原方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Set&lt;Set&lt;T&gt;&gt; <span class="title function_">enumerateSubsets</span><span class="params">(List&lt;T&gt; v, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    Set&lt;Set&lt;T&gt;&gt; els = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    els.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Set&lt;Set&lt;T&gt;&gt; newels = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;T&gt; s : els) &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : v) &#123;</span><br><span class="line">                Set&lt;T&gt; news = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(s);</span><br><span class="line">                <span class="keyword">if</span> (news.add(t))</span><br><span class="line">                    newels.add(news);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        els = newels;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> els;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><p>原先求子集的方法，需要不断的创建新对象，当size很大时时间复杂度非常高。此问题的本质实际上就是类似Leetcode利用回溯的组合问题。原方法的时间复杂度是<code>o(n^3)</code>，回溯的时间复杂度是<code>o(n*2^n)</code>，主要是看剪纸的效率如何。</p><p><img src="image-5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Set&lt;Set&lt;T&gt;&gt; <span class="title function_">enumerateSubsets</span><span class="params">(List&lt;T&gt; v, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    Set&lt;Set&lt;T&gt;&gt; els = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    dfs(els, v, size, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> els;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Set&lt;Set&lt;T&gt;&gt; els, List&lt;T&gt; v, <span class="type">int</span> size, <span class="type">int</span> curIdx, Deque&lt;T&gt; path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">        els.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> curIdx; i &lt; v.size(); i++) &#123;</span><br><span class="line">        path.addLast(v.get(i));</span><br><span class="line">        dfs(els, v, size, i + <span class="number">1</span>, path);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-4.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MIT6.5830 的数据库课程。Lab3 主要是完成数据库查询优化的成本优化器。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://kicheng.github.io/categories/MySQL/"/>
    
    
    <category term="database" scheme="https://kicheng.github.io/tags/database/"/>
    
    <category term="mysql" scheme="https://kicheng.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5830-Lab2</title>
    <link href="https://kicheng.github.io/2024/08/15/MIT6.5830-Lab2/"/>
    <id>https://kicheng.github.io/2024/08/15/MIT6.5830-Lab2/</id>
    <published>2024-08-15T11:09:44.000Z</published>
    <updated>2024-09-19T07:31:35.783Z</updated>
    
    <content type="html"><![CDATA[<p>MIT6.5830 的数据库课程。Lab2 主要是完成查询的连接和过滤、实现聚合下的查询操作、对表的插入删除以及实现数据库中非常重要的 LRU 页面置换算法。</p><span id="more"></span><h2 id="任务目录"><a href="#任务目录" class="headerlink" title="任务目录"></a>任务目录</h2><ul><li><p><input checked="" disabled="" type="checkbox">  Exercise1：实现查询的连接和过滤</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise2：实现聚合操作MIN、MAX、COUNT、SUM、AVG</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise3：实现修改表的方法，完成添加和删除</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise4：实现Insert和Delete操作符</p></li><li><p><input checked="" disabled="" type="checkbox">  Exercise5：实现BufferPool的页面置换算法</p></li></ul><h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><blockquote><p>实现Predicate、JoinPredicate、Filter、Join</p></blockquote><h3 id="Predicate类"><a href="#Predicate类" class="headerlink" title="Predicate类"></a>Predicate类</h3><p>Filter的辅助类，用于筛选满足条件的tuple：将tuple中的字段与<strong>指定字段</strong>进行比较，实现对单个tuple的过滤操作（比较逻辑有==、&gt;=、&lt;=、&gt;、&lt;、!=、LIKE等）。</p><p><img src="image-17.png"></p><p><strong>参数：</strong></p><ul><li><p>指定的比较字段(也是<code>Field.compare()</code>的参数)：<code>private Field operand;</code></p></li><li><p>tuple中指定字段对应字段的索引：<code>private int fieldIndex;</code></p></li><li><p>执行的比较逻辑，运算操作符(也是<code>Field.compare()</code>的参数)：<code>private Op op;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public Predicate(int field, Op op, Field operand)</code></p></li><li><p>返回tuple中对应字段的索引：<code>public int getField()</code></p></li><li><p>返回运算操作符：<code>public Op getOp()</code></p></li><li><p>返回指定的比较字段：<code>public Field getOperand()</code></p></li><li><p>对元组t进行比较：<code>public boolean filter(Tuple t)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Tuple t)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">otherOperand</span> <span class="operator">=</span> t.getField(fieldIndex);</span><br><span class="line">    <span class="keyword">return</span> otherOperand.compare(op, operand);  <span class="comment">// 例如: otherOperand &gt;= operand</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>IntField和StringField分别实现了Field接口中的<code>compare(op, operand)</code>方法。</p><ul><li>返回展示结果：<code>public String toString()</code></li></ul><h3 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h3><p>Filter类实现了Operator接口，根据Predicate的判断结果，得到满足结果的tuples，实现了类似于<code>where age &gt; 16</code>的过滤操作。</p><p><img src="image-14.png"></p><p><strong>参数：</strong></p><ul><li><p>通过Predicate成员变量，实现对每一个tuple的过滤操作：<code>private Predicate predicate;</code></p></li><li><p>待过滤的tuples迭代器，处理输入的元组流，并产生输出的元组流(在 Filter 的上下文中，通常只有一个子操作符)：<code>private OpIterator[] children;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public Filter(Predicate p, OpIterator child)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Filter</span><span class="params">(Predicate p, OpIterator child)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.predicate = p;</span><br><span class="line">    <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">OpIterator</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">this</span>.children[<span class="number">0</span>] = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回谓词predicate：<code>public Predicate getPredicate()</code></p></li><li><p>返回待过滤的tuple属性：<code>public TupleDesc getTupleDesc()</code></p></li><li><p>开启过滤迭代器：<code>public void open()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, NoSuchElementException,</span><br><span class="line">        TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">super</span>.open(); </span><br><span class="line">    children[<span class="number">0</span>].open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Filter是操作符Operator的子类，需要执行<code>super.open()</code>方法。</p><ul><li><p>关闭过滤迭代器：<code>public void close()</code></p></li><li><p>每次调用时，返回过滤后的下一个tuple：<code>protected Tuple fetchNext()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException,</span><br><span class="line">        TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">while</span> (children[<span class="number">0</span>].hasNext()) &#123;</span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> children[<span class="number">0</span>].next();</span><br><span class="line">        <span class="comment">// predicate封装了过滤条件，包括要比较的字段、比较操作符（如等于、大于等）和比较值</span></span><br><span class="line">        <span class="keyword">if</span> (predicate.filter(tuple)) &#123;</span><br><span class="line">            <span class="keyword">return</span> tuple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回待过滤的tuples迭代器：<code>public OpIterator[] getChildren()</code></p></li><li><p>设置待过滤的tuples迭代器：<code>public void setChildren(OpIterator[] children)</code></p></li></ul><h3 id="JoinPredicate类"><a href="#JoinPredicate类" class="headerlink" title="JoinPredicate类"></a>JoinPredicate类</h3><p>Join的辅助类，与Predicate类似，实现连接的条件，对两个tuple中的某一字段进行比较(类似<code>where t1.age = t2.age</code>)。</p><p><img src="image-9.png"></p><p><strong>参数：</strong></p><ul><li><p>tuple1进行比较的字段索引：<code>private int fieldIndex1;</code></p></li><li><p>tuple2进行比较的字段索引：<code>private int fieldIndex2;</code></p></li><li><p>执行的比较逻辑：<code>private Predicate.Op op;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public JoinPredicate(int field1, Predicate.Op op, int field2)</code></p></li><li><p>返回tuple1的字段索引：<code>public int getField1()</code></p></li><li><p>返回tuple2的字段索引：<code>public int getField2()</code></p></li><li><p>返回比较逻辑符：<code>public Predicate.Op getOperator()</code></p></li><li><p>对tuple1的字段和tuple2的字段进行比较：<code>public boolean filter(Tuple t1, Tuple t2)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Tuple t1, Tuple t2)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> t1.getField(fieldIndex1);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> t2.getField(fieldIndex2);</span><br><span class="line">    <span class="keyword">return</span> field1.compare(op, field2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Join类"><a href="#Join类" class="headerlink" title="Join类"></a>Join类</h3><p>和Filter类一样都实现了Operator接口，实现连接操作——对于给定两组tuple中满足JoinPredicate操作的两个tuple进行连接，连接方式采取最简单的<strong>嵌套循环连接</strong>。</p><p><img src="image-16.png"></p><p><strong>参数：</strong></p><ul><li><p>通过JoinPredicate成员变量，实现对两个tuple的连接操作：<code>private JoinPredicate joinPredicate;</code></p></li><li><p>用于连接的tuples迭代器：<code>private OpIterator[] children;</code></p><ul><li><p><em>Left Tuples迭代器: <code>children[0]</code></em></p></li><li><p><em>Right Tuples迭代器: <code>children[1]</code></em></p></li></ul></li><li><p><code>fetchNext()</code>方法每次用嵌套循环选择children[0]中的一个tuple1和children[1]中一个符合条件的tuple2进行连接，记录当前children[0]中的tuple：<code>private Tuple curTuple;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public Join(JoinPredicate p, OpIterator child1, OpIterator child2)</code></p></li><li><p>返回joinPredicate：<code>public JoinPredicate getJoinPredicate()</code></p></li><li><p>返回children[0]（左）中进行比较的字段名：<code>public String getJoinField1Name()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getJoinField1Name</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> children[<span class="number">0</span>].getTupleDesc().getFieldName(joinPredicate.getField1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回children[1]（右）中进行比较的字段名：<code>public String getJoinField2Name()</code></p></li><li><p>返回连接后tuple的字段属性，即新表的tupleDesc：<code>public TupleDesc getTupleDesc()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> TupleDesc.merge(children[<span class="number">0</span>].getTupleDesc(), children[<span class="number">1</span>].getTupleDesc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>调用TupleDesc类的merge操作完成两个tupleDesc的合并。</p><ul><li><p>迭代器相关开启、关闭、重启</p><ul><li><p><code>public void open()</code></p></li><li><p><code>public void close()</code></p></li><li><p><code>public void rewind()</code></p></li></ul></li><li><p>返回连接生成的下一个结果：<code>protected Tuple fetchNext()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">while</span> (children[<span class="number">0</span>].hasNext() || curTuple != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curTuple == <span class="literal">null</span>)</span><br><span class="line">            curTuple = children[<span class="number">0</span>].next();</span><br><span class="line">        Tuple rightTuple;</span><br><span class="line">        <span class="keyword">while</span>(children[<span class="number">1</span>].hasNext()) &#123;</span><br><span class="line">            rightTuple = children[<span class="number">1</span>].next();</span><br><span class="line">            <span class="keyword">if</span> (joinPredicate.filter(curTuple, rightTuple)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> curTuple.getTupleDesc().numFields();</span><br><span class="line">                <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> rightTuple.getTupleDesc().numFields();</span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">combiTuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(getTupleDesc());</span><br><span class="line">                <span class="comment">// join后的元组字段数等于左右两个元组字段数之和</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">                    combiTuple.setField(i, curTuple.getField(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">                    combiTuple.setField(i + len1, rightTuple.getField(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> combiTuple;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curTuple = <span class="literal">null</span>;</span><br><span class="line">        children[<span class="number">1</span>].rewind();  <span class="comment">// 重置右侧子操作符的迭代器到初始状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>采用嵌套循环的连接方式，即两个for循环遍历比较每一对元组：先获取<code>children[0]</code>中的一个tuple赋值给<code>curTuple</code>，令<code>curTuple</code>依次与<code>children[1]</code>中的所有tuples进行比较，<code>curTuple</code>与满足连接条件的tuple2进行连接并返回连接后的tuple，当完成<code>children[1]</code>的一次遍历后，<code>curTuple=children[0].next()</code> +<code>children[1].rewind()</code>。</p><ul><li><p>返回用于连接的tuples迭代器：<code>public OpIterator[] getChildren()</code></p></li><li><p>设置用于连接的tuples迭代器：<code>public void setChildren(OpIterator[] children)</code></p></li></ul><p><img src="image-13.png"></p><h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><blockquote><p>实现IntegerAggregator、StringAggregator、Aggregate类，实现5种SQL聚合(COUNT、SUM、AVG、MIN、MAX)，同时支持分组。</p></blockquote><h3 id="IntegerAggerator类"><a href="#IntegerAggerator类" class="headerlink" title="IntegerAggerator类"></a>IntegerAggerator类</h3><p><strong>参数：</strong></p><ul><li><p>无分组默认StringField字段：<code>private static final Field </code><em><code>NO_GROUP_FIELD </code></em><code>= new StringField(&quot;NO_GROUP_FIELD&quot;, 20);</code></p></li><li><p>分组字段的索引：<code>private int groupByIndex;</code></p></li><li><p>分组字段的类型（目前只有int和String）：<code>private Type groupByType;</code></p></li><li><p>聚合字段的索引：<code>private int aggregateIndex;</code></p></li><li><p>进行的聚合操作（5种SQL聚合操作）：<code>private Op aggOp;</code></p></li><li><p>分组计算的map结果集</p><ul><li>分组的结果（key–分组的字段，value–封装的结果类对象）：<code>private Map&lt;Field, GroupCalResult&gt; groupCalMap;</code></li></ul><blockquote><p>辅助类GroupCalResult：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GroupCalResult</span> &#123;</span><br><span class="line">    <span class="comment">// 根据不同的聚合操作，可能不会同时用到result和count，当聚合操作不使用该成员时设置默认值-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DEFAULT_RES</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">Deactivate_RES</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// result成员变量无效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DEFAULT_COUNT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">Deactivate_COUNT</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// count成员变量无效</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前分组计算的结果: sum, avg, max, min, count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Field出现的频率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupCalResult</span><span class="params">(<span class="type">int</span> result , <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>封装分组聚合的结果集，方便迭代器遍历查看结果（key–分组的字段，value–聚合元组tuple）：<code>private Map&lt;Field, Tuple&gt; resultMap;</code></li></ul></li><li><p>聚合后tuple的tupleDesc：<code>private TupleDesc aggDesc;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public IntegerAggregator(int gbfield, Type gbfieldtype, int afield, Op what)</code></p><p>根据是否有group分组确定聚合后的表字段属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IntegerAggregator</span><span class="params">(<span class="type">int</span> gbfield, Type gbfieldtype, <span class="type">int</span> afield, Op what)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.groupByIndex = gbfield;</span><br><span class="line">    <span class="built_in">this</span>.groupByType = gbfieldtype;</span><br><span class="line">    <span class="built_in">this</span>.aggregateIndex = afield;</span><br><span class="line">    <span class="built_in">this</span>.aggOp = what;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init map</span></span><br><span class="line">    <span class="built_in">this</span>.groupCalMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.resultMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (groupByIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 有groupBy</span></span><br><span class="line">        <span class="built_in">this</span>.aggDesc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;groupByType, Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;groupVal&quot;</span>, <span class="string">&quot;aggregateVal&quot;</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无groupBy</span></span><br><span class="line">        <span class="built_in">this</span>.aggDesc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aggregateVal&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分组聚合操作的执行方法：<code>public void mergeTupleIntoGroup(Tuple tup)</code></p><p>聚合操作的流程是：先读取一个tuple进行聚合操作，得到一个只聚合了一个tuple的聚合结果，之后每读取一个tuple就将其加入到聚合结果中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTupleIntoGroup</span><span class="params">(Tuple tup)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">groupByField</span> <span class="operator">=</span> <span class="built_in">this</span>.groupByIndex == NO_GROUPING ? NO_GROUP_FIELD : tup.getField(groupByIndex);</span><br><span class="line">    <span class="comment">// 分组字段类型检查</span></span><br><span class="line">    <span class="keyword">if</span>(!NO_GROUP_FIELD.equals(groupByField) &amp;&amp; groupByField.getType() != groupByType) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected groupByType: 「&quot;</span> + groupByType + <span class="string">&quot;」, but got: &quot;</span> + groupByField.getType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 聚合字段类型检查</span></span><br><span class="line">    <span class="keyword">if</span>(!(tup.getField(aggregateIndex) <span class="keyword">instanceof</span> IntField)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected aggType is 「IntField」, but got: &quot;</span> + tup.getField(aggregateIndex).getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、store</span></span><br><span class="line">    groupStore(tup, groupByField);</span><br><span class="line">    <span class="comment">// 2、cal</span></span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">curCalTuple</span> <span class="operator">=</span> calResult(groupByField);</span><br><span class="line">    <span class="comment">// 3、update</span></span><br><span class="line">    resultMap.put(groupByField, curCalTuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>分组聚合核心算法：根据不同的聚合操作，GroupCalResult(result, count)封装了分组聚合的结果。例如<code>MIN</code>操作，GroupCalResult的count成员是无效的，故将其置为*<code>Deactivate_COUNT</code>。*</p><p>计算聚合后的结果，如果存在分组则结果字段属性为“分组字段+结果”，若不存在分组则结果字段属性为“结果”。</p><ul><li><p>返回聚合结果的迭代器：<code>public OpIterator iterator()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OpIterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntAggTupIterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>聚合结果的迭代器辅助类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">IntAggTupIterator</span> <span class="keyword">implements</span> <span class="title class_">OpIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">open</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Map.Entry&lt;Field, Tuple&gt;&gt; iter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        iter = resultMap.entrySet().iterator();</span><br><span class="line">        open = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        open = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> open &amp;&amp; iter.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iter.next().getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.close();</span><br><span class="line">        <span class="built_in">this</span>.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aggDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-6.png"></p><h3 id="StringAggerator类"><a href="#StringAggerator类" class="headerlink" title="StringAggerator类"></a>StringAggerator类</h3><p>对String类型的字段实现分组聚合操作，思路和IntegerAggerator一致，不过对于String类型来说只需要实现<code>COUNT</code>聚合操作。</p><p><strong>参数：</strong></p><ul><li><p>无分组默认StringField字段：<code>private static final Field </code><em><code>NO_GROUP_FIELD </code></em><code>= new StringField(&quot;NO_GROUP_FIELD&quot;, 20);</code></p></li><li><p>分组字段的索引：<code>private int groupByIndex;</code></p></li><li><p>分组字段的类型：<code>private Type groupByType;</code></p></li><li><p>聚合字段的索引：<code>private int aggregateIndex;</code></p></li><li><p>聚合结果的字段属性：<code>private TupleDesc aggDesc;</code></p></li><li><p>分组计算的map结果集：</p><ul><li><p>分组的结果：<code>private Map&lt;Field, Integer&gt; groupCalMap;</code></p><p>因为只有<code>COUNT</code>聚合操作符，所以不需要使用GroupCalResult辅助类来区分result和count，value直接使用Integer类型即可。</p></li><li><p>private Map&lt;Field, Tuple&gt; resultMap;</p></li></ul></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public StringAggregator(int gbfield, Type gbfieldtype, int afield, Op what)</code></p></li><li><p>分组聚合操作的执行方法：<code>public void mergeTupleIntoGroup(Tuple tup)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTupleIntoGroup</span><span class="params">(Tuple tup)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">groupField</span> <span class="operator">=</span> groupByIndex &gt;= <span class="number">0</span> ? tup.getField(groupByIndex) : NO_GROUP_FIELD;</span><br><span class="line">    <span class="comment">// 分组字段类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (!NO_GROUP_FIELD.equals(groupField) &amp;&amp; groupField.getType() != groupByType) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected groupByType: 「&quot;</span> + groupByType + <span class="string">&quot;」, but got: &quot;</span> + groupField.getType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 聚合字段类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (!(tup.getField(aggregateIndex) <span class="keyword">instanceof</span> StringField)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected aggregateType: 「&quot;</span> + Type.STRING_TYPE + <span class="string">&quot;」, but got: &quot;</span> + tup.getField(aggregateIndex).getType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、store</span></span><br><span class="line">    groupCalMap.put(groupField, <span class="built_in">this</span>.groupCalMap.getOrDefault(groupField, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2、cal</span></span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">curCalTuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(aggDesc);</span><br><span class="line">    <span class="keyword">if</span> (groupByIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        curCalTuple.setField(<span class="number">0</span>, groupField);</span><br><span class="line">        curCalTuple.setField(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(groupCalMap.get(groupField)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curCalTuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(groupCalMap.get(groupField)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、update</span></span><br><span class="line">    resultMap.put(groupField, curCalTuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回聚合结果的迭代器：<code>public OpIterator iterator()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OpIterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringAggTupIterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>聚合结果的迭代器辅助类（同IntegerAggerator）</p></blockquote></li></ul><p><img src="image-7.png"></p><h3 id="Aggerator类"><a href="#Aggerator类" class="headerlink" title="Aggerator类"></a>Aggerator类</h3><p>对IntegerAggerator、StringAggerator类进行封装。</p><p><strong>参数：</strong></p><ul><li><p>需要聚合的tuples迭代器：<code>OpIterator[] children;</code></p></li><li><p>聚合字段的索引：<code>private int aggregateIndex;</code></p></li><li><p>分组字段的索引：<code>private int groupByIndex;</code></p></li><li><p>聚合操作（5种SQL聚合操作）：<code>private Op aggregateOp;</code></p></li><li><p>进行聚合操作的类（IntegerAggregator或StringAggregator）：<code>private Aggregator aggregator;</code></p></li><li><p>存放聚合结果的迭代器：<code>private OpIterator resultIterator;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public Aggregate(OpIterator child, int afield, int gfield, Aggregator.Op aop)</code></p><p>注意为aggregator聚合操作赋值，判断是IntAggregate还是StringAggregate。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Aggregate</span><span class="params">(OpIterator child, <span class="type">int</span> afield, <span class="type">int</span> gfield, Aggregator.Op aop)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">OpIterator</span>[] &#123;child&#125;;</span><br><span class="line">    <span class="built_in">this</span>.aggregateIndex = afield;</span><br><span class="line">    <span class="built_in">this</span>.groupByIndex = gfield;</span><br><span class="line">    <span class="built_in">this</span>.aggregateOp = aop;</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">groupType</span> <span class="operator">=</span> gfield != Aggregator.NO_GROUPING ? child.getTupleDesc().getFieldType(gfield) : Type.STRING_TYPE;  <span class="comment">// 如果没有分组字段，则默认为字符串类型</span></span><br><span class="line">    <span class="keyword">if</span> (child.getTupleDesc().getFieldType(afield) == Type.INT_TYPE) &#123;</span><br><span class="line">        <span class="built_in">this</span>.aggregator = <span class="keyword">new</span> <span class="title class_">IntegerAggregator</span>(gfield, groupType, afield, aop);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.aggregator = <span class="keyword">new</span> <span class="title class_">StringAggregator</span>(gfield, groupType, afield, aop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回分组的字段索引：<code>public int groupField()</code></p></li><li><p>返回分组的字段名：<code>public String groupFieldName()</code></p></li><li><p>返回聚合的字段索引：<code>public int aggregateField()</code></p></li><li><p>返回聚合的字段名：<code>public String aggregateFieldName()</code></p></li><li><p>返回聚合操作符：<code>public Aggregator.Op aggregateOp()</code></p></li><li><p>迭代器相关</p><ul><li><p>聚合操作的核心逻辑代码：<code>public void open()</code></p><p>将IntAggerator和StringAggerator聚合结果封装在resultIterator迭代器中。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException, DbException,</span><br><span class="line">        TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="built_in">super</span>.open();</span><br><span class="line">    children[<span class="number">0</span>].open();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.children[<span class="number">0</span>].hasNext()) &#123;</span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">nextTuple</span> <span class="operator">=</span> children[<span class="number">0</span>].next();</span><br><span class="line">        aggregator.mergeTupleIntoGroup(nextTuple);  <span class="comment">// 逐行进行聚合操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    resultIterator = aggregator.iterator();</span><br><span class="line">    resultIterator.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>protected Tuple fetchNext()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (resultIterator.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> resultIterator.next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>public void close()</code></p></li><li><p><code>public void rewind()</code></p></li></ul></li><li><p>获取聚合结果的字段属性（<del>不是原tuples迭代器的字段属性</del>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> aggregator.iterator().getTupleDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-12.png"></p><p><img src="image-11.png"></p><h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h2><blockquote><p>实现HeapPage、HeapFile、BufferPool中的insertTuple、deleteTuple</p></blockquote><p>要实现对数据表数据的增添和删除，先从文件和物理页的层次开始。</p><p>Removing Tuples：要移除一个Tuple需要实现deleteTuple，Tuple包含RecordID能够帮助找到tuple存储的物理页，所以思路就是通过RecordID找到对应的物理页，并修改物理页的header。</p><p>Adding Tuples：对于文件层面，insertTuple方法负责添加一个tuple到HeapFile中，大致思路是：到页中找一个空闲的slot；如果HeapFile不存在这样的页就需要新建一个页，并添加新页到磁盘上。同时还要保证新添tuple的RecordID正确更新。</p><p><strong>在insert和delete中BufferPool、HeapFile、HeapPage的作用：</strong></p><p><img src="image-10.png"></p><p>对于BufferPool和HeapFile来说，是相互调用的关系：HeapFile调用BufferPool的getPage方法获取数据页：在页面存在于BufferPool中时直接从BufferPool获取；不存在时还需调用HeapFile的readPage方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Page <span class="title function_">getPage</span><span class="params">(TransactionId tid, PageId pid, Permissions perm)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="keyword">if</span>(!bufferPools.containsKey(pid)) &#123;</span><br><span class="line">        <span class="type">DbFile</span> <span class="variable">file</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(pid.getTableId());</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> file.readPage(pid);  <span class="comment">// 调用HeapFile的readPage方法</span></span><br><span class="line">        bufferPools.put(pid, page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bufferPools.get(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HeapPage类"><a href="#HeapPage类" class="headerlink" title="HeapPage类"></a>HeapPage类</h3><p><strong>参数：</strong></p><ul><li><p>脏页标志位：<code>private boolean dirtyFlag;</code></p></li><li><p>产生脏页的事务id：<code>private TransactionId dirtyTid;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>选择一个空slot插入tuple，同时修改该slot对应header的bitmap，表示该slot已被数据占用：<code>public void insertTuple(Tuple t)</code></p><p>插入数据的三个要点：① 设置slot的bitmap； ② 设置tuple在磁盘的位置recordID； ③ 向页面中插入真实数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertTuple</span><span class="params">(Tuple t)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="keyword">if</span> (getNumUnusedSlots() == <span class="number">0</span> || !t.getTupleDesc().equals(td)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;page is full or tupleDesc is mismatch.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numSlots; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSlotUsed(i)) &#123;</span><br><span class="line">            markSlotUsed(i, <span class="literal">true</span>);  <span class="comment">// 设置slot的bitmap</span></span><br><span class="line">            t.setRecordId(<span class="keyword">new</span> <span class="title class_">RecordId</span>(pid, i));  <span class="comment">// 设置recordID</span></span><br><span class="line">            tuples[i] = t;  <span class="comment">// 向页面插入数据</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除指定的tuple，同时修改slot对应的bitmap，表示该slot已为空：<code>public void deleteTuple(Tuple t)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTuple</span><span class="params">(Tuple t)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tid</span> <span class="operator">=</span> t.getRecordId().getTupleNumber();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tuples.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.equals(tuples[i])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSlotUsed(i)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;tuple slot is already empty&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            markSlotUsed(i, <span class="literal">false</span>);</span><br><span class="line">            tuples[tid] = <span class="literal">null</span>;  <span class="comment">// delete</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;the tuple is not on this page&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改脏页标志位：<code>public void markDirty()</code></p></li><li><p>如果该page是脏页则返回产生脏页的事务id：<code>public TransactionId isDirty()</code></p></li><li><p>修改page中的header，value为true表示在第i位设置为1，value为false表示在第i位设置为0：<code>private void markSlotUsed(int i, boolean value)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">markSlotUsed</span><span class="params">(<span class="type">int</span> i, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">iTh</span> <span class="operator">=</span> i / <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bitTh</span> <span class="operator">=</span> i % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">onBit</span> <span class="operator">=</span> (header[iTh] &gt;&gt; bitTh) &amp; <span class="number">1</span>;  <span class="comment">// 判断该slot位是否被使用</span></span><br><span class="line">    <span class="keyword">if</span> (onBit == <span class="number">0</span> &amp;&amp; value) &#123;</span><br><span class="line">        <span class="comment">// 未使用，现在使用</span></span><br><span class="line">        header[iTh] += (<span class="type">byte</span>) (<span class="number">1</span> &lt;&lt; bitTh);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onBit == <span class="number">1</span> &amp;&amp; !value) &#123;</span><br><span class="line">        <span class="comment">// 已使用，现在未使用</span></span><br><span class="line">        header[iTh] -= (<span class="type">byte</span>) (<span class="number">1</span> &lt;&lt; bitTh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-5.png"></p><h3 id="HeapFile类"><a href="#HeapFile类" class="headerlink" title="HeapFile类"></a>HeapFile类</h3><p><strong>方法：</strong></p><ul><li><p>将page写入磁盘，同时清除脏页标志：<code>public void writePage(Page page)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writePage</span><span class="params">(Page page)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">PageId</span> <span class="variable">pageId</span> <span class="operator">=</span> page.getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> pageId.getPageNumber();</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> pageNo * BufferPool.getPageSize();</span><br><span class="line">    <span class="type">byte</span>[] pageData = page.getPageData();</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    file.seek(offset);</span><br><span class="line">    file.write(pageData);</span><br><span class="line">    file.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除脏页</span></span><br><span class="line">    page.markDirty(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将tuple插入到HeapFile的page中，如果HeapFile的page都满了还要在HeapFile中创建一个新的page：<code>public List&lt;Page&gt; insertTuple(TransactionId tid, Tuple t)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Page&gt; <span class="title function_">insertTuple</span><span class="params">(TransactionId tid, Tuple t)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    ArrayList&lt;Page&gt; pageList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numPages(); i++) &#123;</span><br><span class="line">        <span class="type">HeapPage</span> <span class="variable">p</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid, <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(getId(), i),</span><br><span class="line">                Permissions.READ_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (p.getNumUnusedSlots() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前页面没有空闲槽位</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.insertTuple(t);  <span class="comment">// 调用HeapPage的insertTuple方法</span></span><br><span class="line">        pageList.add(p);</span><br><span class="line">        <span class="keyword">return</span> pageList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到合适的页面，需要创建新的页面</span></span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f, <span class="literal">true</span>));</span><br><span class="line">    <span class="type">byte</span>[] emptyData = HeapPage.createEmptyPageData();</span><br><span class="line">    bos.write(emptyData);</span><br><span class="line">    bos.close();</span><br><span class="line">    <span class="comment">// 加载入BufferPool</span></span><br><span class="line">    <span class="type">HeapPage</span> <span class="variable">p</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid, <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(getId(), numPages()-<span class="number">1</span>),</span><br><span class="line">            Permissions.READ_WRITE);  <span class="comment">// pgNo: numPages()方法的返回值是基于文件当前的大小动态计算的</span></span><br><span class="line">    p.insertTuple(t);</span><br><span class="line">    pageList.add(p);</span><br><span class="line">    <span class="keyword">return</span> pageList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新page时将<code>pageNo</code>设置为<code>numPages()-1</code>而不是<code>numPages()</code>是因为<code>numPages()</code>方法的返回值是基于文件当前的大小动态计算的，默认新page的pageNo是最后一个。</p><blockquote><p>BufferedInputStream和BufferedOutputStream类就是实现缓冲功能的输入/输出流，使用带缓冲的输入/输出流，效率更高、速度更快。</p><p>使用步骤：①创建FileOutputStream对象，构造方法中绑定要输出的目标文件； ②创建BufferOutputStream对象，使用write方法将数据写入内部缓冲区； ③使用BufferOutputStream的flush方法将缓冲区数据刷新到文件； ④释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bos.txt&quot;</span>)) ;</span><br><span class="line">bos.write(<span class="string">&quot;hello&quot;</span>.getBytes());  <span class="comment">//写数据</span></span><br><span class="line">bos.close();  <span class="comment">//释放资源</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>将HeapFile中某一个page上的tuple从该page中删除：<code>public List&lt;Page&gt; deleteTuple(TransactionId tid, Tuple t)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Page&gt; <span class="title function_">deleteTuple</span><span class="params">(TransactionId tid, Tuple t)</span> <span class="keyword">throws</span> DbException,</span><br><span class="line">        TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">HeapPage</span> <span class="variable">p</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid, t.getRecordId().getPageId(), Permissions.READ_WRITE);</span><br><span class="line">    p.deleteTuple(t);</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>根据tuple的RecordID属性也可以通过getPageId找到tuple所在的page页。</p><p><img src="image-8.png"></p><p>可以自行对比一下lab1和lab2中方法实现的区别：</p><p><img src="image-15.png"></p><h3 id="BufferPool类"><a href="#BufferPool类" class="headerlink" title="BufferPool类"></a>BufferPool类</h3><p>insert和delete这里BufferPool涉及到页面置换策略，其实也就是LRU策略。所以这部分实现放到Exercise5中一起来做。</p><h2 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h2><blockquote><p>实现Insert类、Delete类，对exercise3的功能进行封装</p></blockquote><p>实现Insert和Delete操作符，用于修改磁盘上的页数据，这些操作符返回受影响的tuples个数（受影响的行数）。</p><h3 id="Insert类"><a href="#Insert类" class="headerlink" title="Insert类"></a>Insert类</h3><p><strong>参数：</strong></p><ul><li><p>执行插入操作的事务id：<code>private TransactionId tid;</code></p></li><li><p>待插入的tuples的迭代器：<code>private OpIterator[] children;</code></p></li><li><p>待插入的表id：<code>private int tableId;</code></p></li><li><p>fetchNext方法会返回一个标识插入了多少行的tuple结果，tupleDesc就是该tuple的属性行：<code>private TupleDesc tupleDesc;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.tupleDesc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;insertNums&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>插入受影响行数的tuple结果（最主要的作用是避免fetchNext方法无限制的向下取，保证只调用一次）：<code>private Tuple insertRes;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public Insert(TransactionId t, OpIterator child, int tableId)</code></p></li><li><p>执行插入操作，返回包含插入受影响行数的tuple：<code>protected Tuple fetchNext()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 保证只调用一次，多次调用返回null</span></span><br><span class="line">    <span class="keyword">if</span> (insertRes != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">insertNums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (children[<span class="number">0</span>].hasNext()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Database.getBufferPool().insertTuple(tid, tableId, children[<span class="number">0</span>].next());</span><br><span class="line">            insertNums++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Insert tuples into database failed!&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insertRes = <span class="keyword">new</span> <span class="title class_">Tuple</span>(tupleDesc);  <span class="comment">// 计算插入操作影响的行数</span></span><br><span class="line">    insertRes.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(insertNums));</span><br><span class="line">    <span class="keyword">return</span> insertRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Delete类"><a href="#Delete类" class="headerlink" title="Delete类"></a>Delete类</h3><p>封装类的实现和Insert类完全相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTuple</span><span class="params">(Tuple t)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tid</span> <span class="operator">=</span> t.getRecordId().getTupleNumber();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tuples.length; i++) &#123;</span><br><span class="line"><span class="comment">//            if (t.equals(tuples[i])) &#123;</span></span><br><span class="line">            <span class="keyword">if</span>(tuples[i] != <span class="literal">null</span> &amp;&amp; compareTuplesByFields(t, tuples[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isSlotUsed(i)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;tuple slot is already empty&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                markSlotUsed(i, <span class="literal">false</span>);</span><br><span class="line">                tuples[tid] = <span class="literal">null</span>;  <span class="comment">// delete</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;the tuple is not on this page&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="image-4.png"></p><h2 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h2><blockquote><p>Eviction Policy有很多，可以自己选择，我选择的是最常见的LRU策略。</p></blockquote><p>Lab1中在BufferPool满后会抛出异常，这里实现了BufferPool的页面置换策略，采取的是LRU的策略（详见LeetCode中的实现 <a href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2%5C&amp;envId=top-100-liked">https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2\&amp;envId=top-100-liked</a> ）。</p><h3 id="BufferPool类-1"><a href="#BufferPool类-1" class="headerlink" title="BufferPool类"></a>BufferPool类</h3><p>原先采用的是HashMap保存pageId和page的映射：<code>private final Map&lt;PageId, Page&gt; bufferPools = new ConcurrentHashMap&lt;&gt;();</code>，加入页面置换策略后改用自定义的LRUCache类（维护一个<strong>双向链表</strong>）来存储pageId和page的映射关系。</p><blockquote><p>同时还涉及exercise3中BufferPool的插入、删除操作。</p></blockquote><p><strong>参数：</strong></p><ul><li><p>LRUCache类：<code>private static class LRUCache</code></p><p>为了实现LRU算法，需要维护一个双向链表LRUCache，用于记录每个<em>PageId</em>的访问顺序<em>。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了实现LRU算法，需要维护一个双向链表，用于记录每个PageId的访问顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> capacity, size;</span><br><span class="line">    ConcurrentHashMap&lt;PageId, Node&gt; map;</span><br><span class="line">    <span class="comment">// 头节点和尾节点：标志位无数据</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Page <span class="title function_">get</span><span class="params">(PageId key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="comment">// 定位到链表头</span></span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(PageId key, Page val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 更新value</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.val = val;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加到链表头</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 移除链表尾</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                map.remove(node.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到链表头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到链表头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 先从原位置删除node</span></span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="comment">// 再将node插入链表头部</span></span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除node节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除尾部节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        PageId key;</span><br><span class="line">        Page val;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(PageId key, Page val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;PageId, Node&gt;&gt; getEntrySet() &#123;</span><br><span class="line">        <span class="keyword">return</span> map.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法：</strong></p><p><img src="image.png"></p><ul><li><p>调用HeapFile的<code>insertTuple</code>方法插入元组，将返回的结果保存到BufferPool：<code>public void insertTuple(TransactionId tid, int tableId, Tuple t)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertTuple</span><span class="params">(TransactionId tid, <span class="type">int</span> tableId, Tuple t)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">DbFile</span> <span class="variable">f</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(tableId);</span><br><span class="line">    List&lt;Page&gt; updatePages = f.insertTuple(tid, t);</span><br><span class="line">    updateBufferPool(updatePages, tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用HeapFile的<code>deleteTuple</code>方法删除元组，将结果保存到BufferPool：<code>public void deleteTuple(TransactionId tid, Tuple t)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTuple</span><span class="params">(TransactionId tid, Tuple t)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">DbFile</span> <span class="variable">f</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(t.getRecordId().getPageId().getTableId());</span><br><span class="line">    List&lt;Page&gt; updatePages = f.deleteTuple(tid, t);</span><br><span class="line">    updateBufferPool(updatePages, tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更新BufferPool的存储：<code>public void updateBufferPool(List&lt;Page&gt; updatePages, TransactionId id)</code></p><p>注意将页面设置为脏页，因为在BufferPool中修改page后，和磁盘中的page不一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBufferPool</span><span class="params">(List&lt;Page&gt; updatePages, TransactionId id)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Page page: updatePages) &#123;</span><br><span class="line">        page.markDirty(<span class="literal">true</span>, id);  <span class="comment">// 设置为脏页（因为在BufferPool中修改page后，和磁盘中的page不一致了）</span></span><br><span class="line">        <span class="comment">// update BufferPool</span></span><br><span class="line">        lruCache.put(page.getId(), page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从BufferPool中移除页面：<code>public synchronized void removePage (PageId pid)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removePage</span><span class="params">(PageId pid)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="literal">null</span>) &#123;</span><br><span class="line">        lruCache.map.remove(pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将某个页面如果是脏页则刷新到磁盘：<code>private synchronized void flushPage(PageId pid)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(PageId pid)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> lruCache.get(pid);</span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TransactionId</span> <span class="variable">tid</span> <span class="operator">=</span> page.isDirty();</span><br><span class="line">    <span class="keyword">if</span> (tid != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Page</span> <span class="variable">before</span> <span class="operator">=</span> page.getBeforeImage();</span><br><span class="line">        Database.getLogFile().logWrite(tid, before, page);</span><br><span class="line">        Database.getCatalog().getDatabaseFile(pid.getTableId()).writePage(page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将所有脏页刷新到磁盘：<code>public synchronized void flushAllPages()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">flushAllPages</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;PageId, LRUCache.Node&gt; group: lruCache.getEntrySet()) &#123;</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> group.getValue().val;</span><br><span class="line">        <span class="keyword">if</span> (page.isDirty() != <span class="literal">null</span>) &#123;</span><br><span class="line">            flushPage(group.getKey());  <span class="comment">// 将不是脏页的页面刷新页面到磁盘</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-1.png"></p><p><img src="image-2.png"></p><p>要判断要删除的目标元组的字段是否和提供的相等，而不是地址相等：</p><p><img src="image-3.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MIT6.5830 的数据库课程。Lab2 主要是完成查询的连接和过滤、实现聚合下的查询操作、对表的插入删除以及实现数据库中非常重要的 LRU 页面置换算法。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://kicheng.github.io/categories/MySQL/"/>
    
    
    <category term="database" scheme="https://kicheng.github.io/tags/database/"/>
    
    <category term="mysql" scheme="https://kicheng.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5830-Lab1</title>
    <link href="https://kicheng.github.io/2024/08/06/MIT6.5830-Lab1/"/>
    <id>https://kicheng.github.io/2024/08/06/MIT6.5830-Lab1/</id>
    <published>2024-08-06T12:07:44.000Z</published>
    <updated>2024-09-19T07:31:47.055Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间学习一下 MySQL，正好准备一个手撕轮子项目，就准备完成这个 MIT6.5830 的数据库课程。Lab1 主要是完成一些简单的数据库定义以及实现简单的全表扫描。</p><span id="more"></span><h2 id="任务目录"><a href="#任务目录" class="headerlink" title="任务目录"></a>任务目录</h2><ul><li><p><input checked="" disabled="" type="checkbox">  exercise1：实现元组以及元组属性字段</p></li><li><p><input checked="" disabled="" type="checkbox">  exercise2：实现数据库目录，包含数据库现有的表信息</p></li><li><p><input checked="" disabled="" type="checkbox">  exercise3：实现BufferPool，将内存读取过的数据页缓存下来</p></li><li><p><input checked="" disabled="" type="checkbox">  exercise4：实现页面id、数据记录id以及Page类</p></li><li><p><input checked="" disabled="" type="checkbox">  exercise5：实现磁盘文件的接口HeapFile，通过HeapFile可以从磁盘读写数据</p></li><li><p><input checked="" disabled="" type="checkbox">  exercise6：实现全表扫描</p></li></ul><h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><blockquote><p>实现Tuple、TupleDesc两个类</p></blockquote><p>在数据库中，行被称为元组(tuple)或记录(record)，列称为字段(field)。tuple元组在数据库中是一组Field对象的集合。</p><p><img src="image-18.png"></p><h3 id="TupleDesc类"><a href="#TupleDesc类" class="headerlink" title="TupleDesc类"></a>TupleDesc类</h3><p><img src="image-15.png"></p><p><strong>参数：</strong></p><ul><li><code>private CopyOnWriteArrayList&lt;TDItem&gt; tdItems</code></li></ul><blockquote><p>TupleDesc中提供了一个TDItem内部辅助类，类中定义了<code>Type fieldType</code>和<code>String fieldName</code>两个成员变量（Type是枚举类型，当前只实现了INT_TYPE和STRING_TYPE）。</p></blockquote><p><strong>方法：</strong></p><ul><li><p>初始化方法：<code>public TupleDesc(Type[] typeAr, String[] fieldAr)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TupleDesc</span><span class="params">(Type[] typeAr, String[] fieldAr)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    tdItems = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (typeAr.length != fieldAr.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeAr.length; i++) &#123;</span><br><span class="line">        tdItems.add(<span class="keyword">new</span> <span class="title class_">TDItem</span>(typeAr[i], fieldAr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回所有属性的迭代器：<code>public Iterator&lt;TDItem&gt; iterator()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;TDItem&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (tdItems == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tdItems.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回TupleDesc属性的数量：<code>public int numFields()</code></p></li><li><p>返回第i个属性的属性名：<code>public String getFieldName(int i)</code></p></li><li><p>返回第i个属性的属性类型：<code>public Type getFieldType(int i)</code></p></li><li><p>根据属性名返回属性在tditem中的序号：<code>public int indexForFieldName(String name)</code></p></li><li><p>返回此TupleDesc对应的元组所占字节大小：<code>public int getSize()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dataSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numFields(); i++) &#123;</span><br><span class="line">        <span class="comment">// Type中存在getLen()方法，可获取INT_TYPE和STRING_TYPE字节数</span></span><br><span class="line">        dataSize += tdItems.get(i).fieldType.getLen();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并两个TupleDesc：<code>public static TupleDesc merge(TupleDesc td1, TupleDesc td2)</code></p></li><li><p>判断两个TupleDesc是否相等：<code>public boolean equals(Object o)</code></p><p>相等条件：两个TupleDesc的属性数量相等，且tditem1[i]和tditem2[i]属性类型相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// instanceof 测试左边的对象是否是右边“特定类or其子类”的实例</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> TupleDesc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TupleDesc</span> <span class="variable">other</span> <span class="operator">=</span> (TupleDesc) o;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.numFields() != other.numFields() || <span class="built_in">this</span>.tdItems.size() != other.tdItems.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.numFields(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.getFieldType(i).equals(other.getFieldType(i))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>instanceof</li></ol><p>语法：<code>boolean result = object instanceof Class（该类、父类、接口）;</code></p><p>用法：① 判断object对象是否是class类实例； ② 判断object对象是否是class类的子类的实例； ② 判断object对象是否是接口实现类的实例。</p><p><img src="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;===============instanceof阶段测试1===============&quot;</span>);</span><br><span class="line"><span class="comment">// 判断object对象是否为 class类本身的实例</span></span><br><span class="line">System.out.println(computer <span class="keyword">instanceof</span> Computer);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断object对象是否为 class类的子类的实例</span></span><br><span class="line">System.out.println(computer <span class="keyword">instanceof</span> Machine);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断object对象是否为 接口的实现类的实例</span></span><br><span class="line">System.out.println(mouse <span class="keyword">instanceof</span> usb);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===============instanceof阶段测试2===============&quot;</span>);</span><br><span class="line"><span class="comment">// 所有对象都为Object类</span></span><br><span class="line">System.out.println(computer <span class="keyword">instanceof</span> Object);  <span class="comment">// true</span></span><br><span class="line">System.out.println(mouse <span class="keyword">instanceof</span> Object);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===============instanceof阶段测试3===============&quot;</span>);</span><br><span class="line"><span class="comment">// null不是任何类的实例</span></span><br><span class="line">System.out.println(<span class="literal">null</span> <span class="keyword">instanceof</span> Object);  <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="literal">null</span> <span class="keyword">instanceof</span> Computer);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>isInstance</li></ul><p>语法：<code>boolean result = Class.class.isInstance(object);</code></p><p>用法：同上（判断object对象能否被转化为这个Class类）</p></blockquote></li><li><p>返回该TupleDesc的哈希值：<code>public int hashCode()</code></p></li><li><p>展示TupleDesc的所有属性类型+属性名：<code>public String toString()</code></p></li></ul><h3 id="Tuple类"><a href="#Tuple类" class="headerlink" title="Tuple类"></a>Tuple类</h3><p><img src="image-19.png"></p><p><strong>参数：</strong></p><ul><li><p><code>private TupleDesc td;</code></p></li><li><p>元组的id：<code>private RecordId rid;</code></p></li><li><p>存储Tuple中所有字段：<code>CopyOnWriteArrayList&lt;Field&gt; fields;</code></p><blockquote><p>Field接口，包含compare()、getType()、equals()、toString()方法，IntField 和 StringField 类实现了该接口。</p></blockquote></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public Tuple(TupleDesc td)</code></p></li><li><p>获得元组对应的字段属性：<code>public TupleDesc getTupleDesc()</code></p></li><li><p>获得元组id：<code>public RecordId getRecordId()</code></p></li><li><p>设置元组id：<code>public void setRecordId(RecordId rid)</code></p></li><li><p>为Tuple的第i个字段赋值：<code>public void setField(int i, Field f)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">(<span class="type">int</span> i, Field f)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= fields.size()) &#123;</span><br><span class="line">        fields.add(f);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fields.set(i, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得第i个字段：<code>public Field getField(int i)</code></p></li><li><p>展示该Tuple的所有字段值：<code>public String toString()</code></p></li><li><p>返回元组字段的迭代器：<code>public Iterator&lt;Field&gt; fields()</code></p></li><li><p>重置TupldeDesc：<code>public void resetTupleDesc(TupleDesc td)</code></p></li></ul><p><img src="image-17.png"></p><h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><blockquote><p>实现Catalog类</p></blockquote><p><img src="image-4.png"></p><h3 id="Catalog类"><a href="#Catalog类" class="headerlink" title="Catalog类"></a>Catalog类</h3><p>Catalog管理着数据库中的所有表：</p><p><img src="image-1.png"></p><blockquote><p>dbFile是什么 —— 每一个DbFile对应数据库中的一张表。</p><p><img src="image-10.png"></p><p><img src="image-11.png"></p></blockquote><p><strong>参数：</strong></p><ul><li><p>表id与表的映射：<code>ConcurrentHashMap&lt;Integer, Table&gt; tableIdMap;</code></p><blockquote><p>Table类包含参数tableName、pkeyField（表中的主键）、dbFile（存储表内容）</p></blockquote></li><li><p>表名与表id的映射（方便通过tableName获取table）：<code>ConcurrentHashMap&lt;String, Integer&gt; tableNameMap;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public Catalog()</code></p></li><li><p>向Catalog中添加表：<code>public void addTable(DbFile file, String name, String pkeyField)</code></p></li><li><p>根据表明获取表id：<code>public int getTableId(String name)</code></p></li><li><p>&#x20;通过表id获取表TupleDesc：<code>public TupleDesc getTupleDesc(int tableId)</code></p></li><li><p>通过表id获取表的内容dbFile：<code>public DbFile getDatabaseFile(int tableId)</code></p></li><li><p>通过表id获取表的主键：<code>public String getPrimaryKey(int tableId)</code></p></li><li><p>返回tableId的迭代器：<code>public Iterator&lt;Integer&gt; tableIdIterator()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">tableIdIterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> tableIdMap.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过表id获取表名：<code>public String getTableName(int id)</code></p></li><li><p>清空Catalog：<code>public void clear()</code></p></li></ul><p><img src="image-14.png"></p><h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h2><blockquote><p>实现BufferPool的构造器和getPage()方法</p></blockquote><h3 id="BufferPool类"><a href="#BufferPool类" class="headerlink" title="BufferPool类"></a>BufferPool类</h3><p><strong>参数：</strong></p><ul><li><p>默认page大小：<code>private static final int </code><em><code>DEFAULT_PAGE_SIZE </code></em><code>= 4096;</code> <code>private static int </code><em><code>pageSize </code></em><code>= </code><em><code>DEFAULT_PAGE_SIZE</code></em><code>;</code></p></li><li><p>BufferPool能获取的page数量：<code>private final int numPages;</code></p></li><li><p>pageId到page的映射：<code>private final Map&lt;PageId, Page&gt; bufferPools = new ConcurrentHashMap&lt;&gt;();</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public BufferPool(int numPages)</code></p></li><li><p>从BufferPool中根据pageId获取对应的page，如果BufferPool中不存在就去磁盘搜索并保存到BufferPool：<code>public Page getPage(TransactionId tid, PageId pid, Permissions perm)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Page <span class="title function_">getPage</span><span class="params">(TransactionId tid, PageId pid, Permissions perm)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span>(!bufferPools.containsKey(pid)) &#123;</span><br><span class="line">        <span class="type">DbFile</span> <span class="variable">file</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(pid.getTableId());</span><br><span class="line">        <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> file.readPage(pid);</span><br><span class="line">        bufferPools.put(pid, page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bufferPools.get(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取page的方法有且只有<code>BufferPool.getPage()</code>。</p><p>通过一个具体的索引页id就可以找到一张特定的数据表，所以我们可以认为：“<strong>在一个数据页上只能存储同一张表的数据”</strong>。</p><p><img src="image-9.png" alt="copilot解答"></p><ol><li>数据组织和查询效率</li></ol><ul><li><p><strong>连续存储</strong>：将同一张表的数据存储在连续的页面中，有助于提高查询效率。读取一个表的数据时，可以通过顺序扫描这些页面，减少磁盘寻道时间。</p></li><li><p><strong>索引效率</strong>：索引通常是基于表的。当页面只存储一张表的数据时，索引查找可以更快地定位数据。</p></li></ul><ul><li>数据一致性和隔离</li></ul><ul><li><p><strong>事务管理</strong>：事务的隔离级别要求对表的操作是可预测和隔离的。将不同表的数据混合在同一个页面中，可能会导致复杂的锁管理和数据一致性问题。</p></li><li><p><strong>日志记录和恢复</strong>：数据库的日志记录机制（如WAL日志）通常基于表进行管理。将不同表的数据混合在一个页面中，恢复过程会变得更加复杂。</p></li></ul><ul><li>空间管理和回收</li></ul><ul><li><p><strong>空间利用</strong>：将同一张表的数据放在同一页面中，可以更有效地利用空间。当需要扩展表时，只需分配新的页面，不需要考虑不同表的数据混合导致的空间浪费问题。</p></li><li><p><strong>垃圾回收</strong>：当删除数据时，页面中的空闲空间可以更容易地被同一表的新数据使用。如果不同表的数据混合在一起，空间回收和再利用会更加困难。</p></li></ul><ul><li>设计和实现的简化</li></ul><ul><li><p><strong>代码复杂度</strong>：将每个页面绑定到一个特定的表，可以简化数据库管理系统的实现。比如，代码中的 <code>Database.getCatalog().getDatabaseFile(pid.getTableId())</code> 就是通过表ID来获取相关的数据库文件（包含多个页面）的。</p></li><li><p><strong>模块化设计</strong>：这种设计方式使得数据库系统的模块化和维护变得更简单。每个模块（如页面管理、缓冲区管理、事务管理）可以专注于处理单一表的数据。</p><p>&#x20;                                                                                                                                —— chatGPT解答</p></li></ul></blockquote></li></ul><h2 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h2><blockquote><p>实现HeapPageId类、RecordId类、HeapPage类</p></blockquote><p><img src="image-13.png"></p><h3 id="HeapPageId类"><a href="#HeapPageId类" class="headerlink" title="HeapPageId类"></a>HeapPageId类</h3><p><strong>参数：</strong></p><ul><li><p>page所在的数据表id：<code>private int tableId;</code></p></li><li><p>page的序号：<code>private int pgNo;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public HeapPageId(int tableId, int pgNo)</code></p></li><li><p>返回该page所在的数据表id：<code>public int getTableId() </code></p></li><li><p>返回该page的序号：<code>public int getPageNumber()</code></p></li><li><p>返回该pageId的哈希值：<code>public int hashCode()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> getPageNumber() * <span class="number">1000</span> + getTableId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断两个PageId对应的page是否相等：<code>public boolean equals(Object o)</code></p><p>相等条件：两个PageId的pageNo和tableId相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> HeapPageId) &#123;</span><br><span class="line">        <span class="type">HeapPageId</span> <span class="variable">other</span> <span class="operator">=</span> (HeapPageId) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPageNumber() == other.getPageNumber() &amp;&amp; <span class="built_in">this</span>.getTableId() == other.getTableId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RecordId类"><a href="#RecordId类" class="headerlink" title="RecordId类"></a>RecordId类</h3><p><strong>参数：</strong></p><ul><li><p>元组id所在页的pageId：<code>private PageId pid;</code></p></li><li><p>元组的序号：<code>private int tupleNo;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public RecordId(PageId pid, int tupleno)</code></p></li><li><p>返回元组的序号：<code>public int getTupleNumber()</code></p></li><li><p>返回元组所在页的pageId：<code>public PageId getPageId()</code></p></li><li><p>判断两个tuple是否相同：<code>public boolean equals(Object o)</code></p></li><li><p>返回 tuple的哈希值：<code>public int hashCode()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.pid.getPageNumber() * <span class="number">100</span> + <span class="built_in">this</span>.pid.getTableId() * <span class="number">10</span> + <span class="built_in">this</span>.tupleNo; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HeapPage类"><a href="#HeapPage类" class="headerlink" title="HeapPage类"></a>HeapPage类</h3><p><strong>参数：</strong></p><ul><li><p>pageId：<code>private final HeapPageId pid;</code></p></li><li><p>page所对应表格的tupleDesc：<code>private final TupleDesc td;</code></p></li><li><p>page中槽slot的bitmap，判断该页的slot是否被占用：<code>final byte[] header;</code></p></li><li><p>page中的元组：<code>final Tuple[] tuples;</code></p></li><li><p>page中slot的数量：<code>private final int numSlots;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public HeapPage(HeapPageId id, byte[] data)</code></p></li><li><p>返回每个page中包含的tuple数量：<code>private int getNumTuples()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNumTuples</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">page_bits</span> <span class="operator">=</span> BufferPool.getPageSize() * <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tuple_bits</span> <span class="operator">=</span> (td.getSize() * <span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> page_bits / tuple_bits;  <span class="comment">// 进行下取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>数据库中每个page的tuple需要 tuple size*8 bit 的内容大小和 1bit 的header大小。&#x20;</p><ul><li><p>返回page中的header大小：<code>private int getHeaderSize()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeaderSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) Math.ceil((<span class="type">double</span>) getNumTuples() / <span class="number">8</span>);  <span class="comment">// 进行上取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回pageId：<code>public HeapPageId getId()</code></p></li><li><p>判断第i个slot槽是否为空：<code>public boolean isSlotUsed(int i)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSlotUsed</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="comment">// 计算在header中的位置(哪一个字节)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">iTh</span> <span class="operator">=</span> i / <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 计算具体在bitmap中的位置(哪一个比特位，或者理解为header字节位中的比特偏移量)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bitTh</span> <span class="operator">=</span> i % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">onBit</span> <span class="operator">=</span> (header[iTh] &gt;&gt; bitTh) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> onBit == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>header的存储方式是byte数组，每个byte包含8个bit，例如某header的状态如下：{<code>11111111</code>, <code>11111111</code>, <code>00000011</code>}（byte的右侧为低位），此时先通过<code>iTh=i/8</code>变量确定槽i在哪一个byte中，再通过<code>bitTh=i%8</code>确定槽i在byte字节中具体是哪一个bit，最后通过 &amp; 异或确定该bit是0或1。</p><ul><li>返回page中空slot的数量：<code>public int getNumUnusedSlots()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumUnusedSlots</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numSlots; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSlotUsed(i)) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回page中所有tuple的迭代器（不包括空slot）：<code>public Iterator&lt;Tuple&gt; iterator()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;Tuple&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    List&lt;Tuple&gt; tupleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numSlots; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSlotUsed(i)) &#123;</span><br><span class="line">            tupleList.add(tuples[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tupleList.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeapPage中的tuple是通过数组存储的，为了访问迭代器方法需要将tuple数组转换成tuple集合。</p><h2 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h2><blockquote><p>实现HeapFile类</p></blockquote><p><img src="image-12.png"></p><h3 id="HeapFile类"><a href="#HeapFile类" class="headerlink" title="HeapFile类"></a>HeapFile类</h3><p>一个HeapFile就是一张数据表。</p><p><img src="image-8.png"></p><p><strong>参数：</strong></p><ul><li><p>表中的内容：<code>private final File f;</code></p></li><li><p>表的属性行：<code>private final TupleDesc td;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public HeapFile(File f, TupleDesc td)</code></p></li><li><p>返回表的内容：<code>public File getFile()</code></p></li><li><p>返回标识表文件的唯一id (heapfile绝对路径的哈希值)：<code>public int getId()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> f.getAbsolutePath().hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回表的属性行：<code>public TupleDesc getTupleDesc()</code></p></li><li><p>返回表的page数目：<code>public int numPages()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numPages</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">file_length</span> <span class="operator">=</span> getFile().length();  <span class="comment">// 文件长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> BufferPool.getPageSize();  <span class="comment">// 每个页面的大小</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (file_length / pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从表文件中读取page：<code>public Page readPage(PageId pid)</code></p><blockquote><p><code>readPage()</code>方法仅会被BufferPool中的<code>getPage()</code>方法调用，再其他地方获取page时也都要调用BufferPool的<code>getPage()</code>方法，这也是BufferPool的意义。</p></blockquote><p>利用 RandomAccessFile 来读写 HeapFile 中的Page：</p><p><code>RandomAccessFile</code> 是 Java 中用于对文件进行读写操作的类，其支持随机访问文件内容的特性。这里的随机 <code>seek()</code> 方法指的是可以通过指定文件中的任意位置（偏移量）来读取或写入数据，而不是像顺序读写那样只能按照文件中数据的顺序逐个访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Page <span class="title function_">readPage</span><span class="params">(PageId pid)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tableId</span> <span class="operator">=</span> pid.getTableId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgNo</span> <span class="operator">=</span> pid.getPageNumber();</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> pgNo * BufferPool.getPageSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// randomaccessfile try-catch-finally</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        randomAccessFile = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="comment">// 保证pid页面的结束位置不大于文件randomFile的长度</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) pgNo * BufferPool.getPageSize() &gt; randomAccessFile.length()) &#123;</span><br><span class="line">            randomAccessFile.close();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;table %d page %d is invalid&quot;</span>, tableId, pgNo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[BufferPool.getPageSize()];</span><br><span class="line">        <span class="comment">// 移动偏移量到页面的开头</span></span><br><span class="line">        randomAccessFile.seek(offset);</span><br><span class="line">        <span class="comment">// 不要在调用时将整个表加载到内存中，这将导致非常大的表出现内存不足错误</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> randomAccessFile.read(bytes, <span class="number">0</span>, BufferPool.getPageSize());</span><br><span class="line">        <span class="keyword">if</span> (read != BufferPool.getPageSize()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;table %d page %d read %d bytes not equal to BufferPool.getPageSize()&quot;</span>,</span><br><span class="line">                    tableId, pgNo, read));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeapPageId</span> <span class="variable">heapPageId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(pid.getTableId(), pid.getPageNumber());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapPage</span>(heapPageId, bytes);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (randomAccessFile != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                randomAccessFile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;table %d page %d is invalid&quot;</span>, tableId, pgNo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回表文件中所有heapPage中元组的迭代器：<code>public DbFileIterator iterator(TransactionId tid)</code></p><p><img src="image-16.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DbFileIterator <span class="title function_">iterator</span><span class="params">(TransactionId tid)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapFileIterator</span>(tid, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapFileIterator</span> <span class="keyword">implements</span> <span class="title class_">DbFileIterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionId tid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HeapFile heapFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元组迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Tuple&gt; tupleIterator;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页面索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeapFileIterator</span><span class="params">(TransactionId tid, HeapFile heapFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tid = tid;</span><br><span class="line">        <span class="built_in">this</span>.heapFile = heapFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        tupleIterator = getTupleIterator(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Tuple&gt; <span class="title function_">getTupleIterator</span><span class="params">(<span class="type">int</span> pageNumber)</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">        <span class="keyword">if</span> (pageNumber &gt;= <span class="number">0</span> &amp;&amp; pageNumber &lt; heapFile.numPages()) &#123;</span><br><span class="line">            <span class="type">HeapPageId</span> <span class="variable">heapPageId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(heapFile.getId(), pageNumber);</span><br><span class="line">            <span class="type">HeapPage</span> <span class="variable">heapPage</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid, heapPageId, Permissions.READ_ONLY);</span><br><span class="line">            <span class="keyword">return</span> heapPage.iterator();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(String.format(<span class="string">&quot;heapFile %d does not exist in page %d&quot;</span>, heapFile.getId(), pageNumber));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tupleIterator == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!tupleIterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前页面没有元组，则切换到下一个页面</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; heapFile.numPages()) &#123;</span><br><span class="line">                tupleIterator = getTupleIterator(index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前页面还有元组，则返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException, NoSuchElementException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tupleIterator == <span class="literal">null</span> || !tupleIterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tupleIterator.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        close();</span><br><span class="line">        open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        tupleIterator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-7.png"></p><h2 id="Exercise6"><a href="#Exercise6" class="headerlink" title="Exercise6"></a>Exercise6</h2><blockquote><p>实现SeqScan类：该类应该能通过构造方法传入的tableId参数扫描数据表中的所有元组，并使用<code>dbFile.iterator()</code>访问元组</p></blockquote><h3 id="SeqScan类"><a href="#SeqScan类" class="headerlink" title="SeqScan类"></a>SeqScan类</h3><p><strong>参数：</strong></p><ul><li><p>事务id：<code>private TransactionId tid;</code></p></li><li><p>需要扫描的数据表id：<code>private int tableid;</code></p></li><li><p>表的别名（返回TupleDesc时，要在fieldName前加上tableAlias字段）：<code>private String tableAlias;</code></p></li><li><p>扫描数据表要访问的dbFile迭代器：<code>private DbFileIterator dbFileIterator;</code></p></li></ul><p><strong>方法：</strong></p><ul><li><p>构造方法：<code>public SeqScan(TransactionId tid, int tableid, String tableAlias)</code></p></li><li><p>获取表名：<code>public String getTableName()</code></p></li><li><p>获取表的alias别名：<code>public String getAlias()</code></p></li><li><p>查找新的表（重新对tableId赋值）：<code>public void reset(int tableid, String tableAlias)</code></p></li><li><p>返回数据表的tupleDesc，需要在fieldName之前添加alias别名：<code>public TupleDesc getTupleDesc()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="type">TupleDesc</span> <span class="variable">td_old</span> <span class="operator">=</span> Database.getCatalog().getTupleDesc(tableid);</span><br><span class="line">    String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[td_old.numFields()];</span><br><span class="line">    Type[] types = <span class="keyword">new</span> <span class="title class_">Type</span>[td_old.numFields()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; td_old.numFields(); i++) &#123;</span><br><span class="line">        names[i] = tableAlias + <span class="string">&quot;.&quot;</span> + td_old.getFieldName(i);</span><br><span class="line">        types[i] = td_old.getFieldType(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(types, names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历表用到的方法</p><ul><li><p>打开迭代器：<code>public void open()</code></p></li><li><p>如果有更多元组可用，则为True，如果没有元组或未打开迭代器则为False：<code>public boolean hasNext()</code></p></li><li><p>根据迭代器获取下一个元组：<code>public Tuple next()</code></p></li><li><p>关闭迭代器（置空）：<code>public void close()</code></p></li><li><p>将迭代器重置为起始位置（关闭、开启）：<code>public void rewind()</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    dbFileIterator = Database.getCatalog().getDatabaseFile(tableid).iterator(tid);</span><br><span class="line">    dbFileIterator.open();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (dbFileIterator == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;The dbFileIterator is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dbFileIterator.hasNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Tuple <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException,</span><br><span class="line">        TransactionAbortedException, DbException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (dbFileIterator == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;The dbFileIterator is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">t</span> <span class="operator">=</span> dbFileIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No more tuples&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    dbFileIterator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, NoSuchElementException,</span><br><span class="line">        TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    close();</span><br><span class="line">    open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-6.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p>Test：<code>select * from some_data_file</code></p></blockquote><p>在项目根目录下创建some_data_file.txt文件：</p><p><img src="image-3.png"></p><p>用 ant 编译出dist目录下simpleDB的jar包：</p><p><img src="image-5.png"></p><p>运行测试，展示结果：</p><p><img src="image-2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间学习一下 MySQL，正好准备一个手撕轮子项目，就准备完成这个 MIT6.5830 的数据库课程。Lab1 主要是完成一些简单的数据库定义以及实现简单的全表扫描。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://kicheng.github.io/categories/MySQL/"/>
    
    
    <category term="database" scheme="https://kicheng.github.io/tags/database/"/>
    
    <category term="mysql" scheme="https://kicheng.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="https://kicheng.github.io/2023/07/17/Java%E9%9B%86%E5%90%88/"/>
    <id>https://kicheng.github.io/2023/07/17/Java%E9%9B%86%E5%90%88/</id>
    <published>2023-07-17T13:55:33.000Z</published>
    <updated>2023-07-18T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>复习一下Java的集合：分为单列集合和双列集合，单列集合有List和Set两类，双列集合是Map集合。<code>List</code>接口的实现类有ArrayList, LinkedList；Set和Map可以配合着学，主要有HashSet–HashMap, LinkedHashSet–LinkedHashMap, TreeSet–TreeMap三组。</p><span id="more"></span><img src="image-20230718120825421.png" alt="image-20230718120825421" style="zoom:67%;" /><h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><img src="image-20230718120851741.png" alt="image-20230718120851741" style="zoom:67%;" /><p>总结一下Collection单列集合的常用功能有哪些，<code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code>集合都可以调用下面的方法：</p><img src="image-20230718121036160.png" alt="image-20230718121036160" style="zoom:77%;" /><p><strong>Collection集合的遍历方式：</strong></p><ul><li><p>迭代器遍历集合</p><ul><li>当调用<code>iterator()</code>方法获取迭代器时，当前指向第一个元素；</li><li><code>hasNext()</code>方法则判断这个位置是否有元素，如果有则返回<code>true</code>，进入循环；</li><li>调用<code>next()</code>方法获取元素，并将当月元素指向下一个位置；</li><li>等下次循环时，则获取下一个元素，依此类推。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强for遍历集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String context: list)&#123;</span><br><span class="line">    System.out.println(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code>遍历集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*  ======Lambda表达式简化=======  */</span></span><br><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure></li></ul><p><strong>当往集合中存对象时，实际上存储的是对象的地址值：</strong></p><p><img src="image-20230718122238215.png" alt="image-20230718122238215"></p><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><img src="image-20230718122400682.png" alt="image-20230718122400682" style="zoom:77%;" /><p><strong>List集合的常用方法：</strong></p><img src="image-20230718122435550.png" alt="image-20230718122435550" style="zoom:67%;" /><p>因为List集合有索引，所以可以通过普通for循环的方式遍历List集合。</p><h3 id="Arraylist集合"><a href="#Arraylist集合" class="headerlink" title="Arraylist集合"></a>Arraylist集合</h3><p><code>ArrayList</code>集合底层是基于数组结构实现的，也就是说当你往集合容器中存储元素时，底层本质上是往数组中存储元素。 特点如下：</p><img src="image-20230718122710834.png" alt="image-20230718122710834" style="zoom:77%;" /><p>我们知道数组的长度是固定的，但是集合的长度是可变的，这是怎么做到的呢？</p><img src="image-20230718122825047.png" alt="image-20230718122825047" style="zoom:77%;" /><p>数组扩容，并不是在原数组上扩容（原数组是不可以扩容的），底层是创建一个新数组，然后把原数组中的元素全部复制到新数组中去。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList底层是<strong>双向链表</strong>结构。</p><p><img src="image-20230718123113316.png" alt="image-20230718123113316"></p><p>所以相对于<code>ArrayList</code>新增了一些可以针对头尾进行操作的方法，如下图示所示：</p><img src="image-20230718123129380.png" alt="image-20230718123129380" style="zoom:77%;" /><p><strong>由于双向链表的结构，可以用它来设计栈、队列：</strong></p><img src="image-20230718123341697.png" alt="image-20230718123341697" style="zoom:50%;" /><img src="image-20230718123356578.png" alt="image-20230718123356578" style="zoom:50%;" /><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><img src="image-20230717220114816.png" alt="image-20230717220114816" style="zoom:77%;" /><h3 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h3><img src="image-20230717221646999.png" alt="image-20230717221646999" style="zoom: 72%;" /><img src="image-20230717221809732.png" alt="image-20230717221809732" style="zoom:72%;" /><p><strong>HashSet去重原理</strong></p><p>前面我们学习了HashSet存储元素的原理，依赖于两个方法：一个是<code>hashCode</code>方法用来确定在底层数组中存储的位置，另一个是用<code>equals</code>方法判断新添加的元素是否和集合中已有的元素相同。</p><p>要想保证在HashSet集合中没有重复元素，我们需要重写对象类的<code>hashCode</code>和<code>equals</code>方法。比如以下面的<code>User</code>类为例，假设把<code>User</code>类的对象作为HashSet集合的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;User&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ljc&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ljc&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">hs.add(u1);</span><br><span class="line">hs.add(u2);</span><br><span class="line">System.out.println(hs);  <span class="comment">// [User&#123;username = ljc, password = 123&#125;, User&#123;username = ljc, password = 123&#125;]</span></span><br></pre></td></tr></table></figure><p>我们发现结果和我们想象的不一样，HashSet不是可以去重吗？实际上，通常两个不同对象的HashCode值是不同的，导致元素挂在了不同的数组位置上。要解决这个问题要重写对象类的<code>hashCode</code>和<code>equals</code>方法——直接generate自动生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(username, user.username) &amp;&amp; Objects.equals(password, user.password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h3><p><code>LinkedHashSet</code>类是<code>HashSet</code>的子类。<code>LinkedHashSet</code>它底层采用的是也是哈希表结构，只不过额外新增了一个<strong>双向链表</strong>来维护元素的存取顺序。</p><p>特点：相比<code>HashSet</code>，它记录了元素存入的顺序。</p><img src="image-20230717225009568.png" alt="image-20230717225009568" style="zoom:67%;" /><h3 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h3><p>TreeSet集合的特点是可以对元素进行排序（底层是<strong>红黑树</strong>实现的），但是<strong>必须指定元素的排序规则</strong>。如果往集合中存储String类型的元素，或者Integer类型的元素，它们本身就具备排序规则，所以直接就可以排序。如果往TreeSet集合中存储自定义类型的元素，比如说<code>User</code>类型，则需要我们自己指定排序规则，否则会出现异常，原因是TreeSet不知道按照什么条件对自定义对象来排序：</p><p><img src="image-20230717225542069.png" alt="image-20230717225542069"></p><p>我们想要告诉TreeSet集合按照指定的规则排序，有两种办法：</p><p>第一种：在创建TreeSet集合时，通过构造方法传递<code>Compartor</code>比较器对象；</p><p>第二种：让元素的类实现<code>Comparable</code>接口，重写<code>compareTo</code>方法；</p><ul><li><p>第一种：创建集合时传递比较器对象</p><p><code>o1-o2</code>是升序排序，<code>o2-o1</code>是降序排序。</p><blockquote><p>Double类型用<code>Double.compare(d1, d2)</code>比较，String类型用<code>s1.compareTo(s2)</code>方法比较。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;User&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User o1, User o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getUsername().compareTo(o2.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>第二种：实体类实现<code>Comparable</code>接口，重写<code>compareTo</code>方法</p><p><code>this</code>：表示将要添加进去的Student对象；<code>o</code>: 表示集合中已有的Student对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"> <span class="comment">/* ...... */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username.compareTo(o.username);  <span class="comment">// 升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>自然排序<code>Comparable</code>是类在创建的时候就规定了类的比较的特性，而比较器<code>Comparator</code>是在具体的应用过程中我们根据需求创建一个工具类来完成比较，相比之下比较器的使用更加灵活（有的时候需要对同一对象进行多种不同方式的排序；或者按照特定的需求比较字符串但无法重写<code>String</code>类中的<code>compareTo</code>方法），不会改变这个类本身，降低了耦合度。</p><h3 id="Collection集合总结"><a href="#Collection集合总结" class="headerlink" title="Collection集合总结"></a>Collection集合总结</h3><img src="image-20230718101153256.png" alt="image-20230718101153256" style="zoom:67%;" /><h3 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h3><p><font color="red">在使用迭代器遍历集合时，可能存在并发修改异常：</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  list.add(<span class="string">&quot;王麻子&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;小李子&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;李爱花&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;张全蛋&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;晓李&quot;</span>);</span><br><span class="line">  list.add(<span class="string">&quot;李玉刚&quot;</span>);</span><br><span class="line">  System.out.println(list); <span class="comment">// [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除</span></span><br><span class="line">  Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">      <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">          list.remove(name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(list);</span><br></pre></td></tr></table></figure><p><img src="image-20230718101929828.png" alt="image-20230718101929828"></p><p>这是因为迭代器遍历机制，规定<strong>迭代器遍历集合的同时，不允许集合自己去增删元素</strong>。</p><p>增强for循环遍历方式，是在内部调用迭代器进行遍历，所以也会出现并发修改异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String name: list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        list.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>简单for循环遍历方式，不会出发迭代器的并发修改异常，但会造成结果出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        list.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);  <span class="comment">// [王麻子, 李爱花, 张全蛋, 李玉刚]</span></span><br></pre></td></tr></table></figure><p><code>[王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</code>，以上述list集合为例，当<code>i=1</code>时<code>remove</code>了“小李子”元素，这时候<code>i=1</code>的元素变成了“李爱花”，而循环执行了<code>i++</code>，该元素就被跳过去了。解决方案是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">            list.remove(name);</span><br><span class="line">            i--;  <span class="comment">// 因为普通for循环没有异常出现，所以在逻辑上将每次remove元素后的索引i--即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而迭代器遍历解决并发修改异常的方法是，使用迭代器的修改元素方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        it.remove();  <span class="comment">// 当前迭代器指向谁，就删除谁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p><strong>可变参数</strong></p><ul><li><p>可变参数是一种特殊的形式参数，定义在方法、构造器的形参列表处，它可以让方法接收多个同类型的实际参数。</p></li><li><p>可变参数在方法内部，<strong>本质上是一个数组</strong>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    test(<span class="number">1</span>);</span><br><span class="line">    test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>...nums)</span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个形参列表中，只能有一个可变参数；否则会报错。</li><li>形参列表中如果多个参数，可变参数需要写在最后；否则会报错。</li></ul><p><strong>Collections工具类</strong></p><p><img src="image-20230718105406211.png" alt="image-20230718105406211"></p><p>往集合中存储的元素要么是Stirng类型，要么是Integer类型，他们本来就有一种自然顺序所以可以直接排序。但是如果我们往List集合中存储实体类对象，这个时候想要对List集合进行排序自定义比较规则的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User o1, User o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getPassword().compareTo(o2.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>双列集合，就是说集合中的元素是一对一对的。Map集合中的每一个元素是以<code>key=value</code>的形式存在的，一个<code>key=value</code>就称之为一个键值对，而且在 Java 中有一个类叫<code>Entry</code>类，Entry的对象用来表示键值对对象。</p><p>Map集合有如下的特点：<strong>键不能重复，值可以重复，每一个键只能找到自己对应的值。</strong></p><img src="image-20230718111534965.png" alt="image-20230718111534965" style="zoom:77%;" /><h3 id="Map集合常用方法"><a href="#Map集合常用方法" class="headerlink" title="Map集合常用方法"></a>Map集合常用方法</h3><img src="image-20230718112151598.png" alt="image-20230718112151598" style="zoom:87%;" /><h3 id="Map集合遍历方法"><a href="#Map集合遍历方法" class="headerlink" title="Map集合遍历方法"></a>Map集合遍历方法</h3><ul><li><p>方式一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">162.5</span>);</span><br><span class="line">map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.8</span>);</span><br><span class="line">map.put(<span class="string">&quot;紫霞&quot;</span>, <span class="number">165.8</span>);</span><br><span class="line">map.put(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">169.5</span>);</span><br><span class="line">map.put(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">183.6</span>);</span><br><span class="line">  </span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key: keys)&#123;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot;---&gt;&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><p>Map集合是用来存储键值对的，而每一个键值对实际上是一个<code>Entry</code>对象。可以直接获取每一个<code>Entry</code>对象，把<code>Entry</code>存储扫Set集合中去，再通过<code>Entry</code>对象获取键和值。</p><p><img src="image-20230718112943729.png" alt="image-20230718112943729"></p><p>Map集合提供<code>entrySet</code>方法，把Map集合转换成键值对类型的Set集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry: entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;---&gt;&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式三</p><p><img src="image-20230718113224411.png" alt="image-20230718113224411"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String k, Double v)</span> &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;---&gt;&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><code>HashMap</code>集合的特点是由键决定的： <strong>它的键是无序、不能重复，而且没有索引的</strong>。在各种Map集合中也是用得最多的一种集合。</p><p><code>HashMap</code>底层原理和<code>HashSet</code>是一样的。因为我们往<code>HashSet</code>集合中添加元素时，实际上是把元素作为<code>key</code>添加到了<code>HashMap</code>集合中。</p><p><img src="image-20230718114026273.png" alt="image-20230718114026273"></p><p><code>HashMap</code>和<code>HashSet</code>是一样的，底层是哈希表结构，哈希表是一种增删改查性能相对都较好的数据结构。</p><img src="image-20230718114458631.png" alt="image-20230718114458631" style="zoom:77%;" /><ul><li><p>往HashMap集合中键值对数据时，底层步骤如下：</p><ul><li>第1步：当你第一次往<code>HashMap</code>集合中存储键值对时，底层会创建一个<strong>长度为16的数组</strong>；</li><li>第2步：把键然后将键和值封装成一个对象，叫做<code>Entry</code>对象；</li><li>第3步：再根据<code>Entry</code>对象的键计算<code>hashCode</code>值（和值无关）；</li><li>第4步：利用<code>hashCode</code>值和数组的长度做一个类似求余数的算法，会得到一个索引位置；</li><li>第5步：判断这个索引的位置是否为<code>null</code>：如果为<code>null</code>，就直接将这个<code>Entry</code>对象存储到这个索引位置；如果不为<code>null</code>，则还需要进行第6步的判断；</li><li>第6步：继续调用equals方法判断两个对象键是否相同：如果<code>equals</code>返回<code>false</code>，则以链表的形式往下挂；如果<code>equals</code>方法<code>true</code>，则认为键重复，此时新的键值对会替换就的键值对。</li></ul></li><li><p>HashMap底层需要注意这几点：</p><ul><li>底层数组默认长度为16，如果数组中有超过12个位置已经存储了元素，则会对数组进行扩容<strong>2倍</strong>。数组扩容的加载因子是 0.75 ，意思是：<code>16*0.75=12</code>； </li><li>数组的同一个索引位置有多个元素、并且在8个元素以内（包括8），则以链表的形式存储（JDK8以后版本链表采用尾插法）。</li><li>数组的同一个索引位置有多个元素、并且超过了8个，则以红黑树形式存储。       </li></ul></li><li><p>决定键是否重复与两个方法有关，一个是<code>hashCode</code>方法、一个是<code>equals</code>方法。有两个键计算得到的<code>hashCode</code>值相同，并且两个键使用<code>equals</code>比较为<code>true</code>，就认为键重复。所以，往Map集合中存储自定义对象作为键，为了保证键的唯一性，我们应该重写这两个方法。</p></li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><code>LinkedHashMap</code>集合的特点也是由键决定的：<strong>有序的、不重复、无索引</strong>。<font color="blue">这里的“有序”是只存入的顺序。</font><code>LinkedHashMap</code>的底层原理，和<code>LinkedHashSet</code>底层原理是一样的，底层多个一个双向链表来维护键的存储顺序。</p><img src="image-20230718115713991.png" alt="image-20230718115713991" style="zoom:77%;" /><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><code>TreeMap</code>集合的特点也是由键决定的，默认按照键的升序排列，键不重复，也是无索引的。<code>TreeMap</code>集合的底层原理和<code>TreeSet</code>也是一样的，底层都是<strong>红黑树</strong>实现的，所以可以对键进行排序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习一下Java的集合：分为单列集合和双列集合，单列集合有List和Set两类，双列集合是Map集合。&lt;code&gt;List&lt;/code&gt;接口的实现类有ArrayList, LinkedList；Set和Map可以配合着学，主要有HashSet–HashMap, LinkedHashSet–LinkedHashMap, TreeSet–TreeMap三组。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://kicheng.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java的深浅拷贝</title>
    <link href="https://kicheng.github.io/2023/07/14/Java%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://kicheng.github.io/2023/07/14/Java%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2023-07-14T14:33:27.000Z</published>
    <updated>2023-07-14T14:37:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在刷算法题的时候忘记了引用数据类型深浅拷贝的问题，正好借此机会来复习一下。</p><span id="more"></span><h2 id="拷贝的分类"><a href="#拷贝的分类" class="headerlink" title="拷贝的分类"></a>拷贝的分类</h2><ul><li><p>引用拷贝</p><p>没有创建新的内存空间，只是复制了一个引用变量指向了堆空间中相同的地址。</p></li><li><p>对象拷贝</p><p>创建对象的一个副本，创建了新的对象指向不同的地址空间。而深浅拷贝的区别在于<strong>对象里面的属性拷贝方式</strong>。</p><ul><li><p>浅拷贝</p><p>属性就是引用拷贝，指向同一地址。</p></li><li><p>深拷贝</p><p>属性也是对象拷贝，不是同一地址。</p></li></ul></li></ul><h2 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;riemann&quot;</span>, <span class="number">28</span>);</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">otherTeacher</span> <span class="operator">=</span> teacher;  <span class="comment">// 没有创建新的对象</span></span><br><span class="line">System.out.println(teacher);</span><br><span class="line">System.out.println(otherTeacher);</span><br></pre></td></tr></table></figure><img src="image-20230714215404681.png" alt="image-20230714215404681" style="zoom: 45%;" /><p>它们的地址值是相同的，<code>teacher</code>和<code>otherTeacher</code>只是引用而已，他们都指向了一个相同的对象<code>Teacher(“riemann”,28)</code>。</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;riemann&quot;</span>, <span class="number">28</span>);</span><br><span class="line">  <span class="type">Teacher</span> <span class="variable">otherTeacher</span> <span class="operator">=</span> (Teacher) teacher.clone();</span><br><span class="line">  System.out.println(teacher);</span><br><span class="line">  System.out.println(otherTeacher);</span><br></pre></td></tr></table></figure><img src="image-20230714215759090.png" alt="image-20230714215759090" style="zoom:45%;" /><p>它们的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量，这就叫做对象拷贝。</p><p>由于<code>age</code>是基本数据类型， 那么对它的拷贝没有什么疑议，直接将一个4字节的整数值拷贝过来就行。但是<code>name</code>是String类型的， 它只是一个引用， 指向一个真正的String对象，那么对它的拷贝有两种方式将对象拷贝分为了浅拷贝和深拷贝。</p><ul><li>直接将源对象中的<code>name</code>的引用值拷贝给新对象的<code>name</code>字段；</li><li>根据<code>原Person</code>对象中的<code>name</code>指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给<code>新拷贝的Person</code>对象的<code>name</code>字段。</li></ul><p>Student类和Teacher类的pojo结构是这样的：</p><p>​                                                                        <img src="image-20230714215314001.png" alt="image-20230714215314001"></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p><p><img src="image-20230714220049094.png" alt="image-20230714220049094"></p><p>无论是String对象还是pojo对象，它们都是引用数据类型：</p><img src="image-20230714220406867.png" alt="image-20230714220406867" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) student1.clone();</span><br></pre></td></tr></table></figure><blockquote><p>由于Object类本身没有实现<code>Cloneable</code>接口，所以要使用clone方法必须在pojo类上实现该接口。</p></blockquote><p>两个引用<code>student1</code>和<code>student2</code>指向不同的两个对象，但是两个引用<code>student1</code>和<code>student2</code>中的<code>teacher</code><strong>引用指向的是同一个对象</strong>，所以说明是<strong>浅拷贝</strong>。</p><p><code>Cloneable</code>接口中的<code>clone()</code>方法是浅拷贝的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</p><p><img src="image-20230714221034487.png" alt="image-20230714221034487"></p><p>无论是String对象还是pojo对象，它们都是引用数据类型：</p><img src="image-20230714221056367.png" alt="image-20230714221056367" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) student1.clone();</span><br></pre></td></tr></table></figure><p>两个引用<code>student1</code>和<code>student2</code>指向不同的两个对象，两个引用<code>student1</code>和<code>student2</code>中的两个<code>teacher</code>引用指向的是两个对象。对<code>student1</code>中的<code>teacher</code>属性的修改只能影响<code>student1</code>对象，所以说是<strong>深拷贝</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="comment">// 深拷贝时：</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">    student.setTeacher((Teacher)student.getTeacher().clone());</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>讲到对象的拷贝，突然想到字符串，字符串也是一种引用数据类型，这在初学中是容易被忽视掉的。</p><ul><li><p>String字符串的基本特性</p><ul><li>String声明为<code>final</code>的，不可被继承、不可变特性；</li><li>String实现了<code>Serializable</code>接口：表示字符串是支持序列化的；实现了<code>Comparable</code>接口：表示String可以比较大小；</li><li>String在jdk8及以前内部定义了<code>final char [] value</code>用于存储字符串数据，<code>jdk9</code>时改为<code>byte[]</code>；</li></ul></li><li><p>字符串连接池</p></li></ul><p>为了减少在jvm中创建的字符串的数量，虚拟机维护了一个字符串常量池。当创建String对象时，jvm会先检查字符串常量池，如果这个字符串的常量值已经存在在池中了，就直接返回池中对象的引用，如果不在池中，就会实例化一个字符串并放入池中。</p><h3 id="String不可变性"><a href="#String不可变性" class="headerlink" title="String不可变性"></a>String不可变性</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247487062&idx=2&sn=00ba05ef2f80488b1860d6d49e8b9557&chksm=eb538b60dc240276fc745eca8b7667364ea6ca86092d8f404b0bde5ec03dbcd81a4bc3a9454d#rd">Java 中的 String 真的是不可变的吗？</a></p><ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Python&quot;</span>;</span><br><span class="line">System.out.println(str); <span class="comment">// Python</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">System.out.println(str); <span class="comment">// Java</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="string">&quot;ABC&quot;</span>;  <span class="comment">// 相当于new String(&quot;ABC&quot;)，交给str2的引用</span></span><br><span class="line">System.out.println(str1 + <span class="string">&quot;----------&quot;</span> + str2);  <span class="comment">// str1=&quot;abc&quot;, str2=&quot;ABC&quot;</span></span><br></pre></td></tr></table></figure><ul><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;  <span class="comment">// 在底层是StringBuilder.toString而来的，相当于new String(s1+s2);</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>当调用String的<code>replace()</code>方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ul><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在刷算法题的时候忘记了引用数据类型深浅拷贝的问题，正好借此机会来复习一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://kicheng.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux入门</title>
    <link href="https://kicheng.github.io/2023/07/08/Linux%E5%85%A5%E9%97%A8/"/>
    <id>https://kicheng.github.io/2023/07/08/Linux%E5%85%A5%E9%97%A8/</id>
    <published>2023-07-08T08:55:37.000Z</published>
    <updated>2023-07-10T14:03:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux的常见命令和Linux中安装jdk、mysql等。</p><span id="more"></span><h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="文件目录操作命令"><a href="#文件目录操作命令" class="headerlink" title="文件目录操作命令"></a>文件目录操作命令</h3><ul><li><p><code>ls</code></p><ul><li><code>-a</code></li><li><code>-l</code></li></ul></li><li><p><code>cd</code></p><ul><li><code>~</code>：表示用户的home目录</li><li><code>.</code>：表示当前所在目录</li><li><code>..</code>：表示目前目录位置的上级目录</li></ul></li><li><p><code>cat</code></p><ul><li><code>-n</code>：显示行号</li></ul></li><li><p><code>more</code>：分页的形式显示文件内容</p><ul><li><code>回车键</code>：向下滚动一行</li><li><code>空格键</code>：向下滚动一屏</li><li><code>b</code>：返回上一屏</li><li><code>q或者Ctrl+C</code>：退出more</li></ul></li><li><p><code>tail</code>：查看文件末尾的内容</p><ul><li><code>-f</code>：动态读取文件末尾内容并显示，常用于日志文件的内容输出</li></ul></li><li><p><code>mkdir</code>：创建目录</p><ul><li><code>-p</code>：可以实现多级目录的同时创建（<code>mkdir 1/2/3</code>）</li></ul></li><li><p><code>rmdir</code>：删除空目录</p></li></ul><h3 id="拷贝移动命令"><a href="#拷贝移动命令" class="headerlink" title="拷贝移动命令"></a>拷贝移动命令</h3><ul><li><p><code>cp</code>：用来复制文件或目录（<code>cp [-r] source dest</code>）</p><ul><li><code>-r</code>：复制该目录下的所有子目录和文件</li></ul></li><li><p><code>mv</code>：为文件或目录改名，或移动到其他位置（<code>mv source dest</code>）</p></li></ul><h3 id="打包压缩命令"><a href="#打包压缩命令" class="headerlink" title="打包压缩命令"></a>打包压缩命令</h3><ul><li><p><code>tar</code>：对文件进行打包、解包、压缩、解压</p><blockquote><p>包文件后缀名<code>.tar</code>，表示只是完成了打包，并没有压缩；包文件后缀名<code>.tar.gz</code>表示打包的同时还进行了压缩。</p></blockquote><ul><li><code>-z</code>：代表是gzip，gzip可以对文件压缩或解压；</li><li><code>-c</code>：代表是create，创建新的包文件；</li><li><code>-x</code>：代表是extract，实现从包文件中还原文件；</li><li><code>-v</code>：代表是verbose，显示命令的执行操作；</li><li><code>-f</code>：代表是file，用于指定包文件的名称。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf fileName  # 打包tar文件</span><br><span class="line">tar -xvf fileName  # 解包tar文件</span><br><span class="line">tar -zcvf fileName  # 打包并压缩tar.gz文件</span><br><span class="line">tar -zxvf fileName  # 打包并解压tar.gz文件</span><br></pre></td></tr></table></figure><h3 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h3><ul><li><p><code>vi</code>/<code>vim</code></p><blockquote><p><code>vim</code>安装：<code>yum install yum</code></p></blockquote><ul><li>命令模式<ul><li><code>G</code></li><li><code>gg</code></li></ul></li><li>插入模式</li><li>底行模式：<ul><li><code>wq</code></li><li><code>q!</code></li><li><code>set nu</code>：显示行号</li></ul></li></ul></li></ul><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><ul><li><p><code>find</code>：在指定目录下查找文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find dirName -name fileName</span><br></pre></td></tr></table></figure></li><li><p><code>grep</code>：从指定文件查找指定文本内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep word fileName</span><br></pre></td></tr></table></figure></li></ul><h2 id="远程服务器上传下载"><a href="#远程服务器上传下载" class="headerlink" title="远程服务器上传下载"></a>远程服务器上传下载</h2><ul><li><p>本地向服务器上传</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /localpath/filename（本地目录文件） username@IP_Address:/remotepath（远程目录）</span><br><span class="line">scp -r /localpath（本地目录） username@IP_Address:/remotepath（远程目录）</span><br></pre></td></tr></table></figure></li><li><p>本地从服务器下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp username@IP_Address:/remotepath/filename（远程目录文件） /localpath（本地目录）</span><br><span class="line">scp -r username@IP_Address:/remotepath（远程目录） /localpath（本地目录）</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>远程服务器设置固定的ip地址：<a href="https://www.cnblogs.com/itbsl/p/10998696.html">https://www.cnblogs.com/itbsl/p/10998696.html</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux中安装jdk"><a href="#Linux中安装jdk" class="headerlink" title="Linux中安装jdk"></a>Linux中安装jdk</h3><p>建议安装jdk8，jdk17亲测在CentOS中和tomcat不兼容，tomcat安装时无法识别jdk17（我看网上的博主在23年还在linux中使用jdk8的版本，可能CentOS7真的和jdk17有一些兼容上的问题）。</p><p>下载jdk8地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>其中别忘记环境变量的配置：</p><ul><li><p>使用vim修改<code>/etc/profile</code>文件，在文件末尾加入配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_371</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>重新加载profile文件，使得配置立即生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ul><p>检查jdk是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h3 id="Linux中安装Tomcat"><a href="#Linux中安装Tomcat" class="headerlink" title="Linux中安装Tomcat"></a>Linux中安装Tomcat</h3><p>我使用的是Tomcat9版本。</p><p>在Tomcat的<code>/bin</code>目录下启动tomcat服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh 或者 ./startup.sh</span><br></pre></td></tr></table></figure><p>查看进程检查是否启动成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br></pre></td></tr></table></figure><p>通过客户机浏览器可以试着访问服务器的8080端口：</p><img src="image-20230710181303092.png" alt="image-20230710181303092" style="zoom:67%;" /><p>如果无法访问大概率是防火墙关闭了服务器的8080端口，尝试开放8080端口后尝试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent  # 开放指定端口</span><br><span class="line">firewall-cmd --zone=public --remove-port=8080/tcp --permanent  # 开放指定端口</span><br><span class="line">firewall-cmd --reload  # 立即生效配置</span><br><span class="line">filewall-cmd --zone=public --list-ports  # 查看开放的端口</span><br></pre></td></tr></table></figure><p>停止Tomcat服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法一</span></span><br><span class="line">./shutdown.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法二</span></span><br><span class="line">kill -9 进程id</span><br></pre></td></tr></table></figure><h3 id="Linux中安装MySQL"><a href="#Linux中安装MySQL" class="headerlink" title="Linux中安装MySQL"></a>Linux中安装MySQL</h3><p>CentOS7中自带的 Mariadb 和 MySQL 有冲突，先将其卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep mariadb</span><br><span class="line">sudo rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64  # mariadb-libs-5.5.68-1.el7.x86_64是上面命令显示的</span><br><span class="line">sudo rm /etc/my.cnf</span><br></pre></td></tr></table></figure><p>检查MySQL是否存在，如果存在也卸载重新安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>下载MySQL地址：<a href="https://downloads.mysql.com/archives/community/?spm=a2c6h.12873639.article-detail.5.51fa3861DJz2jH">https://downloads.mysql.com/archives/community/?spm=a2c6h.12873639.article-detail.5.51fa3861DJz2jH</a></p><p><img src="image-20230708173316683.png" alt="image-20230708173316683"></p><p>将<code>mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar</code>上传至服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /localpath/mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar username@IP_Address:/remotepath/mysql</span><br></pre></td></tr></table></figure><p>将tar解压到指定目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvf /home/ljc/mysql/mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar -C /usr/local/mysql</span><br></pre></td></tr></table></figure><p><img src="image-20230708174332889.png" alt="image-20230708174332889"></p><p>不考虑依赖关系的强制安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh *.rpm --nodeps --force</span><br></pre></td></tr></table></figure><p><img src="image-20230708175727311.png" alt="image-20230708175727311"></p><p>安装成功后，启动MySQL服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><p>进入MySQL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>MySQL的默认临时密码在安装时的日志文件中，复制过来登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p><img src="image-20230708175930124.png" alt="image-20230708175930124"></p><p>降低密码的校验等级和校验规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password.policy=0;</span><br><span class="line">set global validate_password.length=8;</span><br></pre></td></tr></table></figure><p>重新设置MySQL密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;password&#x27;;</span><br></pre></td></tr></table></figure><p><code>localhost</code>只能用户本机127.0.0.1访问，创建一个新<code>root</code>用户用于远程登录访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;12345678&#x27;;</span><br></pre></td></tr></table></figure><p>给新<code>root</code>用户分配权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>在NaviCat上远程连接服务器上的MySQL：</p><img src="image-20230708181224067.png" alt="image-20230708181224067" style="zoom:67%;" /><p>这里如果连接失败是CentOS防火墙没有开启3306端口，建议关闭防火墙。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure><p><img src="image-20230708181402460.png" alt="image-20230708181402460"></p><p>关闭防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure><p><img src="image-20230708181459858.png" alt="image-20230708181459858"></p><p>永久关闭防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux的常见命令和Linux中安装jdk、mysql等。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://kicheng.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>01-MySQL基础</title>
    <link href="https://kicheng.github.io/2023/07/07/01-MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>https://kicheng.github.io/2023/07/07/01-MySQL%E5%9F%BA%E7%A1%80/</id>
    <published>2023-07-07T09:48:37.000Z</published>
    <updated>2023-07-08T04:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql是一种关系型数据库，这篇博客作为数据库的基础篇主要讲解操作关系型数据的SQL编程语言。</p><span id="more"></span><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><img src="image-20230708120214301.png" alt="image-20230708120214301"></p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型是数据库中数据的存储方式，是数据库系统的基础。</p><img src="image-20230708120103005.png" alt="image-20230708120103005" style="zoom:77%;" /><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h3><ul><li><p>数据库操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="keyword">create</span> database 数据库名;</span><br><span class="line">use 数据库名;</span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line"><span class="keyword">drop</span> database 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>表操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (字段 字段类型, 字段 字段类型...);</span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="operator">/</span> modify <span class="operator">/</span> change <span class="operator">/</span> <span class="keyword">drop</span> <span class="operator">/</span> rename <span class="keyword">to</span> ...;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><p>创建数据表时要指定字段的数据类型，SQL的<strong>数据类型</strong>是很重要的知识点：</p><ul><li><p>数值类型</p><p><img src="image-20230708115522222.png" alt="image-20230708115522222"></p></li><li><p>字符串类型</p><p><img src="image-20230708115834511.png" alt="image-20230708115834511"></p><p><code>varchar</code>类型会先计算数据所占用的存储空间，所以性能相对<code>char</code>会差一些。<code>varchar</code>用来存储变长字符串，<code>char</code>用来存储定长字符串。</p></li><li><p>日期时间类型</p><p><img src="image-20230708120001012.png" alt="image-20230708120001012"></p></li></ul></li></ul><h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h3><ul><li><p>添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...)[, (值<span class="number">1</span>, 值<span class="number">2</span>, ...),...];</span><br></pre></td></tr></table></figure></li><li><p>修改数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 字段<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2.</span>.. [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure></li></ul><h3 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名列表 <span class="keyword">where</span> 条件列表 <span class="keyword">group</span> <span class="keyword">by</span> 分组字段列表 <span class="keyword">having</span> 分组后条件列表 <span class="keyword">order</span> <span class="keyword">by</span> 排序字段列表 limit 分页参数</span><br></pre></td></tr></table></figure><ul><li><p>基本查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> [<span class="keyword">as</span> 别名], 字段<span class="number">2</span> [<span class="keyword">as</span> 别名]... <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>条件查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-20230707182551496.png" alt="image-20230707182551496"></p><ul><li><p>聚合函数</p><p>将一列数据作为一个整体，进行纵向计算。</p><blockquote><p>null值不参与所有聚合函数运算。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数(字段列表) <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><img src="image-20230707182712652.png" alt="image-20230707182712652" style="zoom:87%;" /></li><li><p>分组查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组过滤后的条件];</span><br></pre></td></tr></table></figure><p>where 与 having 的区别：</p><p>① 执行时机不同：where 是分组之前进行过滤，不满足 where 条件是不参与 group by 分组的；而 having 是分组之后的条件对结果进行过滤；</p><p>② 判断条件不同：where 是不能对聚合函数进行判断，而 having 可以。</p><blockquote><p>执行顺序：where &gt; 聚合函数 &gt; having</p><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 </p></blockquote></li><li><p>排序查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span> ...;</span><br></pre></td></tr></table></figure><ul><li><code>ASC</code>：升序（默认值）</li><li><code>DESC</code>：降序</li></ul></li><li><p>分页查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 limit 起始索引, 查询记录数;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>起始索引从0开始，<code>起始索引 = (查询页码 - 1) * 每页显示记录数</code>；</p></li><li><p>分页查询是数据库的“方言”；</p></li><li><p>如果查询的是第一页的数据，起始索引可以省略，直接简写为<code>limit 10</code>。</p></li></ul></blockquote></li></ul><p><strong>DQL语句执行顺序</strong></p><p>可以通过起别名的方式验证sql的执行顺序。</p><img src="image-20230707184905294.png" alt="image-20230707184905294" style="zoom:87%;" /><h3 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL 数据控制语言"></a>DCL 数据控制语言</h3><p>用来管理数据库用户，控制数据库的访问权限等。这类 SQL 开发人员操作较少，主要是 DBA 数据库管理员使用。</p><ul><li><p>管理用户</p><ul><li><p>查询用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p> 创建用户</p></li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>修改用户密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>权限控制</p><img src="image-20230707190503318.png" alt="image-20230707190503318" style="zoom:87%;" /><ul><li><p>查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>撤销权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><img src="image-20230707212720328.png" alt="image-20230707212720328" style="zoom:77%;" /><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p><img src="image-20230707213014115.png" alt="image-20230707213014115"></p><p>练习：通过数据库内置函数，生成6位验证码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> lpad(round(rand()<span class="operator">*</span><span class="number">1000000</span>, <span class="number">0</span>), <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><img src="image-20230707213605363.png" alt="image-20230707213605363" style="zoom:87%;" /><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>在sql语句中实现条件筛选，提高语句的效率。</p><img src="image-20230707214051312.png" alt="image-20230707214051312" style="zoom:87%;" /><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束是作用于表中字段的规则，用于限制存储在表中的数据，可以在创建表或修改表的时候添加约束。目的是保证数据库中数据的正确、有效性和完整性。</p><h3 id="约束分类"><a href="#约束分类" class="headerlink" title="约束分类"></a>约束分类</h3><img src="image-20230707214947434.png" alt="image-20230707214947434" style="zoom:87%;" /><blockquote><p>自增：<code>auto_increment</code> . 当插入一条数据失败时，这时候这条未插入的数据已经向数据库申请了自增的字段值。</p></blockquote><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键是用来让两张表的数据相互建立连接，从而保证数据的一致性和完整性的。</p><p>下面的两张表，仅存在逻辑上的关系，在数据库层面并未建立外键关联，所以是无法保证数据的一致性和完整性的。</p><p><img src="image-20230707220102885.png" alt="image-20230707220102885"></p><p>添加外键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(主表列名);</span><br></pre></td></tr></table></figure><p>删除外键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> key 外键名称;</span><br></pre></td></tr></table></figure><p>删除/更新行为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(主表列名) <span class="keyword">on</span> <span class="keyword">update</span> 行为 <span class="keyword">on</span> <span class="keyword">delete</span> 行为;</span><br></pre></td></tr></table></figure><img src="image-20230707223539126.png" alt="image-20230707223539126" style="zoom:87%;" /><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li>一对多</li></ul><p>一个部门对应多个员工，一个员工对应一个部门。<strong>在多的一方建立外键，指向一的一方的主键。</strong></p><img src="image-20230708095445790.png" alt="image-20230708095445790" style="zoom:87%;" /><ul><li>多对多</li></ul><p>一个学生可以选修多门课程，一门课程可以被多个学生选择。<strong>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。</strong></p><img src="image-20230708095651147.png" alt="image-20230708095651147" style="zoom:87%;" /><ul><li>一对一</li></ul><p>用户与用户详情的关系。多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率。<strong>在任意一方加入外键，关联另一方的主键，并且设置外键是唯一的(UNIQUE) – 保证一对一。</strong></p><img src="image-20230708100105054.png" alt="image-20230708100105054" style="zoom:87%;" /><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>查询的是两张表交集的部分。</p><ul><li><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">where</span> 条件...;</span><br></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件...;</span><br></pre></td></tr></table></figure></li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><ul><li><p>左外连接：相当于查询表1（左表）的所有数据（包含表1和表2交集部分）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure></li><li><p>右外连接：相当于查询表2（右表）的所有数据（包含表1和表2交集部分）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure></li></ul><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>可以是内连接查询，也可以是外连接查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A 别名A <span class="keyword">join</span> 表A 别名B <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A <span class="keyword">union</span> [<span class="keyword">all</span>] <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B;</span><br></pre></td></tr></table></figure><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致；<code>union</code>是将结果合并后去重，<code>union all</code>是只将结果合并。</p><h4 id="子查询（嵌套查询）"><a href="#子查询（嵌套查询）" class="headerlink" title="子查询（嵌套查询）"></a>子查询（嵌套查询）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> column1 <span class="operator">=</span> (<span class="keyword">select</span> column1 <span class="keyword">from</span> t2);</span><br></pre></td></tr></table></figure><p>根据子查询的结果不同分为：标量子查询、列子查询、行子查询、表子查询。</p><ul><li><p>标量子查询：<code>&gt;</code>, <code>&lt;</code>, <code>=</code>…</p></li><li><p>列子查询：<code>in</code>, <code>all</code>, <code>any</code>…</p></li><li><p>行子查询：<code>in</code>, <code>not in</code>, <code>=</code>, <code>&lt;&gt;</code></p></li><li><p>表子查询：<code>in</code></p></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功、要么同时失败。<strong>保证数据的正确性和完整性。</strong></p><p><font color="blue">默认MySQL的事务是自动提交的，也就是说当执行一条DML语句后，MySQL会立即隐式的提交事务。</font>（开启事务 → 提交/回滚事务）</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><ul><li><p>方式一</p><ul><li><p>查看/设置事务提交方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p> 方式二</p></li></ul><p>  开启事务后，必须手动<code>commit</code>提交事务（否则数据是不会在表中变化的），或者<code>rollback</code>回滚事务，才能结束这个事务。一旦事务提交，则其所做的修改就会永久保存到数据库中。</p><ul><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务</p></li><li><p>回滚事务</p></li></ul><h3 id="事务四大特性（面试题）"><a href="#事务四大特性（面试题）" class="headerlink" title="事务四大特性（面试题）"></a>事务四大特性（面试题）</h3><p><img src="image-20230708112047747.png" alt="image-20230708112047747"></p><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ul><li><p>脏读</p><p>一个事务读到另一个事务还没有提交的数据。</p><p><font color="red">Question：在事务没提交前更改的数据信息，保存在数据库的什么位置？</font></p><img src="image-20230708112301432.png" alt="image-20230708112301432" style="zoom:87%;" /></li><li><p>不可重复读</p><p>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><img src="image-20230708112746185.png" alt="image-20230708112746185" style="zoom:87%;" /></li><li><p>幻读</p><p>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在了。</p><img src="image-20230708112946935.png" alt="image-20230708112946935" style="zoom:87%;" /></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务的隔离级别是为了解决并发事务问题。设计数据库时需要衡量数据库的安全级别和并发性能。</p><img src="image-20230708113411288.png" alt="image-20230708113411288" style="zoom:87%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql是一种关系型数据库，这篇博客作为数据库的基础篇主要讲解操作关系型数据的SQL编程语言。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://kicheng.github.io/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>MybatisPlus</title>
    <link href="https://kicheng.github.io/2023/07/07/MybatisPlus/"/>
    <id>https://kicheng.github.io/2023/07/07/MybatisPlus/</id>
    <published>2023-07-07T02:19:57.000Z</published>
    <updated>2023-07-07T07:19:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。使用原生的Mybatis编写持久层逻辑时，所需要的代码是比较繁琐的，需要定义Mapper接口和Mapper.xml文件，每一个方法都需要编写对应的sql语句，会存在很多大量的重复工作，使用MP之后，对通用的方法做了高度的抽取，避免了很多重复工作，可以非常快速的实现了单表的各种增、删、改、查操作。</p><span id="more"></span><p>博客主要讲解Springboot项目下的MybatisPlus框架的核心功能，详细的可参考MP的<a href="https://baomidou.com/">中文开发文档</a>。</p><h2 id="入门配置"><a href="#入门配置" class="headerlink" title="入门配置"></a>入门配置</h2><ul><li><p>创建Springboot工程（在IDEA中集成功能）</p><ul><li><p>引入 Spring Boot Starter 父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>引入 <code>spring-boot-starter</code>、<code>spring-boot-starter-test</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- web工程也要导入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>引入<code>mybatis-plus-boot-starter</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入数据库依赖（在IDEA中集成功能）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 可选 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li><p><code>@TableName</code>：表名注解，标识实体类对应的表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@TableId</code>：主键注释，标识实体类主键字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必须指定</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String</td><td align="center">否</td><td align="center">“”</td><td align="center">主键字段名</td></tr><tr><td align="center">type</td><td align="center">Enum</td><td align="center">否</td><td align="center">IdType.NONE</td><td align="center">指定主键类型</td></tr></tbody></table><ul><li><p><code>IdType</code>的属性</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">AUTO</td><td align="left">数据库 ID 自增</td></tr><tr><td align="left">NONE</td><td align="left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td align="left">INPUT</td><td align="left">insert 前自行 set 主键值</td></tr><tr><td align="left">ASSIGN_ID</td><td align="left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr><tr><td align="left">ASSIGN_UUID</td><td align="left">分配 UUID,主键类型为 String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认 default 方法)</td></tr></tbody></table></li></ul></li><li><p><code>@TableField</code>：字段注解（非主键）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>value</code>：数据库字段名</p></li><li><p><code>fill</code>：字段自动填充策略</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">DEFAULT</td><td align="left">默认不处理</td></tr><tr><td align="left">INSERT</td><td align="left">插入时填充字段</td></tr><tr><td align="left">UPDATE</td><td align="left">更新时填充字段</td></tr><tr><td align="left">INSERT_UPDATE</td><td align="left">插入和更新时填充字段</td></tr></tbody></table></li></ul></li></ul><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="CRUD-接口"><a href="#CRUD-接口" class="headerlink" title="CRUD 接口"></a>CRUD 接口</h3><h4 id="Service-CRUD-接口"><a href="#Service-CRUD-接口" class="headerlink" title="Service CRUD 接口"></a>Service CRUD 接口</h4><p>通用 Service CRUD 封装 IService 接口，进一步封装 CRUD 采用 <code>get 查询单行</code> ，<code>remove 删除</code>， <code>list 查询集合</code> ，<code>page 分页</code> 前缀命名方式区分 Mapper 层避免混淆。</p><ul><li><p><code>Save</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;  <span class="comment">// batchSize:插入批次数量</span></span><br></pre></td></tr></table></figure></li><li><p><code>SaveOrUpdate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Remove</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 queryWrapper 设置的条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;  <span class="comment">// 主键ID</span></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;  <span class="comment">// idList:主键ID列表</span></span><br></pre></td></tr></table></figure></li><li><p><code>Update</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Get</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>List</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Page</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Count</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Mapper-CRUD-接口"><a href="#Mapper-CRUD-接口" class="headerlink" title="Mapper CRUD 接口"></a>Mapper CRUD 接口</h4><p>通用 CRUD 封装 BaseMapper 接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器。</p><ul><li><p><code>Insert</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Delete</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Update</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 修改</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Select</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p><strong>AbstractWrapper</strong>是QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类，用于生成 sql 的 where 条件。</p><blockquote><p>以下方法在入参中出现的<code>R</code>为泛型，在普通wrapper中是<code>String</code>，在<code>LambdaWrapper</code>中是<strong>函数</strong>(例:<code>Entity::getId</code>，<code>Entity</code>为实体类，<code>getId</code>为字段<code>id</code>的<strong>getter Method</strong>)。</p></blockquote><ul><li><p><code>allEq</code>：全部eq（或个别isNull）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allEq(Map&lt;R, V&gt; params)</span><br><span class="line">allEq(Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="type">boolean</span> condition, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br></pre></td></tr></table></figure><blockquote><p><code>params</code> : <code>key</code>为数据库字段名，<code>value</code>为字段值<br><code>null2IsNull</code> : 为<code>true</code>则在<code>map</code>的<code>value</code>为<code>null</code>时调用<code>isNull</code>方法，为<code>false</code>时则忽略<code>value</code>为<code>null</code>的值</p><ul><li>例1: <code>allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;)</code>—&gt;<code>id = 1 and name = &#39;老王&#39; and age is null</code></li><li>例2: <code>allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;, false)</code>—&gt;<code>id = 1 and name = &#39;老王&#39;</code></li></ul></blockquote></li><li><p><code>eq</code>：等于 =</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq(R column, Object val)</span><br><span class="line">eq(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure></li><li><p><code>ne</code>：不等于 &lt;&gt; (或 !=)</p></li><li><p><code>gt</code>：大于 &gt;</p></li><li><p><code>ge</code>：大于等于 &gt;=</p></li><li><p><code>lt</code>：小于 &lt;</p></li><li><p><code>le</code>：小于等于 &lt;=</p></li><li><p><code>between</code>：BETWEEN 值1 AND 值2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">between(R column, Object val1, Object val2)</span><br><span class="line">between(<span class="type">boolean</span> condition, R column, Object val1, Object val2)</span><br><span class="line"><span class="comment">// between(&quot;age&quot;, 18, 30)---&gt;age between 18 and 30</span></span><br></pre></td></tr></table></figure></li><li><p><code>notBetween</code>：NOT BETWEEN 值1 AND 值2</p></li><li><p><code>like</code></p></li><li><p><code>notLike</code></p></li><li><p><code>likeLeft</code></p></li><li><p><code>likeRight</code></p></li><li><p><code>isNull</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNull(R column)</span><br><span class="line">isNull(<span class="type">boolean</span> condition, R column)</span><br></pre></td></tr></table></figure></li><li><p><code>isNotNull</code></p></li><li><p><code>in</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in(R column, Collection&lt;?&gt; value)</span><br><span class="line">in(<span class="type">boolean</span> condition, R column, Collection&lt;?&gt; value)</span><br></pre></td></tr></table></figure></li><li><p><code>groupBy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupBy(R... columns)</span><br><span class="line">groupBy(<span class="type">boolean</span> condition, R... columns)</span><br><span class="line"><span class="comment">// groupBy(&quot;id&quot;, &quot;name&quot;)---&gt;group by id,name</span></span><br></pre></td></tr></table></figure></li><li><p><code>orderByAsc</code>：升序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderByAsc(R... columns)</span><br><span class="line">orderByAsc(<span class="type">boolean</span> condition, R... columns)</span><br></pre></td></tr></table></figure></li><li><p><code>orderByDesc</code>：升序排序</p></li><li><p><code>or</code>：主动调用<code>or</code>表示紧接着下一个<strong>方法</strong>不是用<code>and</code>连接!(不调用<code>or</code>则默认为使用<code>and</code>连接)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">or(Consumer&lt;Param&gt; consumer)</span><br><span class="line">or(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br><span class="line"><span class="comment">// eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)---&gt;id = 1 or name = &#x27;老王&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>不是全部，条件构造器API：<a href="https://baomidou.com/pages/10c804/#querywrapper%E3%80%82">https://baomidou.com/pages/10c804/#querywrapper。</a></p></blockquote><p><strong>QueryWrapper</strong>或者<strong>LambdaQueryWrapper</strong>，继承自 AbstractWrapper 。</p><ul><li><p><code>select</code>：设置查询字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select(String... sqlSelect)</span><br><span class="line">select(Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line"><span class="comment">// select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>UpdateWrapper</strong>或者<strong>LambdaUpdateWrapper</strong>，也继承自 AbstractWrapper。</p><ul><li><p><code>set</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(String column, Object val)</span><br><span class="line">set(<span class="type">boolean</span> condition, String column, Object val)</span><br><span class="line"><span class="comment">// set(&quot;name&quot;, &quot;老李头&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p><code>setSql</code>：设置 SET 部分 SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setSql(String sql) </span><br><span class="line"><span class="comment">// setSql(&quot;name = &#x27;老李头&#x27;&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p><code>lambda</code>：获取 <code>LambdaWrapper</code>，在<code>QueryWrapper</code>中是获取<code>LambdaQueryWrapper</code>在<code>UpdateWrapper</code>中是获取<code>LambdaUpdateWrapper</code>。</p></li></ul><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p><strong>安装</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><p><a href="https://baomidou.com/pages/779a6e/#%E4%BD%BF%E7%94%A8">https://baomidou.com/pages/779a6e/#%E4%BD%BF%E7%94%A8</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。使用原生的Mybatis编写持久层逻辑时，所需要的代码是比较繁琐的，需要定义Mapper接口和Mapper.xml文件，每一个方法都需要编写对应的sql语句，会存在很多大量的重复工作，使用MP之后，对通用的方法做了高度的抽取，避免了很多重复工作，可以非常快速的实现了单表的各种增、删、改、查操作。&lt;/p&gt;</summary>
    
    
    
    <category term="Springboot" scheme="https://kicheng.github.io/categories/Springboot/"/>
    
    
  </entry>
  
  <entry>
    <title>瑞吉外卖项目实战day2</title>
    <link href="https://kicheng.github.io/2023/07/06/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98day2/"/>
    <id>https://kicheng.github.io/2023/07/06/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98day2/</id>
    <published>2023-07-06T02:23:12.000Z</published>
    <updated>2023-07-06T13:48:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>适合新手小白入门Java后端开发的Springboot + Mybatis Plus 项目。</p><span id="more"></span><p>后面我逐渐省略了一些功能的记录，主要是因为和前面的业务万变不离其宗，如果要看详细的代码可以到我的github仓库下拉<a href="https://github.com/KiCheng/reggie">reggie代码</a>。</p><h2 id="业务实现（后台系统）"><a href="#业务实现（后台系统）" class="headerlink" title="业务实现（后台系统）"></a>业务实现（后台系统）</h2><h3 id="新增套餐"><a href="#新增套餐" class="headerlink" title="新增套餐"></a>新增套餐</h3><p><strong>数据模型</strong></p><p><img src="image-20230706103537857.png" alt="image-20230706103537857"></p><p><strong>表现层要素</strong></p><p><img src="image-20230706103038582.png" alt="image-20230706103038582"></p><p>请求类型：POST</p><p>请求路径：<code>/setmeal</code></p><p><img src="image-20230706103143613.png" alt="image-20230706103143613"></p><p>请求参数：json格式的数据，除了setmeal套餐的基本信息外，还有套餐内的菜品信息setmealDishes也封装成json数组的格式。<font color="blue">（还有idType和dishList是什么，当请求参数json数据key大于dto对象的时候，可以正常封装吗？）</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addSetmeal</span>(prams)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;套餐添加成功！&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (!st) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">ruleForm</span>.<span class="title function_">resetFields</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dishList</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dishTable</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ruleForm</span> = &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">categoryId</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">code</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">image</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">description</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">dishList</span>: [],</span><br><span class="line">          <span class="attr">status</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">idType</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>返回值类型：<code>Result&lt;String&gt;</code>类型</p><p><strong>核心业务思路</strong></p><p>仍然是操作setmeal数据表和setmeal_dish数据表，要在Service类上加事务管理注释<code>@Transactional</code>。</p><p>步骤1：在Service类自定义新增套餐的业务层方法，并在类上加事务管理注释<code>@Transactional</code>；</p><p>步骤2：调用Service层原生的save方法将SetmealDto对象传入并保存；</p><p>步骤3：接下来要对setmeal_dish数据表进行添加多条数据，可以从dto对象中get到setmealDishes这个属性列表，但是不能直接将setmealDishes列表<code>saveBatch</code>，要对其赋值setmeal_id值；</p><p>步骤4：通过dto对象get到id值（执行了save操作，在setmeal表已经通过雪花算法为dto对象生成了id属性值），将其赋给setmealDishes列表的setmealDish.setmealId套餐id值；</p><p>步骤5：调用Service层的<code>saveBatch</code>将setmealDishes列表添加到setmeal_dish数据表中。</p><h3 id="套餐信息分页查询"><a href="#套餐信息分页查询" class="headerlink" title="套餐信息分页查询"></a>套餐信息分页查询</h3><p><strong>表现层要素</strong></p><p><img src="image-20230706111444821.png" alt="image-20230706111444821"></p><p>请求类型：GET</p><p>请求路径：<code>/setmeal/page</code></p><p>请求参数：普通参数page、pageSize和可选参数name</p><p>返回值类型：<code>Result&lt;Page&gt;</code></p><p><strong>核心业务思路</strong></p><p>跟前面的菜品信息分页查询一模一样。</p><h3 id="删除套餐"><a href="#删除套餐" class="headerlink" title="删除套餐"></a>删除套餐</h3><p><strong>表现层要素</strong></p><p><img src="image-20230706113845252.png" alt="image-20230706113845252"></p><p>请求类型：DELETE</p><p>请求路径：<code>/setmeal</code></p><p>请求参数：普通参数ids，因为批量删除的id可能有多个，所以这里的方法形参是<code>List&lt;Long&gt; ids</code>，要加<code>@RequestParam</code>注解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">deleteSetmeal</span>(type === <span class="string">&#x27;批量&#x27;</span> ? <span class="variable language_">this</span>.<span class="property">checkList</span>.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) : id).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;删除成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回值类型：<code>Result&lt;String&gt;</code></p><p><strong>核心业务思路</strong></p><p>首先操作setmeal表删除套餐信息，再操作setmeal_dish表删除setmeal_id字段 = ids的所有数据。</p><h3 id="批量起售停售"><a href="#批量起售停售" class="headerlink" title="批量起售停售"></a>批量起售停售</h3><p><img src="image-20230706163258312.png" alt="image-20230706163258312"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">changeStatus</span><span class="params">(<span class="meta">@PathVariable</span> Integer status, <span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">        LambdaUpdateWrapper&lt;Setmeal&gt; lambdaUpdateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaUpdateWrapper.in(Setmeal::getId, ids);</span><br><span class="line">        lambdaUpdateWrapper.set(Setmeal::getStatus, status);</span><br><span class="line">        setmealService.update(lambdaUpdateWrapper);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;状态修改成功&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="订单明细分页查询"><a href="#订单明细分页查询" class="headerlink" title="订单明细分页查询"></a>订单明细分页查询</h3><p>跟前面的分页查询相比就是可选参数变多了，还有就是关注一下“时间”作为可选参数如何处理。</p><p><img src="image-20230706203744254.png" alt="image-20230706203744254"></p><p>可选参数：</p><img src="image-20230706203801378.png" alt="image-20230706203801378" style="zoom:67%;" /><p><img src="image-20230706203823723.png" alt="image-20230706203823723"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Page&gt; <span class="title function_">pageSelect</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> pageSize, String number,String beginTime, String endTime)</span>&#123;</span><br><span class="line">    Page&lt;Orders&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page ,pageSize);</span><br><span class="line">    LambdaQueryWrapper&lt;Orders&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.like(StringUtils.hasText(number), Orders::getNumber, number);</span><br><span class="line">    lambdaQueryWrapper.gt(StringUtils.hasText(beginTime), Orders::getOrderTime, beginTime)</span><br><span class="line">            .lt(StringUtils.hasText(endTime), Orders::getOrderTime, endTime);</span><br><span class="line">    lambdaQueryWrapper.orderByDesc(Orders::getOrderTime);</span><br><span class="line"></span><br><span class="line">    orderService.page(pageInfo, lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务实现（移动端系统）"><a href="#业务实现（移动端系统）" class="headerlink" title="业务实现（移动端系统）"></a>业务实现（移动端系统）</h2><h3 id="手机验证码登录"><a href="#手机验证码登录" class="headerlink" title="手机验证码登录"></a>手机验证码登录</h3><p><strong>流程分析</strong></p><ol><li>点击获取验证码，页面向服务端发送第一次请求，请求服务器随机生成要求的验证码并发送到表单输出的手机号中；</li><li>点击登录，页面向服务端发送第二次请求，携带表单输入的验证码和Session中储存的验证码进行比对，确定是否成功登录。</li></ol><p><strong>核心业务思路</strong></p><ul><li>发送验证码请求</li></ul><p>导入手机验证的依赖坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里云短信服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-dysmsapi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写一个工具类（根据阿里云短信服务的帮助文档改的），用于发送手机验证码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 短信发送工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送短信</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> signName 签名</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> templateCode 模板</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> phoneNumbers 手机号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String signName, String templateCode,String phoneNumbers,String param)</span>&#123;</span><br><span class="line">      <span class="type">DefaultProfile</span> <span class="variable">profile</span> <span class="operator">=</span> DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);  <span class="comment">// accessKeyId, secret</span></span><br><span class="line">      <span class="type">IAcsClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAcsClient</span>(profile);</span><br><span class="line"></span><br><span class="line">      <span class="type">SendSmsRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendSmsRequest</span>();</span><br><span class="line">      request.setSysRegionId(<span class="string">&quot;cn-hangzhou&quot;</span>);</span><br><span class="line">      request.setPhoneNumbers(phoneNumbers);</span><br><span class="line">      request.setSignName(signName);</span><br><span class="line">      request.setTemplateCode(templateCode);</span><br><span class="line">      request.setTemplateParam(<span class="string">&quot;&#123;\&quot;code\&quot;:\&quot;&quot;</span>+param+<span class="string">&quot;\&quot;&#125;&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">SendSmsResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.getAcsResponse(request);</span><br><span class="line">         System.out.println(<span class="string">&quot;短信发送成功&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随机生成随机验证码的工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机生成验证码工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateCodeUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 长度为4位或者6位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">generateValidateCode</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">4</span>)&#123;</span><br><span class="line">            code = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">9999</span>);<span class="comment">//生成随机数，最大为9999</span></span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">                code = code + <span class="number">1000</span>;<span class="comment">//保证随机数为4位数字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(length == <span class="number">6</span>)&#123;</span><br><span class="line">            code = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">999999</span>);<span class="comment">//生成随机数，最大为999999</span></span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="number">100000</span>)&#123;</span><br><span class="line">                code = code + <span class="number">100000</span>;<span class="comment">//保证随机数为6位数字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;只能生成4位或6位数字验证码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成指定长度字符串验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateValidateCode4String</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rdm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hash1</span> <span class="operator">=</span> Integer.toHexString(rdm.nextInt());</span><br><span class="line">        <span class="type">String</span> <span class="variable">capstr</span> <span class="operator">=</span> hash1.substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> capstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改拦截器，对客户端登录相关的请求进行放行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义不需要处理的请求路径</span></span><br><span class="line">String[] urls = &#123;</span><br><span class="line">        <span class="string">&quot;/employee/login&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/employee/logout&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/backend/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/front/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/common/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/user/sendMsg&quot;</span>,  <span class="comment">// 移动端发送短信</span></span><br><span class="line">        <span class="string">&quot;/user/login&quot;</span>  <span class="comment">// 移动端登录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>表现层方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpSession session)</span>&#123;</span><br><span class="line">      <span class="comment">// 获取手机号</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> user.getPhone();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(StringUtils.hasText(phone))&#123;</span><br><span class="line">          <span class="comment">// 生成随机的4位验证码</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> ValidateCodeUtils.generateValidateCode(<span class="number">4</span>).toString();</span><br><span class="line">          log.info(<span class="string">&quot;code -&gt; &#123;&#125;&quot;</span>, code);</span><br><span class="line">          <span class="comment">// 调用阿里云提供的短信服务API完成短信发送</span></span><br><span class="line">          SMSUtils.sendMessage(<span class="string">&quot;瑞吉外卖&quot;</span>, <span class="string">&quot;您的验证码为：$&#123;code&#125;，请勿泄露于他人！&quot;</span>, phone, code);</span><br><span class="line">          <span class="comment">// 需要将生成的验证码保存到Session中</span></span><br><span class="line">          session.setAttribute(phone, code);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> Result.success(<span class="string">&quot;手机短信验证码发送成功&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Result.error(<span class="string">&quot;手机短信验证码发送失败&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>登录请求</li></ul><p><img src="image-20230706171041816.png" alt="image-20230706171041816"></p><p>请求参数是json格式的code和phone，phone是User实体类的属性，但是验证码code不是。有两种解决方案：① 定义增强类UserDto； ② 用Map的key-value接收参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;User&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> Map userMap, HttpSession session)</span>&#123;</span><br><span class="line">    log.info(userMap.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> userMap.get(<span class="string">&quot;phone&quot;</span>).toString();</span><br><span class="line">    <span class="comment">// 获取验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> userMap.get(<span class="string">&quot;code&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从session中获取保存的验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">codeInSession</span> <span class="operator">=</span> session.getAttribute(phone).toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行验证码的比对（页面提交的验证码和Session中保存的验证码做比对）</span></span><br><span class="line">    <span class="keyword">if</span>(codeInSession != <span class="literal">null</span> &amp;&amp; codeInSession.equals(code))&#123;</span><br><span class="line">        <span class="comment">// 如果能够比对成功，说明登录成功</span></span><br><span class="line">        <span class="comment">// 判断当前手机号对应的用户是否为新用户</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(User::getPhone, phone);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getOne(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果是新用户则自动注册</span></span><br><span class="line">            user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setPhone(phone);</span><br><span class="line">            userService.save(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, user.getId());</span><br><span class="line">        <span class="keyword">return</span> Result.success(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.error(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="地址簿管理"><a href="#地址簿管理" class="headerlink" title="地址簿管理"></a>地址簿管理</h3><p><strong>address_book数据模型</strong></p><p><img src="image-20230706171952511.png" alt="image-20230706171952511"></p><p><strong>表现层代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址簿管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/addressBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressBookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;AddressBook&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> AddressBook addressBook)</span> &#123;</span><br><span class="line">        addressBook.setUserId(BaseContext.getCurrentId());</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line">        addressBookService.save(addressBook);</span><br><span class="line">        <span class="keyword">return</span> Result.success(addressBook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置默认地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/default&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;AddressBook&gt; <span class="title function_">setDefault</span><span class="params">(<span class="meta">@RequestBody</span> AddressBook addressBook)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line">        LambdaUpdateWrapper&lt;AddressBook&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());</span><br><span class="line">        wrapper.set(AddressBook::getIsDefault, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//SQL:update address_book set is_default = 0 where user_id = ?</span></span><br><span class="line">        addressBookService.update(wrapper);</span><br><span class="line"></span><br><span class="line">        addressBook.setIsDefault(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//SQL:update address_book set is_default = 1 where id = ?</span></span><br><span class="line">        addressBookService.updateById(addressBook);</span><br><span class="line">        <span class="keyword">return</span> Result.success(addressBook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (addressBook != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.success(addressBook);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;没有找到该对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询默认地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/default&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;AddressBook&gt; <span class="title function_">getDefault</span><span class="params">()</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());</span><br><span class="line">        queryWrapper.eq(AddressBook::getIsDefault, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SQL:select * from address_book where user_id = ? and is_default = 1</span></span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == addressBook) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;没有找到该对象&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.success(addressBook);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定用户的全部地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;AddressBook&gt;&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddressBook</span>();</span><br><span class="line">        addressBook.setUserId(BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件构造器</span></span><br><span class="line">        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="literal">null</span> != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());</span><br><span class="line">        queryWrapper.orderByDesc(AddressBook::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SQL:select * from address_book where user_id = ? order by update_time desc</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(addressBookService.list(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心业务思路</strong></p><ul><li><p>设置默认地址</p><p>一个用户的默认收货地址只能有一个，如何保证在设置默认地址时，每个用户的默认地址只有一个呢？那就是每次操作address_book数据表时，先将该用户的所有<code>is_default</code>字段都设置为0，再将选中的设置为1。</p></li><li><p>查询指定用户的全部地址</p><p><img src="image-20230706173632478.png" alt="image-20230706173632478"></p></li></ul><p>​    这里不需要请求参数，只需要用户userId，这个可以从Session中获取。</p><h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p><strong>需求分析</strong></p><ul><li>移动端用户可以将菜品/套餐添加到购物车</li><li>对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车（前端实现）</li><li>对于套餐来说，可以直接点击当前套餐加入购物车</li><li>在购物车中可以修改菜品/套餐的数量，也可以清空购物车</li></ul><p><strong>表现层代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/shoppingCart&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCartController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向购物车中新增菜品或套餐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shoppingCart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;ShoppingCart&gt; <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> ShoppingCart shoppingCart)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前用户的id，指定是哪个用户的购物车数据</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">        shoppingCart.setUserId(currentId);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> shoppingCart.getDishId();</span><br><span class="line">        <span class="comment">// 菜品和套餐的区别是发送的请求参数一个是dishId一个是setmealId</span></span><br><span class="line">        <span class="comment">// SQL: select * from shopping_cart where user_id = ? and [dish_id = ? 或者 setmeal_id = ?]</span></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId);</span><br><span class="line">        <span class="keyword">if</span>(dishId == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 加入购物车的是套餐setmealId</span></span><br><span class="line">            lambdaQueryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 加入购物车的是单菜品</span></span><br><span class="line">            lambdaQueryWrapper.eq(ShoppingCart::getDishId, shoppingCart.getDishId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  shopping_cart中的一行数据</span></span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">shoppingCartOne</span> <span class="operator">=</span> shoppingCartService.getOne(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还要检查加入购物车菜品或者套餐的数量 -- 如果是第一次添加则setNumber=1，并执行save操作；如果不是第一次添加则updateNumber++</span></span><br><span class="line">        <span class="keyword">if</span>(shoppingCartOne == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 第一次添加</span></span><br><span class="line">            shoppingCart.setNumber(<span class="number">1</span>);</span><br><span class="line">            shoppingCart.setCreateTime(LocalDateTime.now());</span><br><span class="line">            shoppingCartService.save(shoppingCart);</span><br><span class="line">            shoppingCartOne = shoppingCart;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 不是第一次添加</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> shoppingCartOne.getNumber();</span><br><span class="line">            shoppingCartOne.setNumber(++number);</span><br><span class="line">            shoppingCartService.updateById(shoppingCartOne);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success(shoppingCartOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向购物车中减少菜品或套餐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shoppingCart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sub&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;ShoppingCart&gt; <span class="title function_">sub</span><span class="params">(<span class="meta">@RequestBody</span> ShoppingCart shoppingCart)</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">        shoppingCart.setUserId(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际请求参数只有dishId或者setmealId</span></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(ShoppingCart::getUserId, userId);</span><br><span class="line">        <span class="keyword">if</span>(shoppingCart.getDishId() != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 菜品</span></span><br><span class="line">            lambdaQueryWrapper.eq(ShoppingCart::getDishId, shoppingCart.getDishId());</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 套餐</span></span><br><span class="line">            lambdaQueryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">one</span> <span class="operator">=</span> shoppingCartService.getOne(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(one.getNumber() == <span class="number">1</span>)&#123;</span><br><span class="line">            shoppingCartService.remove(lambdaQueryWrapper);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(one.getNumber() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            one.setNumber(one.getNumber() - <span class="number">1</span>);</span><br><span class="line">            shoppingCartService.updateById(one);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success(one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据登录用户的id查询购物车的列表清单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;ShoppingCart&gt;&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId);</span><br><span class="line">        lambdaQueryWrapper.orderByAsc(ShoppingCart::getCreateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;ShoppingCart&gt; list = shoppingCartService.list(lambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">return</span> Result.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空购物车</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/clean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">cleanShoppingCart</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId);</span><br><span class="line">        shoppingCartService.remove(lambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;清空购物车成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户下单"><a href="#用户下单" class="headerlink" title="用户下单"></a>用户下单</h3><p><strong>流程分析</strong></p><ol><li>在订单确认页面中，发送ajax请求，请求服务端，获取当前登录用户的默认地址</li><li>在订单确认页面，发送ajax请求，请求服务端，获取当前登录用户的购物车数据</li><li>在订单确认页面点击去支付按钮，发送ajax请求，请求服务端，完成下单操作</li></ol><p><strong>数据模型</strong></p><p>orders数据表：</p><img src="image-20230706184553636.png" alt="image-20230706184553636" style="zoom:87%;" /><p>order_detail数据表：</p><img src="image-20230706184642018.png" alt="image-20230706184642018" style="zoom:87%;" /><p><strong>“下单”核心业务思路</strong></p><p>步骤1：查询当前用户的购物车，判断购物车是否为空，如果为空抛出业务异常无法下单；</p><p>步骤2：向订单表orders插入(1条)数据；</p><p>步骤3：向订单明细表order_detail插入(多条)数据；</p><p>步骤4：清空购物车数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户下单提交</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orders</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Orders orders)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得当前用户的id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询当前用户id的购物车数据</span></span><br><span class="line">    LambdaQueryWrapper&lt;ShoppingCart&gt; cartLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    cartLambdaQueryWrapper.eq(ShoppingCart::getUserId, currentId);</span><br><span class="line">    List&lt;ShoppingCart&gt; cartList = shoppingCartService.list(cartLambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cartList == <span class="literal">null</span> || cartList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;购物车为空，无法下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户数据</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(currentId);</span><br><span class="line">    <span class="comment">// 查询地址数据</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">addressBookId</span> <span class="operator">=</span> orders.getAddressBookId();</span><br><span class="line">    <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getById(addressBookId);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> IdWorker.getId();<span class="comment">//订单号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历购物车数据得到订单明细列表数据</span></span><br><span class="line">    List&lt;OrderDetail&gt; orderDetails = cartList.stream().map((item) -&gt; &#123;</span><br><span class="line">        <span class="type">OrderDetail</span> <span class="variable">orderDetail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderDetail</span>();</span><br><span class="line">        orderDetail.setOrderId(orderId);</span><br><span class="line">        orderDetail.setNumber(item.getNumber());</span><br><span class="line">        orderDetail.setDishFlavor(item.getDishFlavor());</span><br><span class="line">        orderDetail.setDishId(item.getDishId());</span><br><span class="line">        orderDetail.setSetmealId(item.getSetmealId());</span><br><span class="line">        orderDetail.setName(item.getName());</span><br><span class="line">        orderDetail.setImage(item.getImage());</span><br><span class="line">        orderDetail.setAmount(item.getAmount());</span><br><span class="line">        amount.addAndGet(item.getAmount().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(item.getNumber())).intValue());</span><br><span class="line">        <span class="keyword">return</span> orderDetail;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单表数据设置</span></span><br><span class="line">    orders.setId(orderId);</span><br><span class="line">    orders.setOrderTime(LocalDateTime.now());</span><br><span class="line">    orders.setCheckoutTime(LocalDateTime.now());</span><br><span class="line">    orders.setStatus(<span class="number">2</span>);</span><br><span class="line">    orders.setAmount(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(amount.get()));<span class="comment">//总金额</span></span><br><span class="line">    orders.setUserId(currentId);</span><br><span class="line">    orders.setNumber(String.valueOf(orderId));</span><br><span class="line">    orders.setUserName(user.getName());</span><br><span class="line">    orders.setConsignee(addressBook.getConsignee());</span><br><span class="line">    orders.setPhone(addressBook.getPhone());</span><br><span class="line">    orders.setAddress((addressBook.getProvinceName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getProvinceName())</span><br><span class="line">            + (addressBook.getCityName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getCityName())</span><br><span class="line">            + (addressBook.getDistrictName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getDistrictName())</span><br><span class="line">            + (addressBook.getDetail() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getDetail()));</span><br><span class="line">    <span class="comment">// 向订单表orders插入(1条)数据</span></span><br><span class="line">    <span class="built_in">this</span>.save(orders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向订单明细表order_detail插入(多条)数据</span></span><br><span class="line">    orderDetailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空购物车数据</span></span><br><span class="line">    shoppingCartService.remove(cartLambdaQueryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;适合新手小白入门Java后端开发的Springboot + Mybatis Plus 项目。&lt;/p&gt;</summary>
    
    
    
    <category term="Springboot" scheme="https://kicheng.github.io/categories/Springboot/"/>
    
    
  </entry>
  
  <entry>
    <title>瑞吉外卖项目实战day1</title>
    <link href="https://kicheng.github.io/2023/07/04/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98day1/"/>
    <id>https://kicheng.github.io/2023/07/04/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98day1/</id>
    <published>2023-07-04T03:22:20.000Z</published>
    <updated>2023-07-06T13:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>适合新手小白入门Java后端开发的Springboot + Mybatis Plus 项目。</p><span id="more"></span><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="配置静态资源映射"><a href="#配置静态资源映射" class="headerlink" title="配置静态资源映射"></a>配置静态资源映射</h3><p>为了访问静态资源，要进行静态资源映射的配置。</p><p>Springboot将静态资源都放在<code>resource/static</code>目录下，会进行自动配置静态资源映射。</p><p><img src="image-20230704123442685.png" alt="image-20230704123442685"></p><p>如果静态资源没放在<code>resource/static</code>目录，要书写配置类实现<code>WebMvcConfigurer</code>接口，重写<code>addResourceHandlers</code>方法，进行手动配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始进行静态资源映射...&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/backend/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/backend/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/front/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/front/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不推荐继承WebMvcConfigurationSupport类，而是使用实现WebMvcConfigurer接口，因为继承类会覆盖Springboot提供的自动静态资源映射配置，而实现接口是在原有的配置上附加映射配置。</p></blockquote><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Application.yml配置文件，核心是服务器端口号+数据库四要素。</p><p>此外还有mybatis-plus的一些配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">reggie_take_out</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/reggie</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">ASSIGN_ID</span></span><br></pre></td></tr></table></figure><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>导入lombok依赖，通过<code>@Data</code>注释在实体类中只需要定义属性名，会自动生成默认的无参构造方法和setter/getter方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@AllArgsConstructor</code>：提供全部参数的构造方法，会覆盖<code>@Data</code>提供的无参构造方法。</p><p><code>@NoArgsConstructor</code>：提供默认的无参构造方法。</p><h3 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h3><p>使用Result类将服务器的响应进行统一格式的结果封装。</p><p>属性：状态位code（0/1）、错误信息msg（String）、数据data（泛型T）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">//编码：1成功，0和其它数字为失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//动态数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;T&gt;();</span><br><span class="line">        result.data = object;</span><br><span class="line">        result.code = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        result.msg = msg;</span><br><span class="line">        result.code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Result&lt;T&gt; <span class="title function_">add</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h2><p>编写Controller表现层业务方法时，首先需要通过前端代码以及浏览器开发者工具明确几个要素：</p><ul><li><p>请求类型</p></li><li><p>请求路径</p></li><li><p>请求参数：尽量封装成实体类对象，通过getter得到请求参数。</p><ul><li><code>@PathVariable</code>：RESTful风格的参数</li><li><code>@RequestBody</code>：json格式数据</li><li><code>@RequestParam</code></li></ul></li><li><p>返回值类型：看前端代码需要服务器响应什么类型的数据。</p></li></ul><h3 id="后台登录功能"><a href="#后台登录功能" class="headerlink" title="后台登录功能"></a>后台登录功能</h3><p><strong>表现层要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// login.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loginApi</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;/employee/login&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求类型：POST</p><p>请求路径：<code>/employee/login</code></p><p>请求参数：包含username和password的json格式数据，可以封装成Employee实体类对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;userInfo&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res.<span class="property">data</span>))</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>= <span class="string">&#x27;../../index.html&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值类型：由于前端需要服务端的响应包含<code>data</code>属性，所以返回值应该是<code>Result&lt;Employee&gt;</code>类型</p><p><strong>核心业务思路</strong></p><p>步骤1：先判断请求参数username/password是否为空，任一为空就不用再查表了；</p><p>步骤2：根据请求参数的username查表 – <code>LambdaQueryWrapper</code>封装查询条件；</p><p>步骤3：没查到数据（username）则返回失败；</p><p>步骤4：查询到了数据则进行密码比对，密码不一致返回失败 – 登录功能的密码考虑到安全性可以进行md5加密后再存入数据库：<code>DigestUtils</code>工具类的<code>md5DigestAsHex(String.getBytes())</code>方法；</p><p>步骤5：登陆成功，将员工id存入Session备用。</p><blockquote><p>复习Session：一种服务端的会话跟踪技术，在一次会话的多次请求中共享数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Session</span></span><br><span class="line">HttpServletRequset.getSession().setAttribute(String key, Object o);</span><br><span class="line"><span class="comment">// 获取Session内容</span></span><br><span class="line">HttpServletRequset.getSession().getAttribute(String key);</span><br><span class="line"><span class="comment">// 删除Session内容</span></span><br><span class="line">HttpServletRequset.getSession().removeAttribute(String key);</span><br></pre></td></tr></table></figure></blockquote><p><strong>登录业务完善</strong></p><p>只有登录成功了才得以访问其他页面，未登录则跳转到登录页面——在过滤器或拦截器中判断用户是否登录。</p><ul><li><p>实现Filter过滤器</p><ul><li><p>在LoginCheckFilter类中实现<code>Filter</code>接口，加类注释<code>@WebFilter</code>，重写<code>doFilter</code>方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;, urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Servlet的过滤器对登录功能进行数据增强：访问界面如果未登录则自动跳转到登录界面</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Springboot启动类上加<code>@ServletComponentScan</code>注释；</p></li></ul></li><li><p>过滤器登录检查逻辑</p><ul><li><p>获取本次请求的URI</p></li><li><p>定义不需要拦截的请求（静态资源+登录登出有关的资源路径），并判断本次请求是否需要被处理</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 包含通配符的路径匹配 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">PATH_MATCHER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"><span class="comment">// -----------具体实现-----------</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkFilter</span><span class="params">(String[] urls, String requestURI)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PATH_MATCHER.match(url, requestURI)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果不需要处理则直接放行</p></li><li><p>判断登录状态（通过Session），如果已登录则放行，如果未登录则通过输出流方式返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.getWriter().write(JSON.toJSONString(Result.error(<span class="string">&quot;NOTLOGIN&quot;</span>)));</span><br></pre></td></tr></table></figure><blockquote><p>使用JSON.toJSONString要导入fastjson坐标。</p></blockquote></li></ul></li></ul><h3 id="添加员工功能"><a href="#添加员工功能" class="headerlink" title="添加员工功能"></a>添加员工功能</h3><p><strong>表现层要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// member.js  新增---添加员工</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addEmployee</span> (params) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/employee&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求类型：POST</p><p>请求路径：<code>/employee</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEmployee</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;员工添加成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!st) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ruleForm</span> = &#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;phone&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="comment">// &#x27;password&#x27;: &#x27;&#x27;,</span></span><br><span class="line">        <span class="comment">// &#x27;rePassword&#x27;: &#x27;&#x27;,/</span></span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;idNumber&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求参数：包含username、name、phone、sex、idNumber的json格式数据，可以封装成Employee实体类对象</p><p>返回值类型：由于前端需要服务端的响应只有<code>code</code>和<code>msg</code>属性，所以返回值写成<code>Result&lt;String&gt;</code>类型。</p><p><strong>核心业务思路</strong></p><p>Controller表现层直接调用Service层的<code>save</code>添加实体轮类Employee对象，在Mapper层对象解析成Employee数据表中的字段进行数据添加。</p><p><strong>添加员工业务完善</strong></p><p>操作数据库时insert操作要注意：① 数据表中not null的字段必须有值； ② 数据表中主键、not unique字段都不能重复，要进行判断。</p><ul><li>Employee数据表结构：</li></ul><img src="image-20230704144542860.png" alt="image-20230704144542860" style="zoom:87%;" /><p>前端的表单中提交过来的参数填充的字段有：username、name、phone、sex、id_number，主键id雪花算法自动生成、status具有默认值1，所以后面4个not null字段的值需要我们手动来添加：</p><p>而创建人、创建时间、修改人、修改时间字段属于公共字段，不仅员工表有这些字段，在菜品表、分类表等其他表中，也拥有这些字段。那我们有没有办法让这些字段在一个地方统一管理呢？</p><p>解决方案：使用MybatisPlus给我们提供的公共字段自动填充功能。</p><ul><li>在Employee数据表中，username字段not unique不能重复：</li></ul><img src="image-20230704144402844.png" alt="image-20230704144402844" style="zoom:87%;" /><p>步骤1：获取请求参数中的username，调用Service方法检查用户名是否重复；</p><p>步骤2：用户名重复则无法添加，<strong>抛出异常</strong>（进行统一异常处理）并响应给前端提示信息；用户名未重复则操作数据库进行添加操作。</p><p><strong>公共字段自动填充</strong></p><p>步骤1：按照框架要求编写元数据对象处理器MyMetaObjectHandler类，在此类中统一对公共字段赋值，此类需要实现<code>MetaObjectHandler</code>接口，实现接口之后，重写两个方法，一个是插入时填充，一个是修改时填充（字段填充方式，使用metaObject的<code>setValue</code>方法来实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作自动填充</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">      <span class="comment">// 在元数据对象处理器中通过LocalThread获取用户id</span></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作自动填充</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        log.info(<span class="string">&quot;线程id: &#123;&#125;&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">       <span class="comment">// 在元数据对象处理器中通过LocalThread获取用户id</span></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2：在实体类的属性上方加入<code>@TableFiled</code>注解，指定自动填充的策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span>  <span class="comment">// 插入时填充字段</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>  <span class="comment">// 插入和更新时填充字段</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span>  <span class="comment">// 插入时填充字段</span></span><br><span class="line"><span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>  <span class="comment">// 插入和更新时填充字段</span></span><br><span class="line"><span class="keyword">private</span> Long updateUser;</span><br></pre></td></tr></table></figure><p><strong>通过LocalThread获取用户id</strong></p><p>关于id的获取，我们之前是存到session里的，但在<code>MyMetaObjectHandler</code>类中不能获得HttpSession对象，所以我们需要用其他方式来获取登录用户id。</p><p>我们可以使用<code>ThreadLocal</code>来解决这个问题：在学习ThreadLocal之前，我们需要先确认一个事情，<font color="blue">就是客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程：</p><ol><li><code>LoginCheckFilter</code>中的<code>doFilter</code>方法</li><li><code>EmployeeController</code>中的响应方法</li><li><code>MyMetaObjectHandler</code>中的<code>insertFill</code>或者<code>updateFill</code>方法</li></ol><blockquote><p>ThreadLocal并不是一个Thread，而是Thread的局部变量；当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本；所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本；ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p></blockquote><p>具体实现——</p><p>我们可以在LoginCheckFilter过滤器的的<code>doFilter</code>方法中获取当前登录用户id，并调用<code>ThreadLocal</code>的<code>set</code>方法来设置当前线程的线程局部变量的值（用户id)，然后在MyMetaObjectHandler的<code>insertFill</code>或<code>updateFill</code>方法中调用<code>ThreadLocal</code>的<code>get</code>方法来获得当前线程所对应的线程局部变量的值（用户id)。</p><ul><li>步骤1：common包下新建BaseContext类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户的id</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤2：在LoginCheckFilter类（每次请求都会首先经过过滤器类）中获取当前Session的值(用户id)，使用BaseContext封装的<code>setCurrentId</code>方法封装id值</li><li>步骤3：在MyMetaObjectHandler类中获取当前请求所在线程的id值。</li></ul><p><strong>统一异常处理</strong></p><ul><li>统一异常处理框架<ul><li>在common包下添加一个ProjectExceptionAdvice统一异常处理类，加类注释<code>@RestControllerAdvice</code>；</li><li>方法参数是异常类型的对象ex，方法上加类注释<code>@ExceptionHandler(异常类型.class)</code>，返回值一般是<code>Result&lt;String&gt;</code>；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">doSqlException</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">        log.info(ex.getMessage());  <span class="comment">// Duplicate entry &#x27;lisi&#x27; for key &#x27;employee.idx_username&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* --- 异常逻辑判断（可选） ---  */</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常逻辑判断（有些时候需要，有时不用）– <code>ex.getMessage()</code>方法很重要</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ex.getMessage().contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;<span class="comment">// Duplicate entry &#x27;lisi&#x27; for key &#x27;employee.idx_username&#x27;</span></span><br><span class="line">    String[] split = ex.getMessage().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> split[<span class="number">2</span>] + <span class="string">&quot;已存在&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Result.error(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="员工信息分页查询"><a href="#员工信息分页查询" class="headerlink" title="员工信息分页查询"></a>员工信息分页查询</h3><p><strong>表现层要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// member.js </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMemberList</span> (params) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/employee/page&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    params</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求类型：GET</p><p>请求路径：<code>/employee/page</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> init () &#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">      <span class="attr">page</span>: <span class="variable language_">this</span>.<span class="property">page</span>,</span><br><span class="line">      <span class="attr">pageSize</span>: <span class="variable language_">this</span>.<span class="property">pageSize</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">input</span> ? <span class="variable language_">this</span>.<span class="property">input</span> : <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">getMemberList</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">records</span> || []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">counts</span> = res.<span class="property">data</span>.<span class="property">total</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求出错了：&#x27;</span> + err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><img src="image-20230704170513895.png" alt="image-20230704170513895"></p><p>请求参数：包含page、pageSzie和可选参数name，因为是get请求，所以请求参数是在请求头中的普通参数</p><p>返回值类型：由于前端需要服务端的响应除了<code>code</code>属性还有<code>res.data.records</code>和<code>res.data.total</code>属性，很明显方法返回值是<code>Result&lt;Page&gt;</code>类型。</p><p><strong>Mybatis-Plus中分页插件配置</strong></p><p>要在Springboot项目中使用分页查询，必须要配置Mybatis-Plus的分页插件：</p><p>在config包下新建MybatisPlusConfig配置类，在方法中首先创建一个MybatisPlus拦截器，在拦截器中再添加分页查询的拦截器，不要忘了将方法注释为<code>@Bean</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置MybatisPlus的分页插件</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心业务思路</strong></p><p>分页查询的请求参数是page、pageSize，响应参数也是page，它的业务逻辑比较固定，直接展示实现基本分页功能的表现层代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Page&gt; <span class="title function_">pageSelect</span><span class="params">(Integer page, Integer pageSize, String name)</span>&#123;</span><br><span class="line">        <span class="comment">// 构造分页构造器</span></span><br><span class="line">        Page&lt;Employee&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page, pageSize);</span><br><span class="line">        <span class="comment">// 构造条件构造器</span></span><br><span class="line">        LambdaQueryWrapper&lt;Employee&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加过滤条件</span></span><br><span class="line">        lambdaQueryWrapper.like(StringUtils.hasText(name), Employee::getName, name);  <span class="comment">// 或者 name != null</span></span><br><span class="line">        <span class="comment">// 添加排序条件</span></span><br><span class="line">        lambdaQueryWrapper.orderByDesc(Employee::getUpdateTime);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        employeeService.page(pageInfo, lambdaQueryWrapper);  <span class="comment">// IService的page函数会将查询数据自动封装到pageInfo当中</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(pageInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="禁用-启用员工账号"><a href="#禁用-启用员工账号" class="headerlink" title="禁用/启用员工账号"></a>禁用/启用员工账号</h3><p>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作：账号禁用的员工不能登录系统，启用后的员工可以正常登录。【前端业务】需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。</p><p><strong>表现层要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// member.js --启用禁用接口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">enableOrDisableEmployee</span> (params) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/employee&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求类型：PUT</p><p>请求路径：<code>/employee</code></p><p><img src="image-20230704173524643.png" alt="image-20230704173524643"></p><p>请求参数：包含id和status的json格式数据，可以封装成Employee实体类对象（这里注意一下，status为0则表示客户端的禁用请求，status为1则表示客户端的启用请求）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enableOrDisableEmployee</span>(&#123; <span class="string">&#x27;id&#x27;</span>: <span class="variable language_">this</span>.<span class="property">id</span>, <span class="string">&#x27;status&#x27;</span>: !<span class="variable language_">this</span>.<span class="property">status</span> ? <span class="number">1</span> : <span class="number">0</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enableOrDisableEmployee&#x27;</span>,res)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;账号状态更改成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值类型：由于前端需要服务端的响应只有<code>code</code>属性，所以返回值写成<code>Result&lt;String&gt;</code>类型。</p><p><strong>核心业务思路</strong></p><p>将请求参数传入Service的updateById方法，就可以更改相应employee数据的status字段值。</p><p><font color="blue">但是通过日志我们发现，数据并没有修改成功，原因是服务端接收到的Long类型的请求参数<code>employee.id</code> 通过前端js已经丢失了精度，导致id不准确，无法从数据库中找到相应id的数据！</font></p><p>解决方案是：我们可以在服务端给页面响应json数据时进行处理，将Long型数据统一转为String字符串。</p><p><strong>拓展mvc的消息转换器</strong></p><p>可以自定义服务器Result对象序列化成json数据的细节，比如数据类型Long→String，比如自定义时间格式等。</p><p>步骤1：common包下配置对象映射器<font color="red">（工具类可以直接复制代码）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span></span><br><span class="line"><span class="comment"> * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span></span><br><span class="line"><span class="comment"> * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonObjectMapper</span> <span class="keyword">extends</span> <span class="title class_">ObjectMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;HH:mm:ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JacksonObjectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//收到未知属性时不报异常</span></span><br><span class="line">        <span class="built_in">this</span>.configure(FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化时，属性不存在的兼容处理</span></span><br><span class="line">        <span class="built_in">this</span>.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">simpleModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>()</span><br><span class="line">                .addDeserializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line"></span><br><span class="line">                .addSerializer(BigInteger.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(Long.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addSerializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addSerializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span></span><br><span class="line">        <span class="built_in">this</span>.registerModule(simpleModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2：扩展Mvc框架的消息转换器</p><p>config包下的WebMvcConfig配置类，实现<code>WebMvcConfigurer</code>接口，重写<code>extendMessageConverters</code>方法（方法在项目启动时就被调用）。springboot自己的消息转换器可以把返回的Result对象序列化成json数据响应给前端，而我们可以根据自己的需要扩展消息转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展mvc框架的消息转换器: springboot自己的消息转换器可以把返回的Result对象序列化成json数据响应给前端，而我们可以根据自己的需要扩展消息转换器</span></span><br><span class="line"><span class="comment">     * (方法在项目启动时调用)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;扩展消息转换器...&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建消息转换器对象</span></span><br><span class="line">        <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">messageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        <span class="comment">// 设置对象转换器，底层使用jackson将Java对象转换成json数据</span></span><br><span class="line">        messageConverter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">        <span class="comment">// 将上面的消息转换器对象追加到mvc框架的转换器集合中</span></span><br><span class="line">        converters.add(<span class="number">0</span>, messageConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑员工信息"><a href="#编辑员工信息" class="headerlink" title="编辑员工信息"></a>编辑员工信息</h3><p><strong>流程分析</strong></p><p>后续我们会开发一些比较复杂的业务功能，一个业务功能处理多个请求发送多个响应数据，所以流程分析是很重要的。</p><ol><li>在list.html页面中，点击编辑按钮，页面跳转到add.html中，并在url中携带employee的id；</li><li>发送ajax请求（回显数据的请求），将id提交给服务器；</li><li>服务器接收请求，根据id查询employee信息，并将员工信息响应给页面；</li><li>页面接收服务端的json数据，并通过Vue的双向绑定进行员工信息回显；</li><li>点击保存按钮，发送ajax请求（修改数据的请求），将id和表单数据一起提交至服务端；</li><li>服务端接收员工信息，根据id修改员工的信息，完成后给页面响应。</li></ol><p><strong>表现层要素</strong></p><ul><li>回显数据的请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// member.js -- 修改页面反查详情接口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queryEmployeeById</span> (id) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">`/employee/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230704201830485.png" alt="image-20230704201830485"></p><p>请求类型：GET</p><p>请求路径：<code>/employee/&#123;id&#125;</code></p><p>请求参数：只有员工id，且是RESTful风格，需要加<code>@PathVariable</code>注解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">queryEmployeeById</span>(<span class="variable language_">this</span>.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span> = res.<span class="property">data</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span>.<span class="property">sex</span> = res.<span class="property">data</span>.<span class="property">sex</span> === <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;女&#x27;</span> : <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    <span class="comment">// this.ruleForm.password = &#x27;&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回值类型：前端需要服务端的响应<code>data</code>属性，所以方法返回值是Result<Employee>类型。</p><ul><li>修改数据的请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改---添加员工</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">editEmployee</span> (params) &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/employee&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求类型：PUT</p><p>请求路径：<code>/employee</code></p><p><img src="image-20230704210234755.png" alt="image-20230704210234755"></p><p>请求参数：json格式的员工信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">editEmployee</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;员工信息修改成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回值类型：前端只要服务端的响应<code>code</code>和<code>msg</code>属性，所以方法返回值是<code>Result&lt;String&gt;</code>类型即可。</p><p><strong>核心业务思路</strong></p><p>通过员工id查询Employee数据表进行数据回显；前端点击修改按钮后，服务端接收修改后的Employee对象请求参数，调用Service层的updateById传回employee对象即可修改数据表内容。</p><h3 id="新增菜品分类"><a href="#新增菜品分类" class="headerlink" title="新增菜品分类"></a>新增菜品分类</h3><p><strong>数据模型</strong></p><p><img src="image-20230705093303752.png" alt="image-20230705093303752"></p><p>菜品分类id字段是主键，name分类名称是unique唯一的，type为1表示菜品分类，type为2表示套餐分类。</p><p><strong>表现层要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// category.js -- 新增接口</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">addCategory</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;/category&#x27;</span>,</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">     <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>请求类型：POST</p><p>请求路径：<code>/employee</code></p><p><img src="image-20230705094033530.png" alt="image-20230705094033530"></p><p><img src="image-20230705094411620.png" alt="image-20230705094411620"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addCategory</span>(&#123;<span class="string">&#x27;name&#x27;</span>: classData.<span class="property">name</span>,<span class="string">&#x27;type&#x27;</span>:<span class="variable language_">this</span>.<span class="property">type</span>, <span class="attr">sort</span>: classData.<span class="property">sort</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;分类添加成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!st) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">dialogVisible</span> = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">sort</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>请求参数：json格式的请求参数，包含name、type、sort字段，可以封装成Category对象</p><p>返回值类型：前端需要服务端的响应只有<code>code</code>和<code>msg</code>属性，所以方法返回值是<code>Result&lt;String&gt;</code>类型</p><p><strong>核心业务思路</strong></p><p>前面已经做过新增员工的业务逻辑，新增菜品分类的其实都是一样的，<strong>（新增业务的重点）保证每一个not null的字段都有赋值且unique的字段没有重复</strong>，再通过Service层的save方法调用进而mapper操作数据库进行添加数据。</p><h3 id="分类信息分页查询"><a href="#分类信息分页查询" class="headerlink" title="分类信息分页查询"></a>分类信息分页查询</h3><p><strong>表现层要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// category.js -- 查询列表接口</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">getCategoryPage</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;/category/page&#x27;</span>,</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">     params</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>请求类型：GET</p><p>请求路径：<code>/category/page</code></p><p><img src="image-20230705094851492.png" alt="image-20230705094851492"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="title function_">getCategoryPage</span>(&#123;<span class="string">&#x27;page&#x27;</span>: <span class="variable language_">this</span>.<span class="property">page</span>, <span class="string">&#x27;pageSize&#x27;</span>: <span class="variable language_">this</span>.<span class="property">pageSize</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">records</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">counts</span> = <span class="title class_">Number</span>(res.<span class="property">data</span>.<span class="property">total</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>请求参数：分页查询，请求参数是普通请求头里的page、pageSize。</p><p>返回值类型：<code>Result&lt;Page&gt;</code>类型</p><p><strong>核心业务思路</strong></p><p>对于分页查询来说，我们一定要记得配置MybatisPlus的分页查询插件。除此之外，表现层的业务代码非常简单：分页构造器+条件构造器（排序条件），调用Service层的page函数即可，最终把分页构造器响应给前端用来页面的展示。</p><blockquote><p>分页插件的配置，再复习一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="删除菜品分类"><a href="#删除菜品分类" class="headerlink" title="删除菜品分类"></a>删除菜品分类</h3><p><strong>表现层要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// category.js -- 删除当前列的接口</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">deleCategory</span> = (<span class="params">ids</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;/category&#x27;</span>,</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">     <span class="attr">params</span>: &#123; ids &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230705100107054.png" alt="image-20230705100107054"></p><p>请求类型：DELETE</p><p>请求路径：<code>/category/&#123;ids&#125;</code></p><p>请求参数：RESTful风格的菜品id参数，如果方法参数名和前端请求参数名不一致，需要在注释后面加<code>@PathVariable(&quot;参数名&quot;)</code>参数名进行映射。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">deleCategory</span>(id).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;删除成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回值类型：<code>Result&lt;String&gt;</code>类型</p><p><strong>核心业务思路</strong></p><p>因为请求参数是Category数据表的主键值id，所以直接调用Service层的<code>removeById</code>删除数据即可。和新增业务必须考虑的not null和unique字段一样，删除业务也有必须考虑的点：<strong>也就是当前要删除的数据，是否跟其他表中的数据相关联。</strong>对于当前来说，当菜品分类或套餐分类关联了其他菜品或套餐时，该分类将不允许被删除，所以我们需要进一步完善我们的删除业务逻辑。<font color="red">（是否可以直接把关联通过外键约束等体现在数据库中，这需要进一步优化数据库表？复习完mysql再回来研究）</font></p><p>MybatisPlus中的Service层提供的删除方法不能满足我们的业务需求，所以我们在Service层手动添加remove方法：我们需要在删除数据之前，根据<code>id</code>值，去<code>Dish</code>表和<code>Setmeal</code>表中（<code>category_id</code>字段）查询是否关联了数据：如果存在关联数据，则不能删除，并抛一个自定义的业务异常。</p><blockquote><p>复习一下统一异常处理：自定义业务异常</p><p>步骤1：在exception包下创建响应的Exception类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的业务异常</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2：在统一异常处理类中自定义异常处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理方法</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(ServiceException.class)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">doServiceException</span><span class="params">(ServiceException ex)</span>&#123;</span><br><span class="line">    log.info(ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> Result.error(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="修改菜品分类"><a href="#修改菜品分类" class="headerlink" title="修改菜品分类"></a>修改菜品分类</h3><p><strong>表现层要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// category.js -- 修改接口</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">editCategory</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;/category&#x27;</span>,</span><br><span class="line">     <span class="attr">method</span>: <span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">     <span class="attr">data</span>: &#123; ...params &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230705105056053.png" alt="image-20230705105056053"></p><p>请求类型：PUT</p><p>请求路径：<code>/category</code></p><p><img src="image-20230705105128881.png" alt="image-20230705105128881"></p><p>请求参数：json格式的菜品id、name、sort参数，封装成Category对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">editCategory</span>(&#123;<span class="string">&#x27;id&#x27;</span>:<span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">id</span>,<span class="string">&#x27;name&#x27;</span>: <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">name</span>, <span class="attr">sort</span>: <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">sort</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;分类修改成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">classData</span>.<span class="property">dialogVisible</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleQuery</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回值类型：<code>Result&lt;String&gt;</code>类型</p><blockquote><p>这里的数据回显完全交由前端来处理，我们简单了解下前端是如何完成数据回显的即可。页面首先通过<code>scope.row</code> 传递当前行的数据对象，通过v-model双向绑定完成数据的回显。</p></blockquote><p><strong>核心业务思路</strong></p><p>没什么好讲的，直接调用Service原生的<code>updateById</code>方法把实体类对象传进去。</p><h3 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h3><p><strong>文件上传</strong></p><p>文件上传，也叫upload，是指将本地图片、视频、音频等文件上传到服务器中，可以供其他用户浏览或下载的过程。</p><p>文件上传的前端业务我们不需要掌握，只需要了解文件上传是通过采用post方式提交数据即可。Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个<code>MultipartFile</code>类型的参数即可接收上传的文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;  <span class="comment">// 请求参数名是Form-Data的name值</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(fileName);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的MultipartFile类型的参数名不是随意定的，要和前端请求参数中Form-Data的<code>name</code>值一致才可以！</p><p><img src="image-20230705112408492.png" alt="image-20230705112408492"></p></blockquote><p><strong>文件下载</strong></p><p>文件下载，也称为了download，是指将文件从服务器传输到本地计算机的过程，<strong>本质上就是服务端将文件以流的形式写回浏览器的过程</strong>。通过浏览器进行文件下载，通常有两种表现形式：① 以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录；② 直接在浏览器中打开。</p><p><strong>文件上传核心业务实现</strong></p><p><img src="image-20230705161814263.png" alt="image-20230705161814263"></p><p>请求类型：POST</p><p>请求路径：<code>/common/upload</code></p><p>请求参数：<code>MultipartFile</code>类型的对象<code> file</code></p><p>方法返回值：<code>Result&lt;String&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 注入配置文件的属性</span></span><br><span class="line"> <span class="meta">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;  <span class="comment">// 请求参数名是Form-Data的name值</span></span><br><span class="line">     log.info(file.toString());</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 本地的是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();   <span class="comment">// xxxxxxx.jpg</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用UUID重新生成文件名，防止文件名重复造成的文件覆盖</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 判断文件目录basePath确实存在，若不存在则先进行创建 */</span></span><br><span class="line">     <span class="comment">// 创建一个目录对象</span></span><br><span class="line">     <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">     <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">         dir.mkdirs();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + fileName));  <span class="comment">// 转存文件</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Result.success(fileName);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因为上传至服务器的是一个临时文件（完成本次请求后会被删除），所以我们需要设定文件转存到指定位置，在yml配置文件中设置保存在服务器中的路径并通过<code>@Value(&quot;$&#123;xxx&#125;&quot;)</code>获得路径：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义下载上传图片的路径配置</span></span><br><span class="line"><span class="attr">reggie:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/Users/NUC/git/SSM/reggie_take_out/src/main/resources/picture/</span></span><br></pre></td></tr></table></figure><p><strong>文件下载核心业务实现</strong></p><p>前端页面的ElementUI在上传完图片后发送请求，服务端以流的方式（输出流）将文件写回给浏览器，在浏览器中展示图片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handleAvatarSuccess (response, file, fileList) &#123;</span><br><span class="line">  <span class="comment">// 拼接down接口预览</span></span><br><span class="line">  <span class="keyword">if</span>(response.<span class="property">code</span> === <span class="number">0</span> &amp;&amp; response.<span class="property">msg</span> === <span class="string">&#x27;未登录&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">top</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;../login/login.html&#x27;</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">`/common/download?name=<span class="subst">$&#123;response.data&#125;</span>`</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span>.<span class="property">image</span> = response.<span class="property">data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="image-20230705162548370.png" alt="image-20230705162548370"></p><p>请求类型：GET</p><p>请求路径：<code>/common/download</code></p><p>请求参数：String类型的文件名name</p><p>方法返回值：无</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件下载</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(HttpServletResponse response, <span class="meta">@RequestParam(&quot;name&quot;)</span> String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 输入流，通过输入流读取文件内容</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + fileName));</span><br><span class="line">    <span class="comment">// 输出流，通过输出流将文件写回浏览器，在浏览器展示图片</span></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应数据的类型</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>((len = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        outputStream.write(bytes,<span class="number">0</span> ,len);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    outputStream.close();</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>文件下载中有一个容易被忽视的点：浏览器需要知道文件的类型，所以必须设置相应数据的类型<code>response.setContentType</code>，否则会导致下载失败。</p></blockquote><h3 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h3><p><strong>流程分析</strong></p><ol><li>add.html页面发送ajax请求，请求服务器获取菜品分类并展示到下拉框中</li><li>选择图片进行上传，请求服务器将图片保存在服务器当中</li><li>上传成功后前端会自动发送下载请求，回显上传的图片</li><li>点击保存按钮，发送ajax请求，将菜品相关json数据提供到服务器端进行处理</li></ol><p><strong>表现层要素</strong></p><p>上传下载请求上一节讲的很明白了这里就不说了，主要讲一下第一个请求（是容易被忽略掉的）和第四个请求。</p><ul><li>获取菜品分类并展示到下拉框</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取菜品分类列表</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCategoryList</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/category/list&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    params</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求类型：GET</p><p>请求路径：<code>/category/list</code></p><p><img src="image-20230705171036768.png" alt="image-20230705171036768"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取菜品分类</span></span><br><span class="line">getDishList () &#123;</span><br><span class="line">  <span class="title function_">getCategoryList</span>(&#123; <span class="string">&#x27;type&#x27;</span>: <span class="number">1</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dishList</span> = res.<span class="property">data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>请求参数：菜品分类Category对象中的分类类型type，可以封装成Category对象</p><p>方法返回值：前端得到服务器响应的结果有<code>data</code>属性，返回值应该是<code>Result&lt;List&gt;</code>类型，将查询到的列表响应给前端</p><ul><li>将新增菜品json数据提交</li></ul><p><img src="image-20230705163823971.png" alt="image-20230705163823971"></p><p>请求类型：POST</p><p>请求路径：<code>/dish</code></p><p><img src="image-20230705163902869.png" alt="image-20230705163902869"></p><p>请求参数：json格式的dish菜品信息，外加flavors是一个json数组。而flavors不是Dish类中的属性，Dish对象不足以接收本次请求的参数，所以需要导入Dish的增强类DishDto，用于封装页面提交的数据。</p><blockquote><p>DTO，全称为<code>Data Transfer Object</code>，即数据传输对象，一般用于展示层与服务层之间的数据传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishDto</span> <span class="keyword">extends</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;DishFlavor&gt; flavors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer copies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">actionType</span> == <span class="string">&#x27;add&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">delete</span> params.<span class="property">id</span></span><br><span class="line">  <span class="title function_">addDish</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;菜品添加成功！&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (!st) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dishFlavors</span> = []</span><br><span class="line">        <span class="comment">// this.dishFlavorsData = []</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ruleForm</span> = &#123;</span><br><span class="line">          <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;price&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;image&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;description&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;dishFlavors&#x27;</span>: [],</span><br><span class="line">          <span class="string">&#x27;status&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">categoryId</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>返回值类型：<code>Result&lt;String&gt;</code>类型</p><p><strong>核心业务思路</strong></p><ul><li>获取菜品分类并展示到下拉框</li></ul><p>​        将请求参数type作为查询条件，调用Service层的<code>list</code>将菜品分类列表响应给前端即可。</p><ul><li>将新增菜品json数据提交</li></ul><p>​        由于请求参数是json格式的嵌套，且flavors口味数据并不在Dish数据表中，所以要完成新增菜品的业务我们需要：① 在dish数据表中添加菜品基本信息； ② 在dish_flavor数据表中添加口味信息。    </p><p>​        步骤1：因为要在两张数据表中添加数据，所以不能用MyabtisPlus提供好的Service层方法，我们在Service中自定义新增方法；</p><p>​        <font color="red">因为这里要在多张表中添加或修改数据，所以要加入事务管理：① 在Service层方法或类上加注释<code>@Transactional</code>； ② 在启动类上加注释<code>@EnableTransactionManagement</code>.</font></p><p>​        步骤2：添加菜品的基本信息到dish菜品表<code>this.save(dishDto);</code>；<font color="blue">（这里可以直接传dishDto对象）</font></p><p>​        步骤3：添加菜品口味数据flavors到菜品口味表dish_flavor，要注意dish_id（是一个not null字段）无法通过flavors列表赋值要通过Dto对象手动set。</p><p>​                               <img src="image-20230705182604710.png" alt="image-20230705182604710" style="zoom:77%;" /></p><h3 id="菜品信息分页查询"><a href="#菜品信息分页查询" class="headerlink" title="菜品信息分页查询"></a>菜品信息分页查询</h3><p><strong>流程分析</strong></p><p>这里的分页查询其实也是发送了两次请求：</p><ol><li>请求参数page、pageSize和可选参数name，发送分页请求并回显在页面上；</li><li>向服务端发送下载请求，将图片回显到页面上。（这个请求前面的CommonController表现层已经实现功能响应）</li></ol><p><strong>核心业务思路</strong></p><p>分页查询前面已经做过好多了，这里的分页查询图片列和菜品分类列比较特殊：</p><ul><li>图片列：会用到文件的下载功能</li><li>菜品分类列：由于我们的dish菜品表只保存了category_id，所以我们需要在category分类表中查询category_id对应的菜品分类名称，从而回显数据</li></ul><p><img src="image-20230705184128037.png" alt="image-20230705184128037"></p><p>因为代码中用到了几个比较关键的知识点，所以这里我直接展示业务代码，也方便到时候复习来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Page&gt; <span class="title function_">pageSelect</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> pageSize, String name)</span> &#123;</span><br><span class="line">        Page&lt;Dish&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page, pageSize);</span><br><span class="line">        Page&lt;DishDto&gt; dishDtoPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.like(name != <span class="literal">null</span>, Dish::getName, name);</span><br><span class="line">        lambdaQueryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line">      </span><br><span class="line">        dishService.page(pageInfo, lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象拷贝pageInfo除了&quot;records&quot;属性</span></span><br><span class="line">        BeanUtils.copyProperties(pageInfo, dishDtoPage, <span class="string">&quot;records&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">        List&lt;DishDto&gt; dishDtoList = records.stream().map((item) -&gt; &#123;</span><br><span class="line">            <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line">            BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">            <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();</span><br><span class="line">            <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line">            <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">            dishDto.setCategoryName(categoryName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dishDtoPage.setRecords(dishDtoList);</span><br><span class="line">        <span class="keyword">return</span> Result.success(dishDtoPage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h3><p><strong>流程分析</strong></p><ol><li>页面发送ajax请求，请求服务器获取分类数据，用于菜品分类下拉框的数据回显（之前已经实现过了）</li><li>页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片回显（之前已经实现过了）</li><li>点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</li></ol><p><strong>表现层要素</strong></p><ul><li>回显数据</li></ul><p><img src="image-20230705214455637.png" alt="image-20230705214455637"></p><p>请求类型：GET</p><p>请求路径：<code>/dish/&#123;id&#125;</code></p><p>请求参数：RESTful风格的菜品id</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">queryDishById</span>(<span class="variable language_">this</span>.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">String</span>(res.<span class="property">code</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span> = &#123; ...res.<span class="property">data</span> &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span>.<span class="property">price</span> = <span class="title class_">String</span>(res.<span class="property">data</span>.<span class="property">price</span>/<span class="number">100</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ruleForm</span>.<span class="property">status</span> = res.<span class="property">data</span>.<span class="property">status</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dishFlavors</span> = res.<span class="property">data</span>.<span class="property">flavors</span> &amp;&amp; res.<span class="property">data</span>.<span class="property">flavors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">obj</span> =&gt;</span> (&#123; ...obj, <span class="attr">value</span>: <span class="title class_">JSON</span>.<span class="title function_">parse</span>(obj.<span class="property">value</span>),<span class="attr">showOption</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this.dishFlavors&#x27;</span>,<span class="variable language_">this</span>.<span class="property">dishFlavors</span>)</span><br><span class="line">    <span class="comment">// this.ruleForm.id = res.data.data.categoryId</span></span><br><span class="line">    <span class="comment">// this.imageUrl = res.data.data.image</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">`/common/download?name=<span class="subst">$&#123;res.data.image&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方法返回值：前端用到了响应的<code>data.flavors</code>属性，所以响应的数据一定是Result<DishDto>类型</p><ul><li>提交修改数据</li></ul><p><img src="image-20230705215233049.png" alt="image-20230705215233049"></p><p>请求类型：PUT</p><p>请求路径：<code>/dish</code></p><img src="image-20230705215325955.png" alt="image-20230705215325955" style="zoom:77%;" /><p>请求参数：json格式的DishDto对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">editDish</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;菜品修改成功！&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">goBack</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方法返回值：<code>Result&lt;String&gt;</code></p><p><strong>核心业务思路</strong></p><ul><li>回显数据</li></ul><p>​        这里的数据回显还是值得一提的。通常来说数据回显就是以id作为请求参数向服务端发送查询请求，在以id作为主键的数据表中查询到该条数据并将该对象作为相应参数返回并回显在页面上。但是这里回显的数据内容除了以id作为主键的dish菜品表外，还有flavors口味信息，需要在dish_flavor表中查询多条数据。</p><p>​        步骤1：在Service层自定义一个根据菜品id查询的业务层方法；</p><p>​        步骤2：根据id查询dish菜品表中的基本信息，只需要调用MybatisPlus原生的<code>getOne</code>方法得到查询到的Dish对象；</p><p>​        步骤3：因为要在dish_flavor表再做查询，而Dish对象没有flavors属性，所以定义一个DishDto增强对象，并进行Dish的对象拷贝；</p><p>​        步骤4：根据DishDto的id属性查询dish_id = id的DishDto对象列表，set给DishDto的flavors属性，将DishDto响应给前端。</p><ul><li><p>提交修改数据</p><p>很显然这里也要涉及两张表dish表和dish_flavor表的修改操作，所以先在Service实现类上加上注释<code>@Transactional</code>。</p><p>步骤1：先在Service实现类上加上注释<code>@Transactional</code>；</p></li></ul><p>​       步骤2：将请求参数DishDto传入MybatisPlus原生的<code>updateById</code>方法修改dish表中的菜品基本信息；</p><p>​       步骤3：在dish_flavor表中涉及多条数据的修改，所以这里的修改我们将其拆分为删除+添加两个过程来完成：首先是将dish_id = DishDto.id的数据删除；</p><p>​       步骤4：再将DishDto.flavors这个列表通过<code>saveBatch</code>方法添加到口味表中，其中dish_id字段在DishDto.flavors中没有相应的属性对应，要进行手动的set。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;适合新手小白入门Java后端开发的Springboot + Mybatis Plus 项目。&lt;/p&gt;</summary>
    
    
    
    <category term="Springboot" scheme="https://kicheng.github.io/categories/Springboot/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA中集成git</title>
    <link href="https://kicheng.github.io/2023/06/30/IDEA%E4%B8%AD%E9%9B%86%E6%88%90git/"/>
    <id>https://kicheng.github.io/2023/06/30/IDEA%E4%B8%AD%E9%9B%86%E6%88%90git/</id>
    <published>2023-06-30T09:21:51.000Z</published>
    <updated>2023-06-30T11:42:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客主要记录git的常用命令以及在IDE中集成git简化版本控制操作。</p><span id="more"></span><p>git安装以及更新（macOS）：<a href="https://docs.brew.sh/Installation">安装Homebrew</a></p><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h3 id="git全局设置"><a href="#git全局设置" class="headerlink" title="git全局设置"></a>git全局设置</h3><ul><li><p>git版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li><p>设置用户信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;KiCheng&quot;</span><br><span class="line">git config --global user.email &quot;lijiacehng053@gmail.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>查看配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取本地仓库"><a href="#获取本地仓库" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h3><ul><li><p>在本地初始化一个git仓库（不常用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库克隆（常用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [URL]</span><br></pre></td></tr></table></figure></li></ul><h3 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h3><ul><li><p>查看文件状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>将文件的修改加入暂存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [文件名] / git add .</span><br></pre></td></tr></table></figure></li><li><p>将暂存区的文件取消暂存或者是切换到指定版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset [文件名] / git reset .</span><br><span class="line">git reset --hard [版本号]</span><br></pre></td></tr></table></figure></li><li><p>将暂存区的文件修改提交到本地版本库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;[注释内容]&quot;</span><br></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li></ul><h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><ul><li><p>查看远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote / git remote -v</span><br></pre></td></tr></table></figure></li><li><p>连接到远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [远程仓库名(通常是origin)] [URL]</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库克隆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [URL]</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库拉取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [远程仓库名] [分支名]</span><br></pre></td></tr></table></figure></li><li><p>推送到远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库名] [分支名]</span><br></pre></td></tr></table></figure></li></ul><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul><li><p>查看分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>创建分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [分支名]</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [分支名]</span><br></pre></td></tr></table></figure></li><li><p>推送至远程仓库分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库名] [分支名]</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [分支名]</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>分支合并时冲突：手动处理合并冲突再重新<code>add</code> +<code> commit -i</code>.</p></blockquote><h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><ul><li><p>列出已有标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li><li><p>创建标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag [标签名]</span><br></pre></td></tr></table></figure></li><li><p>将标签推送至远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag [远程仓库名] [标签名]</span><br></pre></td></tr></table></figure></li><li><p>创建新分支检出标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [新建分支名] [标签名]</span><br></pre></td></tr></table></figure></li></ul><h2 id="IDEA中集成git"><a href="#IDEA中集成git" class="headerlink" title="IDEA中集成git"></a>IDEA中集成git</h2><img src="image-20230630182031051.png" alt="image-20230630182031051" style="zoom:77%;" /><h3 id="获取本地仓库-1"><a href="#获取本地仓库-1" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h3><h4 id="方法一：本地初始化仓库"><a href="#方法一：本地初始化仓库" class="headerlink" title="方法一：本地初始化仓库"></a>方法一：本地初始化仓库</h4><img src="image-20230630182255719.png" alt="image-20230630182255719" style="zoom:77%;" /><p>路径选择IDE中的demo目录即可。</p><h4 id="方法二：从远程仓库克隆"><a href="#方法二：从远程仓库克隆" class="headerlink" title="方法二：从远程仓库克隆"></a>方法二：从远程仓库克隆</h4><p><img src="image-20230630182549048.png" alt="image-20230630182549048"></p><p><img src="image-20230630182656435.png" alt="image-20230630182656435"></p><h3 id="本地仓库操作-1"><a href="#本地仓库操作-1" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h3><ul><li><p>将文件加入暂存区</p><p>IDEA会弹出提示框，自动把新建或修改的文件add到暂存区，也可以手动添加。</p></li></ul><blockquote><p>未加入暂存区的文件是红色的，加入暂存区的文件是绿色的：</p><p><img src="image-20230630183314045.png" alt="image-20230630183314045"></p></blockquote><ul><li>将暂存区的文件提交到版本库</li></ul><p>​                                        <img src="image-20230630183737356.png" alt="image-20230630183737356" style="zoom: 50%;" /></p><ul><li>查看日志</li></ul><p><img src="image-20230630184053887.png" alt="image-20230630184053887"></p><h3 id="远程仓库操作-1"><a href="#远程仓库操作-1" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><ul><li>查看并添加远程仓库</li></ul><img src="image-20230630193049503.png" alt="image-20230630193049503" style="zoom:67%;" /><img src="image-20230630193130607.png" alt="image-20230630193130607" style="zoom:87%;" /><ul><li>推送至远程仓库</li></ul><img src="image-20230630184015304.png" alt="image-20230630184015304" style="zoom:77%;" /><ul><li>从远程仓库拉取</li></ul><h3 id="分支操作-1"><a href="#分支操作-1" class="headerlink" title="分支操作"></a>分支操作</h3><p><img src="image-20230630193635799.png" alt="image-20230630193635799"></p><ul><li><p>将分支推送到远程仓库</p><img src="image-20230630193920080.png" alt="image-20230630193920080" style="zoom:87%;" /></li><li><p>合并分支</p></li></ul><img src="image-20230630194033825.png" alt="image-20230630194033825" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇博客主要记录git的常用命令以及在IDE中集成git简化版本控制操作。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://kicheng.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Maven进阶</title>
    <link href="https://kicheng.github.io/2023/06/22/Maven%E8%BF%9B%E9%98%B6/"/>
    <id>https://kicheng.github.io/2023/06/22/Maven%E8%BF%9B%E9%98%B6/</id>
    <published>2023-06-22T02:20:18.000Z</published>
    <updated>2023-06-23T05:31:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Maven就是是专门为Java项目打造的管理和构建工具，它 提供了一套标准化的项目结构、提供了一套标准化的构建流程等等。</p><span id="more"></span><h2 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h2><h3 id="分模块开发设计"><a href="#分模块开发设计" class="headerlink" title="分模块开发设计"></a>分模块开发设计</h3><p>1、按照功能拆分：如果把不同业务场景的模块代码放入到一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目无法正常启动，从而导致多个业务都无法正常运行。所以我们会<strong>按照功能</strong>将项目进行拆分。</p><p>2、按照模块拆分：比如电商的项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期的维护成本就比较高。我们就想能不能将它们公共的部分抽取成一个独立的模块，其他模块要想使用可以像添加第三方jar包依赖一样来使用我们自己抽取的模块，这样就解决了代码重复的问题，这种拆分方式就说我们所说的<strong>按照模块</strong>拆分。</p><p>我们可以将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享：</p><img src="image-20230622151943596.png" alt="image-20230622151943596" style="zoom:77%;" /><p>这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。</p><h3 id="分模块开发实现"><a href="#分模块开发实现" class="headerlink" title="分模块开发实现"></a>分模块开发实现</h3><p>这里就基于SSM整合的项目来实现对项目的拆分。</p><p><strong>环境准备</strong>（之前ssm整合的框架）</p><img src="image-20230622160806750.png" alt="image-20230622160806750" style="zoom:77%;" /><h4 id="抽取domain层"><a href="#抽取domain层" class="headerlink" title="抽取domain层"></a>抽取domain层</h4><p>步骤1：创建新模块maven_03_pojo</p><p>步骤2：项目中创建domain包，将Book实体类复制进来</p><p>步骤3：删除原项目(maven_02_ssm)中的domain包</p><p><img src="image-20230622161341910.png" alt="image-20230622161341910"></p><p>这时在原项目中用到Book实体类的地方都会出现报错。<strong>解决问题的办法是在maven_02_ssm中添加maven_03_pojo的依赖。</strong></p><p>步骤4：建立依赖关系</p><p>在maven_02_ssm项目的pom.xml添加maven_03_pojo的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤5：编译maven_02_ssm模块</p><p>这时虽然不再报错了，但是不意味着程序可以正常运行。报错提醒我们在maven_02_ssm模块中找不到maven_03_pojo的jar包：</p><p><img src="image-20230622163816397.png" alt="image-20230622163816397"></p><p>那么为什么找不到呢？因为Maven会从本地仓库找对应的jar包，但是本地仓库又不存在该jar包，所以我们需要手动将maven_03_pojo项目安装到本地仓库即</p><p>可。</p><p>步骤6：将项目安装到本地仓库</p><p><img src="image-20230622164033568.png" alt="image-20230622164033568"></p><p>此时maven_02_ssm模块就可以编译成功了。</p><h4 id="抽取dao层"><a href="#抽取dao层" class="headerlink" title="抽取dao层"></a>抽取dao层</h4><p>步骤1：创建新模块并在项目中创建dao包</p><p><img src="image-20230622164526229.png" alt="image-20230622164526229"></p><p>这时候存在两个问题：</p><p>1）实体类Book类不存在：添加maven_03_pojo的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）Mybatis在dao层的增删改查注解无法识别：添加mybatis和mysql依赖</p><p><img src="image-20230622164827822.png" alt="image-20230622164827822"></p><p>步骤2：删除原项目(maven_02_ssm)的dao包，添加maven_04_dao的依赖</p><h4 id="分模块开发总结"><a href="#分模块开发总结" class="headerlink" title="分模块开发总结"></a>分模块开发总结</h4><p>1、创建Maven模块</p><p>2、书写模块代码</p><p>分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</p><p>3、通过maven指令安装模块到本地仓库(install 指令)</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>依赖指当前项目运行所需的jar，一个项目可以设置多个依赖。在其他项目中想要使用独立出来的这些模块，只需要在其pom.xml使用标签来进行jar包的引入即可。</p><p>依赖的格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--设置具体的依赖--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!--依赖所属群组id--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--依赖所属项目id--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--依赖版本号--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.24.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖传递与依赖冲突问题"><a href="#依赖传递与依赖冲突问题" class="headerlink" title="依赖传递与依赖冲突问题"></a>依赖传递与依赖冲突问题</h3><p><strong>依赖传递</strong></p><p>这个jar包下面还包含有其他的jar包：</p><p><img src="image-20230622165753892.png" alt="image-20230622165753892"></p><p>会发现有两个maven_03_pojo的依赖被加载到Dependencies中，那么maven_04_dao中的maven_03_pojo能不能使用呢？答案是可以的。</p><img src="image-20230622165918814.png" alt="image-20230622165918814" style="zoom:67%;" /><p>A依赖了B和C，B和C又分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递。</p><blockquote><p>依赖传递有直接依赖和间接依赖（相对的概念）：相对于A来说，A直接依赖B和C，间接依赖了D1,E1,G,F,D2和E2。</p></blockquote><p><strong>依赖冲突</strong></p><p>因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题。这里所说的<strong>依赖冲突</strong>是指项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。</p><p>情况一：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。</p><p><img src="image-20230622170145521.png" alt="image-20230622170145521"></p><p>情况二：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高。</p><p>情况三：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。</p><p>​    关于依赖冲突的规则我们不需要记住，可以在面板上查看详细的依赖关系包括版本信息等：</p><img src="image-20230622170357301.png" alt="image-20230622170357301" style="zoom:77%;" /><h3 id="可选依赖和排除依赖"><a href="#可选依赖和排除依赖" class="headerlink" title="可选依赖和排除依赖"></a>可选依赖和排除依赖</h3><p>maven_02_ssm 依赖了 maven_04_dao，maven_04_dao 依赖了 maven_03_pojo，因为现在有依赖传递，所以maven_02_ssm能够使用到maven_03_pojo的内容。但是如果说现在不想让maven_02_ssm依赖到maven_03_pojo，有哪些解决方案?</p><img src="image-20230622170710475.png" alt="image-20230622170710475" style="zoom:67%;" /><p><strong>方案一：可选依赖</strong></p><p>可选依赖指对外隐藏当前所依赖的资源。</p><p>对于我们的需求是：不想让maven_02_ssm依赖到maven_03_pojo。我们可以在maven_04_dao的pom.xml中在引入maven_03_pojo的时候，添加<code>optional</code>从而切断依赖传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方案二：排除依赖</strong></p><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。</p><p>前面我们已经通过可选依赖实现了阻断maven_03_pojo的依赖传递。对于排除依赖，则是maven_02_ssm项目中已经通过依赖传递用到了maven_03_pojo，此时我们需要做的是将其进行排除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.Lijiacheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>A依赖B，B依赖C，C通过依赖传递会被A使用到，现在要想办法让A不去依赖C：</p><ul><li><p>可选依赖是在B上设置<code>&lt;optional&gt;</code>， A不知道有C的存在；</p></li><li><p>排除依赖是在A上设置<code>&lt;exclusions&gt;</code>，A知道有C的存在，主动将其排除掉。</p></li></ul><h2 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h2><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><img src="image-20230622213742753.png" alt="image-20230622213742753" style="zoom:67%;" /><p>缺点一：分模块开发后，需要将这几个项目都安装到本地仓库，目前我们只能通过项目Maven面板的install来安装，并且需要安装多个，如果我们的项目足够多，那么一个个安装起来还是比较麻烦的。</p><p>缺点二：如果几个项目都已经安装成功，当ssm_pojo发生变化后，我们就得将ssm_pojo重新安装到maven仓库，但是为了确保我们对ssm_pojo的修改不会影响到其他项目模块，我们需要对所有的模块进行重新编译。</p><p>解决方案：所以我们就想能不能抽取一个项目，把所有的项目管理起来，以后我们要想操作这些项目，只需要操作这一个项目，这就用到了我们接下来要讲解的<strong>聚合</strong>——将多个模块组织成一个整体，同时进行项目构建的过程称为聚合。聚合工程通常是一个不具有业务功能的空工程（有且仅有一个pom文件）。</p><p>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</p><p>步骤1：创建一个空的Maven工程</p><p>步骤2：将项目的打包方式改为<strong>pom</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>目前我们接触到的项目打包方式有三种：</p><p>① jar：默认情况，说明该项目为java项目； ② war：说明该项目为web项目； ③ pom：说明该项目为聚合或继承项目。</p></blockquote><p>步骤3：pom.xml添加所要管理的项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置管理的模块名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤4：使用聚合统一管理项目</p><p><img src="image-20230623093529641.png" alt="image-20230623093529641"></p><p>测试发现，当maven_01_parent的compile被点击后，所有被其管理的项目都会被执行编译操作，这就是聚合工程的作用。</p><blockquote><p><strong>说明：</strong>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序，和配置的顺序无关。</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>接下来我们再来考虑多模块开发存在的另外一个问题，依赖的重复配置。</p><p>问题一：spring-webmvc、spring-jdbc在三个项目模块中都有出现，这样就出现了重复的内容；</p><p>问题二：spring-test只在部分项目模块中出现，而在某些项目模块中没有出现，这里是部分重复的内容；</p><p>问题三：我们使用的spring版本目前是5.2.24.RELEASE ,假如后期要想升级spring版本，所有跟Spring相关jar包都得被修改，涉及到的项目越多，维护成本越高。</p><p>面对上面的这些问题，我们就得用到接下来要学习的<strong>继承</strong>（简化配置、减少版本冲突）：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</p><p>步骤1：创建一个空Maven工程并将打包方式设置为<code>pom</code></p><p>步骤2：在子项目中设置其父项目</p><blockquote><p>java里面的继承，也是在子类声明它继承的父类。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可选项：设置父项目pom.xml位置路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤3：优化子项目共有依赖导入问题</p><p>1）将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中 </p><p>2）删除子项目中已经被抽取到父项目的pom.xml中的jar包，如在maven_02_ssm的pom.xml中将已经出现在父项目的jar包删除掉</p><p>将子项目中的公共jar包抽取到父工程中进行统一添加依赖，这样做的可以简化配置，并且当父工程中所依赖的jar包版本发生变化，所有子项目中对应的jar包版本也会跟着更新。</p><p>步骤4：优化子项目依赖版本问题</p><p>如果把所有用到的jar包都管理在父项目的pom.xml，看上去更简单些，但是这样就会导致有很多项目引入了过多自己不需要的jar包。</p><p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p><p>在父工程mavne_01_parent的pom.xml来定义依赖管理<code>&lt;dependencyManagement&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义依赖管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;dependencyManagement&gt;</code>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖。<font color="blue">子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定<code>&lt;version&gt;</code> </font>。</p><blockquote><p>这样做的好处就是当父工程dependencyManagement标签中的版本发生变化后，子项目中的依赖版本也会跟着发生变化。</p></blockquote><p><strong>继承总结</strong>：父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</p><p>1）将所有项目公共的jar包依赖提取到父工程的pom.xml中，子项目就可以不用重复编写，简化开发</p><p>2）将所有项目的jar包配置到父工程的dependencyManagement标签下，实现版本管理，方便维护</p><h3 id="聚合和继承的区别"><a href="#聚合和继承的区别" class="headerlink" title="聚合和继承的区别"></a>聚合和继承的区别</h3><h4 id="聚合和继承的区别-1"><a href="#聚合和继承的区别-1" class="headerlink" title="聚合和继承的区别"></a>聚合和继承的区别</h4><p>聚合用于快速构建项目，对项目进行管理；继承用于快速配置和管理子项目中所使用jar包的版本。</p><ul><li><p>聚合和继承的相同点</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul></li><li><p>聚合和继承的不同点</p><ul><li>聚合是在当前模块中配置关系<code>&lt;modules&gt;</code>，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系<code>&lt;parent&gt;</code>，父模块无法感知哪些子模块继承了自己</li></ul></li></ul><h4 id="IDEA构建聚合与继承工程"><a href="#IDEA构建聚合与继承工程" class="headerlink" title="IDEA构建聚合与继承工程"></a>IDEA构建聚合与继承工程</h4><p>步骤1：创建一个空的Maven项目，可以将项目中的src目录删除掉，这个项目作为聚合工程和父工程</p><p>步骤2：创建子项目，该项目可以继承并聚合父工程。</p><img src="image-20230623101441961.png" alt="image-20230623101441961" style="zoom:77%;" /><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>如果我们现在想更新Spring的版本，你会发现我们依然需要更新多个jar包的版本，这样的话还是有可能出现漏改导致程序出问题，而且改起来也是比较麻烦。我们可以参考咱们java基础所学习的变量，声明一个变量，在其他地方使用该变量，当变量的值发生变化后，所有使用变量的地方，就会跟着修改。</p><img src="image-20230623120509297.png" alt="image-20230623120509297" style="zoom:67%;" /><p>步骤1：父工程中定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.24.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤2：修改依赖的version</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    </span><br></pre></td></tr></table></figure><p>我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。当然除了将spring相关版本进行维护，我们可以将其他的jar包版本也进行抽取，这样就可以对项目中所有jar包的版本进行统一维护。</p><h3 id="配置文件的属性加载"><a href="#配置文件的属性加载" class="headerlink" title="配置文件的属性加载"></a>配置文件的属性加载</h3><p>想让Maven对于属性的管理范围能更大些，比如我们之前项目中的jdbc.properties，这个配置文件中的属性，能不能也来让Maven进行管理呢？</p><p>步骤1：父工程定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤2：jdbc.properties文件中引用属性</p><p>在jdbc.properties，将jdbc.url的值直接获取Maven配置的属性.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.url</span>=<span class="string">$&#123;jdbc.url&#125;</span></span><br></pre></td></tr></table></figure><p>步骤3：设置maven过滤文件范围</p><p>Maven在默认情况下是从当前项目的”src\main\resources”下读取文件进行打包。现在我们需要打包的资源文件是在maven_02_ssm下,需要我们通过配置来指定下具体的资源目录。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置maven过滤文件范围 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>../maven_02_ssm/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤4：测试是否生效</p><p>测试的时候，只需要将maven_02_ssm项目进行打包，然后观察打包结果中最终生成的内容是否为父工程中Maven配置的内容。</p><p><img src="image-20230623125438205.png" alt="image-20230623125438205"></p><p>如果不只是maven_02_ssm项目需要有属性被父工程管理，如果有多个项目需要配置，该如何实现呢？</p><p>方式一：使用多个<code>&lt;resource&gt;</code>标签在下面继续配置；</p><p>方式二：<code>$&#123;project.basedir&#125;</code>，当前项目所在目录。子项目继承了父项目， 相当于所有的子项目都添加了资源目录的过滤：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置maven过滤文件范围 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;directory&gt;../maven_02_ssm/src/main/resources&lt;/directory&gt;--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main.resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面我们所使用的都是Maven的自定义属性，除了<code>$&#123;project.basedir&#125;</code>，它属于Maven的内置系统属性。</p></blockquote><h2 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h2><h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><img src="image-20230623130112191.png" alt="image-20230623130112191" style="zoom:67%;" /><p>不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，要想实现不同环境之间的配置切换又该如何来实现呢？</p><p>Maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。</p><p>步骤1：父工程配置多个环境，并指定默认激活环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多开发环境配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开发环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设定是否为默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生产环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.2.2.2:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 测试环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.3.3.3:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然已经能够实现不同环境的切换，但是每次切换都是需要手动修改，如何来实现在不改变代码的前提下完成环境的切换呢?</p><p>步骤2：命令行实现环境切换（这里我反正是测试失败了。。。）</p><img src="image-20230623132355560.png" alt="image-20230623132355560" style="zoom:77%;" /><h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><p>前面在执行install指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行test，对于test来说有它存在的意义：可以确保每次打包或者安装的时候，程序的正确性。但是有时候，功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</p><p>方式一：IDEA工具</p><p><img src="image-20230623132550500.png" alt="image-20230623132550500"></p><p>方式二：命令行跳过测试</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn 指令 <span class="literal">-D</span> skipTests</span><br></pre></td></tr></table></figure><p>该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。</p><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><p>公司或者团队一般会搭建自己的私服，这里暂时先不展开实践了，就简单了解一下什么是私服以及配置私服的原理。</p><img src="image-20230623132904112.png" alt="image-20230623132904112" style="zoom:67%;" /><p>Maven的中央仓库不允许私人上传自己的jar包，那么自己搭建一个类似于中央仓库的东西，把自己的内容上传上去，其他人就可以从上面下载jar包使用。私服就是公司内部搭建的用于存储Maven资源的服务器，用于解决团队内部的资源共享与资源同步问题。</p><p>搭建Maven私服的方式有很多，其中一种使用量比较大的实现方式：Nexus。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Maven就是是专门为Java项目打造的管理和构建工具，它 提供了一套标准化的项目结构、提供了一套标准化的构建流程等等。&lt;/p&gt;</summary>
    
    
    
    <category term="Maven" scheme="https://kicheng.github.io/categories/Maven/"/>
    
    
  </entry>
  
  <entry>
    <title>03-SSM整合</title>
    <link href="https://kicheng.github.io/2023/06/19/03-SSM%E6%95%B4%E5%90%88/"/>
    <id>https://kicheng.github.io/2023/06/19/03-SSM%E6%95%B4%E5%90%88/</id>
    <published>2023-06-19T03:40:18.000Z</published>
    <updated>2023-06-21T10:55:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经把Mybatis、Spring和SpringMVC三个框架进行了学习，今天主要的内容就是把这三个框架整合在一起完成我们的业务功能开发。                                                             </p><span id="more"></span><h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>1、创建Maven的Web工程</p><p>2、在pom.xml中导入SSM需要的依赖jar包：</p><p>​    ① SpringMVC的核心依赖<code>spring-webmvc</code></p><p>​    ② Spring和jdbc、mybatis的依赖<code>spring-test</code>, <code>spring-jdbc</code> , <code>mybatis-spring</code>, <code>mybatis</code></p><blockquote><p>这里要注意Spring和jdk的版本兼容问题：当使用java8时，webmvc、test、jdbc保持版本一致且5.2.x以下的版本，mybatis-spring要保持2.x的版本。</p></blockquote><p>​    ③ 数据库<code>mysql</code>和数据库连接池<code>Druid</code></p><p>​    ④ Servlet（使用java8时要用4.0.1以下的版本）</p><p>​    ⑤ 其他：<code>jackson</code>自动解析json格式数据，<code>juint</code>测试依赖</p><p>3、编写Web项目的入口配置类ServletInitConfig，实现AbstractAnnotationConfigDispatcherServletInitializer并重写以下方法：</p><p>​    ① getRootConfigClasses() ：返回Spring的配置类-&gt;需要<strong>SpringConfig</strong>配置类</p><p>​    ② getServletConfigClasses() ：返回SpringMVC的配置类-&gt;需要<strong>SpringMvcConfig</strong>配置类</p><p>​    ③ getServletMappings() : 设置SpringMVC请求拦截路径规则</p><p>​    ④ getServletFilters() （这个要记住函数名因为没有快捷override方式）：设置过滤器，解决POST请求中文乱码问题</p><h4 id="SSM整合-1"><a href="#SSM整合-1" class="headerlink" title="SSM整合"></a>SSM整合</h4><p>1、SpringConfig</p><p>​    ① 标识该类为配置类 <code>@Configuration</code></p><p>​    ② 扫描Service所在的包 <code>@ComponentScan</code></p><p>​    ③ 在Service层要管理事务 <code>@EnableTransactionManagement</code></p><p>​    ④ 读取外部的properties配置文件 <code>@PropertySource</code></p><p>​    ⑤ 整合Mybatis需要引入Mybatis相关配置类 <code>@Import</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.Lijiacheng.service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MybatisConfig.class, JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        1) 第三方数据源配置类 JdbcConfig：构建DataSource数据源DruidDataSouroce，需要注入数据库连接四要素，<code>@Bean</code>和<code>@Value</code>注解。构建平台事务管理器DataSourceTransactionManager，<code>@Bean</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建jdbc事务管理</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        2) Mybatis配置类 MybatisConfig：构建SqlSessionFactoryBean并设置别名扫描与数据源，<code>@Bean</code>注解。构建MapperScannerConfigurer并设置DAO层的包扫描，<code>@Bean</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setTypeAliasesPackage(<span class="string">&quot;com.Lijiacheng.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.Lijiacheng.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、SpringMvcConfig</p><p>​    ① 标识该类为配置类 <code>@Configuration</code></p><p>​    ② 扫描Controller所在的包 <code>@ComponentScan</code></p><p>​    ③ 开启SpringMVC注解支持 <code>@EnableWebMvc</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h4><p>1、创建数据库表</p><p>2、根据数据库表创建对应的模型类</p><p>3、通过Dao层完成数据库表的增删改查（接口+自动代理）</p><p>4、编写Service层（Service接口+实现类）：<code>@Service</code>, <code>@Transactional</code>；整合Junit对业务层进行单元测试<code>@RunWith</code>, <code>@ContextConfiguration</code>, <code>@Test</code></p><p>5、编写Controller层：<code>@RestController</code>；接收请求(<code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>)；接收数据(<code>@RequestParam</code>, <code>@PathVariable</code>, <code>@RequestBody</code>)；转发业务层<code>@Autowired</code></p><h3 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h3><p>步骤1：创建项目包结构</p><p>​                                                             <img src="image-20230619215547658.png" alt="image-20230619215547658" style="zoom:87%;" />    </p><p>步骤2：创建SpringConfig配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.Lijiacheng.service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MybatisConfig.class, JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="comment">// 创建事务管理</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤3：创建JdbcConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建jdbc事务管理</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4：创建MybatisConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setTypeAliasesPackage(<span class="string">&quot;com.Lijiacheng.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.Lijiacheng.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤5：创建jdbc.properties</p><p>在resources下提供jdbc.properties，设置数据库连接四要素</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssm_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">xxxxxxx</span></span><br></pre></td></tr></table></figure><p>步骤6：创建SpringMvcConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤7：创建Web项目入口ServletInitConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters()&#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p><p>Web项目入口配置类ServletInitConfig → SpringConfig配置类：扫描Service层、导入外部properties、导入JdbcConfig、MybatisConfig等配置类</p><p>​                                                                  → SpringMvcConfig配置类：扫描Controller层                                                         </p></blockquote><h3 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h3><p>步骤1：编写pojo模型类</p><p>步骤2：编写Dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_book values(null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_book set type = #&#123;type&#125;, name = #&#123;name&#125;, description = #&#123;description&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤3：编写Service接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ======================================================== */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bookDao在Service中注入的会提示一个红线提示：这是因为BookDao是一个接口，没有实现类，接口是不能创建对象的，所以最终注入的应该是代理对象。而代理对象是由Spring的IOC容器来创建管理的，IOC容器又是在Web服务器启动的时候才会创建，没有找到适合的类注入所以会提示错误提示。</p><p><img src="image-20230619221050923.png" alt="image-20230619221050923"></p><p>不去理会当然可以正常运行程序，但作为追求完美的强迫症程序员，可以设置IDEA的错误提示级别：</p><p><img src="image-20230619221318810.png" alt="image-20230619221318810"></p><p>在这里取消勾选，或者将其降级为warning级别都可以：</p><p><img src="image-20230619221402465.png" alt="image-20230619221402465"></p><p>步骤4：编写Controller类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>对于图书模块的增删改查就已经完成了编写，接下来我们就先把业务层Service的代码使用Spring整合Junit进行单元测试：</p><p>步骤1：新建测试类</p><p>步骤2：注入Service类</p><p>步骤3：编写测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Book&gt; books = bookService.getAll();</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service层的代码测试成功，结果就不在这放嘞，接着往下看。</p><h3 id="PostMan测试"><a href="#PostMan测试" class="headerlink" title="PostMan测试"></a>PostMan测试</h3><p><strong>新增</strong></p><p>前端发送新增请求：</p><img src="image-20230619222757536.png" alt="image-20230619222757536" style="zoom:87%;" /><p>后台数据库：</p><p><img src="image-20230619223001724.png" alt="image-20230619223001724"></p><p><strong>修改</strong></p><p>前端发送修改请求：</p><img src="image-20230619222849481.png" alt="image-20230619222849481" style="zoom:87%;" /><p>后台数据库：</p><p><img src="image-20230619223124913.png" alt="image-20230619223124913"></p><p><strong>删除</strong></p><p>前端发送删除请求：</p><img src="image-20230619223213419.png" alt="image-20230619223213419" style="zoom:87%;" /><p>后台数据库：</p><p><img src="image-20230619223300861.png" alt="image-20230619223300861"></p><p><strong>查询</strong></p><p>前端发送查询请求：</p><img src="image-20230619223340795.png" alt="image-20230619223340795" style="zoom:67%;" /><img src="image-20230619223400561.png" alt="image-20230619223400561" style="zoom:67%;" /><h2 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h2><h3 id="表现层与前端数据传输协议定义"><a href="#表现层与前端数据传输协议定义" class="headerlink" title="表现层与前端数据传输协议定义"></a>表现层与前端数据传输协议定义</h3><p>在Controller层增删改返回给前端的是boolean类型数据、在Controller层查询单个返回给前端的是对象、在Controller层查询所有返回给前端的是集合对象……对于前端来说，如果后台能够返回一个统一的数据结果，前端在解析的时候就可以按照一种方式进行解析，开发就会变得更加简单。</p><p>所以我们就想能不能将返回结果的数据进行统一，具体如何来做，大体的思路为:</p><ul><li><p>为了封装返回的结果数据：创建结果模型类，封装数据到data属性中</p></li><li><p>为了封装返回的数据是何种操作及是否操作成功：封装操作结果到code属性中</p></li><li><p>操作失败后为了封装返回的错误信息：封装特殊消息到message(msg)属性中</p></li></ul><img src="image-20230621101144401.png" alt="image-20230621101144401" style="zoom:77%;" /><p>解决方案是我们可以设置统一数据返回结果类，Result类名及类中的字段并不是固定的，可以根据需要自行增减提供若干个构造方法，方便操作：</p><h3 id="表现层与前端数据传输协议实现"><a href="#表现层与前端数据传输协议实现" class="headerlink" title="表现层与前端数据传输协议实现"></a>表现层与前端数据传输协议实现</h3><p>步骤1：创建Result类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="comment">// 描述统一格式中的数据</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">  <span class="comment">// 描述统一格式中的编码</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">  <span class="comment">// 描述统一格式中的消息，可选属性</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2：定义返回码Code类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤3：修改Controller类的返回值为Result对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.save(book);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.update(book);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getById(id);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> book != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> book != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;未查询到信息，请重试&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, book, msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Book&gt; books = bookService.getAll();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> books != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> books != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;未查询到信息，请重试&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, books, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的返回结果就已经能以一种统一的格式返回给前端。前端根据返回的结果，先从中获取code，根据code判断，如果成功则取data属性的值；如果失败则取msg中的值做提示（随便举一个根据id查询的例子）：</p><img src="image-20230621102138599.png" alt="image-20230621102138599" style="zoom:87%;" /><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><h3 id="异常处理概述"><a href="#异常处理概述" class="headerlink" title="异常处理概述"></a>异常处理概述</h3><p>当我们在表现Controller层的getById方法中手动添加一个异常，可以发现在前端发送请求时出现接收到的信息和之前约定的数据格式不一致的问题：</p><img src="image-20230620101102095.png" alt="image-20230620101102095" style="zoom: 77%;" /><p>我们在开发的过程中在任何一个位置都可能会出现异常。</p><p>框架内部抛出的异常：因使用不合规导致</p><p>数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）</p><p>业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）</p><p>表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）</p><p>工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）</p><blockquote><p>各个层级均出现异常，异常处理代码书写在哪一层？<strong>所有的异常均抛出到表现层进行处理</strong></p><p>异常的种类很多，表现层如何将所有的异常都处理到呢？<strong>异常分类</strong></p><p>表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决？<strong>AOP</strong></p></blockquote><p>针对上述的问题，SpringMVC已经为我们提供了一套<strong>异常处理器</strong>的解决方案，集中的统一的处理项目中出现的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">666</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理器的使用"><a href="#异常处理器的使用" class="headerlink" title="异常处理器的使用"></a>异常处理器的使用</h3><p>步骤1：创建异常处理器类</p><p><font color="blue">要确保SpringMvcConfig能够扫描到异常处理器类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘿嘿，异常你往哪里跑！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2：让程序抛出异常</p><p>步骤3：运行程序测试（异常已经被拦截并执行了doException方法）</p><p><img src="image-20230620102849723.png" alt="image-20230620102849723"></p><p>步骤4：异常处理器类返回结果给前端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;嘿嘿，异常你往哪里跑！&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">666</span>, <span class="literal">null</span>, <span class="string">&quot;呵呵，异常你往哪里跑！&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230620103149866.png" alt="image-20230620103149866"></p><p>就算后台执行的过程中抛出异常，最终也能按照我们和前端约定好的数据格式返回给前端。</p><blockquote><p><code>@RestControllerAdvice</code>注解：此注解自带<code>@ResponseBody</code>注解与<code>@Component</code>注解，REST风格的(异常处理)控制器类。</p><p><code>@ExceptionHandler</code>注解：专用于异常处理的控制器<strong>方法</strong>上方，出现异常后终止原始控制器执行，并转入当前方法执行。</p></blockquote><h3 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>因为异常的种类有很多，如果每一个异常都对应一个<code>@ExceptionHandler</code>，那得写多少个方法来处理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类。</p><ul><li><p>业务异常(BusinessException)</p><p>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串；</p><p>不规范的用户行为操作产生的异常，如用户故意传递错误数据。</p></li><li><p>系统异常(SystemException)</p></li></ul><p>​        项目运行过程中可预计但无法避免的异常，比如数据库或服务器宕机。</p><ul><li>其他异常(Exception)</li></ul><p>​        编程人员未预期到的异常，如:用到的文件不存在。</p><p>将异常分类以后，针对不同类型的异常，要提供具体的解决方案。</p><h4 id="异常解决方案"><a href="#异常解决方案" class="headerlink" title="异常解决方案"></a>异常解决方案</h4><ul><li>业务异常（BusinessException）</li></ul><p>​    发送对应消息传递给用户，提醒规范操作（大家常见的就是提示用户名已存在或密码格式不正确等）</p><ul><li>系统异常（SystemException）</li></ul><p>​    发送固定消息传递给用户，安抚用户（系统繁忙，请稍后再试）</p><p>​    发送特定消息给运维人员，提醒维护（可以发送短信、邮箱或者是公司内部通信软件）</p><p>​    记录日志（发消息和记录日志对用户来说是不可见的，属于后台程序）</p><ul><li>其他异常（Exception）</li></ul><p>​    发送固定消息传递给用户，安抚用户</p><p>​    发送特定消息给编程人员，提醒维护（纳入预期范围内）</p><p>​    记录日志（一般是程序没有考虑全，比如未做非空校验等）</p><h4 id="异常解决方案的具体实现"><a href="#异常解决方案的具体实现" class="headerlink" title="异常解决方案的具体实现"></a>异常解决方案的具体实现</h4><blockquote><p>思路：</p><ol><li><p>先通过自定义异常，完成BusinessException和SystemException的定义</p></li><li><p>将其他异常包装成自定义异常类型</p></li><li><p>在异常处理器类中对不同的异常进行处理</p></li></ol></blockquote><p>步骤1：自定义异常类（新建一个exception包目录）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code, String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>让自定义异常类继承RuntimeException的好处是，后期在抛出这两个异常的时候，就不用try…catch…或throws了。</p><p>自定义异常类中添加code属性的原因是为了更好的区分异常是来自哪个业务的。</p></blockquote><p>步骤1.5：在Code类中再新增需要的属性</p><p>步骤2：将其他异常包装成自定义异常</p><p>具体的包装方式有两种：</p><p>方式一：try{…}catch(){…}在catch中重新throw我们自定义异常即可；</p><p>方式二：直接throw自定义异常即可；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//模拟业务异常，包装成自定义异常</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(Code.BUSINESS_ERR, <span class="string">&quot;请不要用你的技术挑战我的饭碗！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟系统异常，将可能出现的异常进行包装，转换成自定义异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(Code.SYSTEM_TIMEOUT_ERR,<span class="string">&quot;服务器访问超时，请重试！&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getById(id);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> book != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> book != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;未查询到信息，请重试&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, book, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤3：处理器类中处理自定义异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// @ExceptionHandler用于设置当前处理器类对应的异常类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(SystemException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doSystemException</span><span class="params">(SystemException ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">// 发送消息给运维</span></span><br><span class="line">        <span class="comment">// 发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ex.getCode(), <span class="literal">null</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doBusinessException</span><span class="params">(BusinessException ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ex.getCode(), <span class="literal">null</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        <span class="comment">// 发送消息给运维</span></span><br><span class="line">        <span class="comment">// 发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(Code.SYSTEM_UNKNOWN_ERR, <span class="literal">null</span>, <span class="string">&quot;系统繁忙，请稍后再试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4：进行异常测试</p><p>在根据id查询中，如果查询请求id为1报错BusinessException错，如果id不为1则报SystemException错。</p><img src="image-20230620210737395.png" alt="image-20230620210737395" style="zoom:77%;" /><p>对于异常我们就已经处理完成了。不管后台哪一层抛出异常，都会以我们与前端约定好的方式进行返回，前端只需要把信息获取到，根据返回的正确与否来展示不同的内容即可。</p><p><strong>小结</strong></p><p>项目中的异常处理方式为：</p><img src="image-20230620210909413.png" alt="image-20230620210909413" style="zoom:67%;" /><h2 id="前后台协议联调"><a href="#前后台协议联调" class="headerlink" title="前后台协议联调"></a>前后台协议联调</h2><img src="image-20230620221704513.png" alt="image-20230620221704513" style="zoom:87%;" /><p>因为添加了静态资源，SpringMVC会拦截，所以需要将静态资源进行放行：</p><blockquote><p><strong>复习一下如何将静态资源放行？</strong></p><p>1）新建SpringMvcSupport配置类，继承WebMvcConfigurationSupport，重写addResourceHandlers方法。</p><p>2）在SpringMvcConfig中扫描SpringMvcSupport</p></blockquote><p><strong>列表功能</strong></p><p>页面加载完后发送异步请求到后台获取列表数据进行展示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//列表</span><br><span class="line">getAll() &#123;</span><br><span class="line">    // 发送ajax请求</span><br><span class="line">    axios.get(&quot;/books&quot;).then((res)=&gt;&#123;</span><br><span class="line">      this.dataList = res.data.data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><img src="image-20230620230749389.png" alt="image-20230620230749389" style="zoom:67%;" /><p><strong>添加功能</strong></p><p>“新建”按钮上绑定了@click=”handleCreate()”方法；在method中找到handleCreate方法，方法中打开”新增“面板。</p><p>”确定”按钮上绑定了@click=”handleAdd()”方法；在method中找到handleAdd方法，在方法中发送请求和数据，响应成功后将新增面板关闭并重新查询数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//弹出添加窗口</span><br><span class="line">handleCreate() &#123;</span><br><span class="line">    this.dialogFormVisible = true;</span><br><span class="line">&#125;,</span><br><span class="line">//添加</span><br><span class="line">handleAdd () &#123;</span><br><span class="line">    //发送ajax请求</span><br><span class="line">    // this.formData是表单中的数据，最后是一个json数据</span><br><span class="line">    axios.post(&quot;/books&quot;, this.formData).then((res)=&gt;&#123;</span><br><span class="line">        this.dialogFormVisible = false;  // 关闭弹窗</span><br><span class="line">        this.getAll();  // 刷新显示全部</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="image-20230620231613537.png" alt="image-20230620231613537"></p><p>但是我们发现在新增成功后，再次点击新增按钮会发现之前的数据还存在，这个时候就需要在新增的时候将表单内容清空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//弹出添加窗口</span><br><span class="line">handleCreate() &#123;</span><br><span class="line">    this.dialogFormVisible = true;</span><br><span class="line">    this.resetForm();</span><br><span class="line">&#125;,</span><br><span class="line">//重置表单</span><br><span class="line">resetForm() &#123;</span><br><span class="line">    this.formData = &#123;&#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>添加功能状态处理</strong></p><p>新增成功是关闭面板，重新查询数据，但是我们还需要考虑新增失败的异常情况：即在handlerAdd方法中根据后台返回的数据来进行不同的处理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//添加</span><br><span class="line">handleAdd () &#123;</span><br><span class="line">    //发送ajax请求</span><br><span class="line">    axios.post(&quot;/books&quot;, this.formData).then((res)=&gt;&#123;</span><br><span class="line">        // 如果请求成功，则关闭弹层，显示数据</span><br><span class="line">        if(res.data.code == 20011)&#123;</span><br><span class="line">            this.dialogFormVisible = false;  // 关闭弹窗</span><br><span class="line">            this.$message.success(&quot;添加成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果请求失败，则弹窗提醒</span><br><span class="line">        else if(res.data.code == 20010)&#123;</span><br><span class="line">            this.$message.error(&quot;添加失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他的未知异常</span><br><span class="line">        else&#123;</span><br><span class="line">            this.$message.error(res.data.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).finally(()=&gt;&#123;</span><br><span class="line">        this.getAll();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><img src="image-20230620235136525.png" alt="image-20230620235136525" style="zoom:77%;" /><p><strong>修改功能</strong></p><p>“编辑”按钮绑定了@click=”handleUpdate(scope.row)”；在method的handleUpdate方法中发送异步请求根据ID查询图书信息。根据后台返回的结果，判断是否查询成功：如果查询成功打开修改面板回显数据，如果失败提示错误信息。</p><p>修改完成后“确定”按钮绑定了@click=”handleEdit()”，在method的handleEdit方法中发送异步请求提交修改数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//弹出编辑窗口</span><br><span class="line">handleUpdate(row) &#123;</span><br><span class="line">    axios.get(&quot;/books/&quot; + row.id).then((res)=&gt;&#123;</span><br><span class="line">        // 展示弹层，加载数据</span><br><span class="line">        if(res.data.code == 20041)&#123;</span><br><span class="line">            this.formData = res.data.data;</span><br><span class="line">            this.dialogFormVisible4Edit = true;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            this.$message.error(res.data.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">//编辑</span><br><span class="line">handleEdit() &#123;</span><br><span class="line">    axios.put(&quot;/books&quot;, this.formData).then((res)=&gt;&#123;</span><br><span class="line">        // 如果操作成功，关闭弹层，显示数据</span><br><span class="line">        if(res.data.code == 20031)&#123;</span><br><span class="line">            this.dialogFormVisible4Edit = false;</span><br><span class="line">            this.$message.error(&quot;修改成功！&quot;);</span><br><span class="line">        &#125; else if(res.data.code == 20030)&#123;</span><br><span class="line">            this.$message.error(&quot;修改失败！&quot;);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            this.$message.error(res.data.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).finally(()=&gt;&#123;</span><br><span class="line">        this.getAll();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>删除功能</strong></p><p>”删除“按钮上绑定了@click=”handleDelete(scope.row)”，method的handleDelete方法弹出提示框。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 删除</span><br><span class="line">handleDelete(row) &#123;</span><br><span class="line">    this.$confirm(&quot;此操作永久删除当前数据，是否继续？&quot;,&quot;提示&quot;,&#123;</span><br><span class="line">        type:&#x27;info&#x27;</span><br><span class="line">    &#125;).then(()=&gt;&#123;</span><br><span class="line">        //2.做删除业务</span><br><span class="line">        axios.delete(&quot;/books/&quot;+row.id).then((res)=&gt;&#123;</span><br><span class="line">            if(res.data.code == 20021)&#123;</span><br><span class="line">                this.$message.success(&quot;删除成功&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                this.$message.error(&quot;删除失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).finally(()=&gt;&#123;</span><br><span class="line">            this.getAll();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">        //3.取消删除</span><br><span class="line">        this.$message.info(&quot;取消删除操作&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h3><img src="image-20230621112011258.png" alt="image-20230621112011258" style="zoom:77%;" /><p>(1) 浏览器发送一个请求会先到Tomcat的web服务器；</p><p>(2) Tomcat服务器接收到请求以后，会去判断请求的是静态资源还是动态资源；</p><p>(3) 如果是静态资源，会直接到Tomcat的项目部署目录下去直接访问；</p><p>(4) 如果是动态资源，就需要交给项目的后台代码进行处理；</p><p>(5) 在找到具体的方法之前，我们可以去配置过滤器(可以配置多个)，按照顺序进行执行；</p><p>(6) 然后进入到到中央处理器(SpringMVC中的内容)，SpringMVC会根据配置的规则进行拦截；</p><p>(7) 如果满足规则，则进行处理，找到其对应的controller类中的方法进行执行，完成后返回结果；</p><p>(8) 如果不满足规则，则不进行处理；</p><p>(9) 这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现？——拦截器</p><p><strong>拦截器</strong>（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行：在指定的方法调用前后执行预先设定的代码来阻止原始方法的执行。</p><blockquote><p>SpringMVC的拦截器和Servlet的过滤器的区别：</p><p>归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术；</p><p>拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强。</p></blockquote><h3 id="拦截器入门案例"><a href="#拦截器入门案例" class="headerlink" title="拦截器入门案例"></a>拦截器入门案例</h3><p><strong>环境准备</strong></p><img src="image-20230621180705381.png" alt="image-20230621180705381" style="zoom:87%;" /><h4 id="拦截器开发"><a href="#拦截器开发" class="headerlink" title="拦截器开发"></a>拦截器开发</h4><p>步骤1：在controller表现层创建拦截器类</p><p>让类实现HandlerInterceptor接口，重写接口中的三个方法。<strong>同时要注意Interceptor类必须受Spring容器控制和被SpringMVC扫描到。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 注意当前类必须受Spring容器控制</span></span><br><span class="line"><span class="comment">// 定义拦截器类，实现HandlerInterceptor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2：配置拦截器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(<span class="string">&quot;/books&quot;</span>, <span class="string">&quot;/books/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动装配前面创建的拦截器类，在Support配置中配置拦截的路径。</p><p>步骤3：SpringMvcConfig添加SpringMvcSupport包(config包下)扫描</p><blockquote><p>当拦截器拦截的路径是(“/books”)时，则发送<a href="http://localhost/books/100%E4%BC%9A%E5%8F%91%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B2%A1%E6%9C%89%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C">http://localhost/books/100会发现拦截器没有被执行，</a> 因为没有匹配上，想要拦截则要设置”/books/*”。</p></blockquote><p>当有拦截器后，请求会先进入preHandle方法，如果方法返回true，则放行继续执行后面的handle（controller的方法）和后面的方法；如果返回false，则直接跳过后面方法的执行。</p><img src="image-20230621182504009.png" alt="image-20230621182504009" style="zoom:87%;" /><p>（可选）步骤4：简化SpringMvcSupport的编写</p><p>在SpringMvcConfig中实现WebMvcConfigurer接口后面就不用写SpringMvcSupport配置类了，但具有一定的侵入性。</p><h3 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h3><p><strong>前置处理方法</strong></p><p>request：请求对象</p><p>response：响应对象</p><p>handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装</p><p>使用request对象可以获取请求数据中的内容，如获取请求头的Content-Type（<font color="blue">要使用post请求</font>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;preHandle...&quot;</span> + contentType);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用handler参数，可以获取方法的相关信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">hm</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> hm.getMethod().getName();  <span class="comment">//可以获取方法的名称</span></span><br><span class="line">    System.out.println(<span class="string">&quot;preHandle...&quot;</span> + contentType + <span class="string">&quot;, &quot;</span> + methodName);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后置处理方法</strong></p><p>原始方法运行后运行，如果原始方法被拦截，则不执行。</p><p>modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整。因为现在都是返回json数据，所以该参数的使用率不高。</p><p><strong>完成处理方法</strong></p><p>拦截器最后执行的方法，无论原始方法是否执行。</p><p>ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理。因为现在已经有全局异常处理器类，所以该参数的使用率也不高。</p><p><strong>总结</strong></p><p>这三个方法中，最常用的是<strong>preHandle</strong>，在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回true放行，不满足则返回false拦截。</p><h3 id="拦截器链配置"><a href="#拦截器链配置" class="headerlink" title="拦截器链配置"></a>拦截器链配置</h3><p>步骤1：创建多个拦截器类ProjectInterceptor1、ProjectInterceptor2…</p><p>步骤2：配置拦截器链</p><p>拦截器执行的顺序是和配置顺序有关：先进后出（preHandle是与配置顺序相同，必定运行的）。</p><p>执行过程：当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行；当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作，见下图所示：</p><img src="image-20230621185149653.png" alt="image-20230621185149653" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;前面我们已经把Mybatis、Spring和SpringMVC三个框架进行了学习，今天主要的内容就是把这三个框架整合在一起完成我们的业务功能开发。                                                             &lt;/p&gt;</summary>
    
    
    
    <category term="SpringMVC" scheme="https://kicheng.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>02-RESTful开发</title>
    <link href="https://kicheng.github.io/2023/06/13/02-RESTful%E5%BC%80%E5%8F%91/"/>
    <id>https://kicheng.github.io/2023/06/13/02-RESTful%E5%BC%80%E5%8F%91/</id>
    <published>2023-06-13T03:18:31.000Z</published>
    <updated>2023-06-20T15:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>REST（Representational State Transfer），表现形式状态转换，它是一种软件架构风格，听不懂很正常。说通俗点就是用URL定位资源，用HTTP动词（GET, POST, DELETE, PUT）描述操作的一种开发方式。</p><span id="more"></span><h2 id="REST简介"><a href="#REST简介" class="headerlink" title="REST简介"></a>REST简介</h2><p>当我们想表示一个网络资源的时候，可以使用两种方式：</p><p>（1）传统风格资源描述形式</p><p>​    ① <a href="http://localhost/user/getById?id=1">http://localhost/user/getById?id=1</a> 查询id为1的用户信息</p><p>​    ② <a href="http://localhost/user/saveUser">http://localhost/user/saveUser</a> 保存用户信息</p><p>（2）REST风格描述形式</p><p>​    ① <a href="http://localhost/users/1">http://localhost/users/1</a> </p><p>​    ② <a href="http://localhost/users">http://localhost/users</a></p><p>传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全，因为会程序的人读取了你的请求url地址，就大概知道该url实现的是一个什么样的操作。</p><p>所以REST的优点有:</p><ul><li><p>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</p></li><li><p>书写简化</p></li></ul><p>那么对于REST来说，一个相同的url地址即可以是新增也可以是修改或者查询，那么到底我们该如何区分该请求到底是什么操作呢?</p><p>按照REST风格访问资源时使用的<strong>行为动作</strong>（一共有8种，常用的只有以下4种）区分对资源进行了何种操作：</p><ul><li><p><a href="http://localhost/users">http://localhost/users</a> 查询全部用户信息 <code>GET</code>（查询）</p></li><li><p><a href="http://localhost/users/1">http://localhost/users/1</a> 查询指定用户信息 <code>GET</code>（查询）</p></li><li><p><a href="http://localhost/users">http://localhost/users</a> 添加用户信息 <code>POST</code>（新增/保存）</p></li><li><p><a href="http://localhost/users">http://localhost/users</a> 修改用户信息 <code>PUT</code>（修改/更新）</p></li><li><p><a href="http://localhost/users/1">http://localhost/users/1</a> 删除用户信息 <code>DELETE</code>（删除）</p></li></ul><p>按照不同的请求方式代表不同的操作类型：发送GET请求是用来做查询；发送POST请求是用来做新增；发送PUT请求是用来做修改；发送DELETE请求是用来做删除。</p><blockquote><p>REST提供了对应的架构方式，按照这种架构设计项目可以降低开发的复杂性，提高系统的可伸缩性。</p><p>上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范。REST中规定GET/POST/PUT/DELETE针对的是查询/新增/修改/删除，但是我们如果非要用GET请求做删除，这点在程序上运行是可以实现的，但是如果绝大多数人都遵循这种风格，你写的代码让别人读起来就有点莫名其妙了。</p></blockquote><p>根据REST风格对资源进行访问称为<strong>RESTful</strong>，所以可以说以后都是基于RESTful来进行开发的。</p><h2 id="RESTful入门案例"><a href="#RESTful入门案例" class="headerlink" title="RESTful入门案例"></a>RESTful入门案例</h2><p><strong>环境准备</strong></p><img src="image-20230618093614185.png" alt="image-20230618093614185" style="zoom:87%;" /><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>将之前的增删改查替换成RESTful开发方式：</p><ul><li><p>之前不同的请求有不同的路径，现在要将其修改成统一的请求路径</p><p>修改前：新增: /save ，修改: /update，删除 /delete …</p><p>修改后：增删改查: /users</p></li><li><p>根据GET查询、POST新增、PUT修改、DELETE删除对方法的请求方式进行限定</p></li></ul><h3 id="修改RESTful风格"><a href="#修改RESTful风格" class="headerlink" title="修改RESTful风格"></a>修改RESTful风格</h3><p><strong>新增</strong></p><p>请求路径更改为<code>/users</code>，并且使用method属性限定该方法的访问方式为POST：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置当前请求方法为POST，表示REST风格中的添加操作</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;user save...&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>对于RESTful开发，如何携带数据参数？</p><p>前端发送请求的时候使用：<a href="http://localhost/users/1">http://localhost/users/1</a> ，路径中的1就是我们想要传递的参数。</p><p>后端获取参数，需要做如下修改：① 修改<code>@RequestMapping</code>的value属性，将其中修改为<code>/users/&#123;id&#125;</code>，目的是和路径匹配；② 在方法的形参前添加<code>@PathVariable</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前请求方法为DELETE，表示REST风格中的删除操作</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//    public String delete(@PathVariable(&quot;id&quot;) Integer userid)&#123;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete...&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果方法形参的名称和路径{}中的值不一致：</p><img src="image-20230618112603915.png" alt="image-20230618112603915" style="zoom:67%;" /><p>如果有多个参数需要传递该如何编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id,<span class="meta">@PathVariable</span> String name)</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置当前请求方法为PUT，表示REST风格中的修改操作</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.PUT)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;user update...&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user update&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>复习一下：<font color="red">只有在请求参数是json格式的时候，才需要在control方法的形参前加<code>@RequestBody</code>注解。</font></p></blockquote><img src="image-20230618113323094.png" alt="image-20230618113323094" style="zoom:77%;" /><p><strong>根据ID查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置当前请求方法为GET，表示REST风格中的查询操作</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;user getById...&quot;</span> + id);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user getById&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>查询全部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.GET)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;user getAll...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user getAll&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="RESTful入门开发总结"><a href="#RESTful入门开发总结" class="headerlink" title="RESTful入门开发总结"></a>RESTful入门开发总结</h3><ul><li>设定Http请求动作(method动词)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;&quot;,method = RequestMethod.POST|GET|PUT|DELETE)</span></span><br></pre></td></tr></table></figure><ul><li>设定请求参数(路径变量)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@ReponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三大接收参数<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>：</strong></p><p>区别：</p><p>(1) <code>@RequestParam</code>用于接收url地址传参或表单传参；</p><p>(2) <code>@RequestBody</code>用于接收json数据；</p><p>(3) <code>@PathVariable</code>用于接收路径参数，使用参数名称描述路径参数；</p><p>应用：</p><p>(1) 如果发送非json格式数据，选用<code>@RequestParam</code>接收请求参数；</p><p>(2) 后期开发中，发送请求参数超过1个时，以json格式为主，<code>@RequestBody</code>应用较广；</p><p>(3) 采用RESTful进行开发，当参数数量较少时，例如1个，可以采用<code>@PathVariable</code>接收请求路径变量，通常用于传递id值；</p><h2 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a>RESTful快速开发</h2><p>简化前面RESTful入门开发的繁琐流程：</p><img src="image-20230618150323271.png" alt="image-20230618150323271" style="zoom:67%;" /><ul><li><p>每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高：将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。</p></li><li><p>每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高：使用<code>@GetMapping</code> <code>@PostMapping</code> <code>@PutMapping</code> <code>@DeleteMapping</code>代替。 </p></li><li><p>每个方法响应json都需要加上@ResponseBody注解，重复性太高：将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能；使用<code>@RestController</code>注解替换@Controller与@ResponseBody注解，简化书写。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save...&quot;</span> + book);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book delete...&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book update...&quot;</span> + book);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book update&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book getById...&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book getById&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book getAll...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book getAll&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RESTful案例"><a href="#RESTful案例" class="headerlink" title="RESTful案例"></a>RESTful案例</h2><p>此次案例的重点是在SpringMVC中如何使用RESTful实现前后台交互，所以本案例并没有和数据库进行交互，所有数据使用假数据来完成开发。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求一：图书列表查询，从后台返回数据，将数据展示在页面上。</p><p>需求二：新增图书，将新增图书的数据传递到后台，并在控制台打印。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><img src="image-20230618161050752.png" alt="image-20230618161050752" style="zoom:77%;" /><h3 id="后台接口开发"><a href="#后台接口开发" class="headerlink" title="后台接口开发"></a>后台接口开发</h3><p>步骤1：编写Controller类并使用RESTful进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="comment">// 查询全部</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 不与数据库进行交互，这里使用假数据</span></span><br><span class="line">        ArrayList&lt;Book&gt; bookList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book1.setName(<span class="string">&quot;C# primer&quot;</span>);</span><br><span class="line">        book1.setType(<span class="string">&quot;编程图书&quot;</span>);</span><br><span class="line">        book1.setDescription(<span class="string">&quot;C语言入门图书&quot;</span>);</span><br><span class="line">        bookList.add(book1);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book2.setName(<span class="string">&quot;计算机网络：自顶向下&quot;</span>);</span><br><span class="line">        book2.setType(<span class="string">&quot;计算机网络&quot;</span>);</span><br><span class="line">        book2.setDescription(<span class="string">&quot;计算机四大件之计算机网络&quot;</span>);</span><br><span class="line">        bookList.add(book2);</span><br><span class="line">        <span class="keyword">return</span> bookList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save =====&gt; &quot;</span> + book);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27;module&#x27;:&#x27;Book save successfully...&#x27;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2：使用PostMan进行测试</p><ul><li>测试新增</li></ul><img src="image-20230618163951612.png" alt="image-20230618163951612" style="zoom:87%;" /><ul><li>测试查询全部</li></ul><img src="image-20230618164145531.png" alt="image-20230618164145531" style="zoom:87%;" /><h3 id="页面访问处理"><a href="#页面访问处理" class="headerlink" title="页面访问处理"></a>页面访问处理</h3><p>步骤1：拷贝静态页面</p><p><img src="image-20230618165134339.png" alt="image-20230618165134339"></p><p>步骤2：访问pages目录下的books.html</p><p><img src="image-20230618165232338.png" alt="image-20230618165232338"></p><p>报错的原因是：<font color="blue">SpringMVC拦截了静态资源，根据/pages/books.html去controller找对应的方法，找不到所以会报404的错误。</font></p><p>因为在ServletInitConfig配置文件中<strong>拦截了静态资源</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以必须将静态资源在ServletInitConfig中进行放行：创建一个新的SpringMvcSupport配置类！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span>&#123;</span><br><span class="line">        <span class="comment">//当访问/pages/????时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.Lijiacheng.controller&quot;,&quot;com.Lijiacheng.config&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p>步骤3：修改books.html页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//添加</span><br><span class="line">  saveBook () &#123;</span><br><span class="line">  axios.post(&quot;/books&quot;,this.formData).then((res)=&gt;&#123;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;,</span><br><span class="line">//主页列表查询</span><br><span class="line">  getAll() &#123;</span><br><span class="line">    axios.get(&quot;/books&quot;).then((res)=&gt;&#123;</span><br><span class="line">    this.dataList = res.data;</span><br><span class="line">    &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p><img src="image-20230618170855805.png" alt="image-20230618170855805"></p><img src="image-20230618171004140.png" alt="image-20230618171004140" style="zoom:77%;" /><p>前端的新增图书请求到后端来接收：</p><p><img src="image-20230618171022178.png" alt="image-20230618171022178"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;REST（Representational State Transfer），表现形式状态转换，它是一种软件架构风格，听不懂很正常。说通俗点就是用URL定位资源，用HTTP动词（GET, POST, DELETE, PUT）描述操作的一种开发方式。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringMVC" scheme="https://kicheng.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>01-SpringMVC入门</title>
    <link href="https://kicheng.github.io/2023/06/05/01-SpringMVC%E5%85%A5%E9%97%A8/"/>
    <id>https://kicheng.github.io/2023/06/05/01-SpringMVC%E5%85%A5%E9%97%A8/</id>
    <published>2023-06-05T02:39:50.000Z</published>
    <updated>2023-06-11T03:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringMVC是隶属于Spring框架的一部分吗，是对Servlet进行了封装。SpringMVC是处于Web层的框架，所以其主要的作用就是用来接收前端发过来的请求和数据然后经过处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容。</p><span id="more"></span><h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><h3 id="Web架构"><a href="#Web架构" class="headerlink" title="Web架构"></a>Web架构</h3><p>现在web程序大都基于三层架构来实现：</p><img src="image-20230605105629968.png" alt="image-20230605105629968" style="zoom:67%;" /><ul><li><p>浏览器发送一个请求给后端服务器，后端服务器现在是使用Servlet来接收请求和数据；</p></li><li><p>如果所有的处理都交给Servlet来处理的话，所有的东西都耦合在一起，对后期的维护和扩展极为不利；将后端服务器Servlet拆分成三层，分别是web、service和dao；</p><ul><li>web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端；</li><li>service层主要负责业务逻辑的处理；</li><li>dao层主要负责连接数据库，进行数据的增删改查操作；</li></ul></li><li><p>servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求；针对web层进行了优化，采用了MVC设计模式，将其设计为controller、view和model：</p><img src="image-20230605110015709.png" alt="image-20230605110015709" style="zoom:67%;" /><ul><li><p>controller负责请求和数据的接收，接收后将其转发给service进行业务处理；</p></li><li><p>service根据需要调用dao对数据进行增删改查；</p></li><li><p>dao把数据处理完后将结果交给service，service再交给controller；</p></li><li><p><font color="red"><strong>同步请求：</strong></font>controller根据需求组装成Model和View，Model和View组合起来生成页面转发给前端浏览器（这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操作）；</p><p>现在更多使用的是<font color="red"><strong>异步请求</strong></font>方式，后端不需要返回view视图，而是将数据以json格式返回</p></li></ul></li></ul><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC是一种基于Java实现MVC模型的轻量级Web框架，相比于Servlet使用更加简单、开发更加便捷。</p><p>SpringMVC主要负责的就是：① controller如何接收请求和数据；② 如何将请求和数据转发给业务层；③ 如何将响应数据转换成json发回到前端。</p><h2 id="SpringMVC入门案例"><a href="#SpringMVC入门案例" class="headerlink" title="SpringMVC入门案例"></a>SpringMVC入门案例</h2><p>SpringMVC是一个Web框架，是用来替换Servlet的，在JavaWeb中如何使用Servlet进行开发呢？忘记的话看前面的文章【<a href="https://kicheng.github.io/2023/03/28/03-Servlet/">JavaWeb_Servlet</a>】</p><p>SpringMVC的制作流程与Servlet几乎一致：</p><p>1、创建Maven结构的web工程</p><p>2、设置tomcat服务器：tomcat插件</p><p>3、导入坐标（SpringMVC+Servlet）</p><p>4、定义处理请求的功能类（Controller）</p><p>5、设置请求映射</p><p>6、将SpringMVC设定加载到tomcat容器中</p><h3 id="SpringMVC实现流程"><a href="#SpringMVC实现流程" class="headerlink" title="SpringMVC实现流程"></a>SpringMVC实现流程</h3><p>步骤1：创建webapp内核的Maven项目</p><p>步骤2：导入依赖坐标（Servlet、SpringMVC）</p><p>​    注意导入的版本，建议使用JDK8以及5.3.0以下的SpringMVC版本配置，否则后面会出现奇奇怪怪的bug…到现在不知道如何解决jdk17不兼容的问题，后面做大项目的时候一定解决这个问题！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果不设置默认是compile在编译、运行、测试时均有效；如果运行有效的话就会和tomcat中的servlet-api包发生冲突 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.24.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤3：创建SpringMvcConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4：创建Controller类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;springMVC&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Controller要注意的点有如下几个：</p><p>（1）<code>@Controller</code>将其作为Bean交给Spring管理；</p><p>（2）<code>@RequestMapping(&quot;/save&quot;)</code>指定request请求访问的地址，相当于Servlet中的<code>WebServlet</code>；</p><p>（3）<code>@ResponseBody</code>指定后端返回的response响应是json数据；</p><p>步骤5：使用Servlet容器启动配置类替换web.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//加载springmvc配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化WebApplicationContext对象</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//加载指定配置类</span></span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置由springmvc控制器处理的请求映射路径(设置为接收所有路径)</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载spring配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    配置类要继承这个<code>AbstractDispatcherServletInitializer</code>类；并且初始化时所需的对象和前面的不同，是<code>AnnotationConfigWebApplicationContext</code>。</p><p>步骤6：配置Tomcat环境</p><p>我一般是习惯用IDEA自带的Tomcat插件，唯一的缺点是只能用Tomcat7，但是Tomcat7和JDK17已经不兼容了，所以我这里降低版本到JDK8了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤7：运行Tomcat服务器，在浏览器访问<code>/save</code></p><p><img src="image-20230605164950934.png" alt="image-20230605164950934"></p><h3 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h3><p>将SpringMVC的使用过程总共分两个阶段来分析，分别是启动服务器初始化过程和单次请求过程。</p><img src="image-20230605165432219.png" alt="image-20230605165432219" style="zoom: 50%;" /><h4 id="启动服务器初始化"><a href="#启动服务器初始化" class="headerlink" title="启动服务器初始化"></a>启动服务器初始化</h4><p>1、服务器启动，执行ServletInitConfig类，初始化web容器（功能类似于以前的web.xml）</p><p>2、执行createServletApplicationContext方法，创建了WebApplicationContext对象，加载SpringMvcConfig配置类来初始化SpringMVC的容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化WebApplicationContext对象</span></span><br><span class="line"><span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line"><span class="comment">//加载指定配置类</span></span><br><span class="line">ctx.register(SpringMvcConfig.class);</span><br></pre></td></tr></table></figure><p>3、加载SpringMvcConfig配置类，执行@ComponentScan加载对应的bean，扫描指定包及其子包下所有类上的注解，这里是<code>@Controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br></pre></td></tr></table></figure><p>4、加载Controller类，每个@RequestMapping的名称对应一个具体的方法：建立了<code>/save</code>和save方法的对应关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;springMVC&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、执行getServletMappings方法，设定SpringMVC拦截请求的路径规则：<code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="单次请求过程"><a href="#单次请求过程" class="headerlink" title="单次请求过程"></a>单次请求过程</h4><p>1、发送请求 <a href="http://localhost:8080/springmvc_01_quickstart/save">http://localhost:8080/springmvc_01_quickstart/save</a></p><p>2、web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</p><p>3、解析请求路径<code>/save</code>，由<code>/save</code>匹配执行对应的方法save()</p><p>4、检测到有<code>@ResponseBody</code>直接将save()方法的返回值作为响应体返回给请求方</p><h3 id="Bean加载控制"><a href="#Bean加载控制" class="headerlink" title="Bean加载控制"></a>Bean加载控制</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>之前我们创建过SpringConfig配置类，在MVC中也创建了SpringMvcConfig配置类，它们都需要加载资源，它们分别都加载哪些内容呢？</p><blockquote><p>我们目前写过的Config配置类有：ServletInitConfig, SpringConfig, SpringMvcConfig, JdbcConfig, MybatisConfig。</p></blockquote><p>controller目录存放的是SpringMVC的controller类、service目录存放的是service接口和实现类、dao目录存放的是dao/Mapper接口。controller、service和dao这些类都需要被容器管理成bean对象，SpringMVC加载表现层bean，也就是controller包下的类；Spring控制业务层service的bean和功能bean（DataSource, SqlSessionFactoryBean, MapperScannerConfigurer等），我们需要让Spring和SpringMVC分开加载各自的内容。</p><p>在SpringMVC的配置类SpringMvcConfig中使用注解<code>@ComponentScan</code>，我们只需要将其扫描范围设置到controller即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring的配置类SpringConfig中使用注解<code>@ComponentScan </code>，当时扫描的范围中其实是已经包含了controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为功能不同，所以我们需要避免Spring错误加载到SpringMVC的bean。</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230605192715499.png" alt="image-20230605192715499" style="zoom:67%;" /><h4 id="设置Bean加载控制"><a href="#设置Bean加载控制" class="headerlink" title="设置Bean加载控制"></a>设置Bean加载控制</h4><p>方式一：修改Spring配置类，设定扫描范围为精准范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述只是通过例子说明可以精确指定让Spring扫描对应的包结构，真正在做开发的时候，因为Dao最终是交给MapperScannerConfigurer对象来进行扫描处理的，我们只需要将其扫描到service包即可。</p></blockquote><p>方式二：修改Spring配置类，排除掉controller包中的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.Lijiacheng&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(  // 设置扫描加载bean时，排除的过滤规则</span></span><br><span class="line"><span class="meta">                type = FilterType.ANNOTATION,  // 设置排除规则，当前使用按照bean定义时的注解类型进行排除</span></span><br><span class="line"><span class="meta">                classes = Controller.class  // 设置具体排除的注解类</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过getBean获取Controller类，如果获取不到就说明在SpringConfig配置类中排除成功了。</p><blockquote><p>需要把SpringMvcConfig配置类上的<code>@ComponentScan</code>注解注释掉才可以测试成功。因为SpringConfig类中扫描的包是com.Lijiacheng下除了controller包，config中的SpringMvcConfig就会被扫描到，里面又有一个<code>@ComponentScan</code>又将controller类扫描进来了。</p></blockquote><p>最后一点也很重要，有了SpringConfig配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletInitConfig配置类中的最后一个函数，将Spring配置也加载进来，很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">      ctx.register(SpringConfig.class);</span><br><span class="line">      <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>简化ServletInitConfig配置类开发</strong>（以后用它更简单，不过上面的是老母子）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bean加载控制总结</strong></p><p><code>@ComponentScan</code>有个很重要的属性：<code>excludeFilters</code>排除扫描路径中加载的bean，需要指定类别（type）和具体项（classes）；<code>includeFilter</code>相反。</p><h2 id="SpringMVC的请求与响应"><a href="#SpringMVC的请求与响应" class="headerlink" title="SpringMVC的请求与响应"></a>SpringMVC的请求与响应</h2><p>SpringMVC是web层的框架，主要的作用是接收请求、响应结果，所以这一部分是学习SpringMVC的重点内容。</p><h3 id="设置请求映射路径"><a href="#设置请求映射路径" class="headerlink" title="设置请求映射路径"></a>设置请求映射路径</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230606101301421.png" alt="image-20230606101301421" style="zoom:77%;" /><p>开启Tomcat服务器，发生报错：</p><p><img src="image-20230606102344014.png" alt="image-20230606102344014"></p><p>意思是<code>/save</code>已经是bookController这个bean的方法进行匹配了，而另一个UserController这个bean也有一个<code>/save</code>，出现了request请求的匹配模糊。</p><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>前面说到报错，是因为两个Controller中出现了重复的请求路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =====================================</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User delete...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决思路其实也很好想到：为不同模块设置模块名作为请求路径前缀。</p><p>对于BookController的save，将其访问路径设置 <a href="http://localhost:8080/springmvc_03_request_mapping/book/save%EF%BC%9B%E5%AF%B9%E4%BA%8EUserController%E7%9A%84save%EF%BC%8C%E5%B0%86%E5%85%B6%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE">http://localhost:8080/springmvc_03_request_mapping/book/save；对于UserController的save，将其访问路径设置</a> <a href="http://localhost:8080/springmvc_03_request_mapping/User/save%E3%80%82">http://localhost:8080/springmvc_03_request_mapping/User/save。</a></p><h4 id="设置映射路径"><a href="#设置映射路径" class="headerlink" title="设置映射路径"></a>设置映射路径</h4><p>类上也可以添加<code>@RequestMapping</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =====================================</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User delete...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230606105142414.png" alt="image-20230606105142414"></p><blockquote><p><code>@RequestMapping</code>注解value属性前面加不加<code>/</code>都可以，这一点和Servlet有所不同！</p></blockquote><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>请求路径设置好后，只要确保页面发送请求地址和后台Controller类中配置的路径一致，就可以接收到前端的请求，接收到请求后，如何接收页面传递的参数。请求参数的传递与接收是和请求方式有关系的，目前比较常见的两种请求方式POST和GET。</p><h4 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230606114451105.png" alt="image-20230606114451105" style="zoom:77%;" /><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p><strong>GET发送单个参数</strong></p><p>客户端发送请求与参数：</p><img src="image-20230606115900208.png" alt="image-20230606115900208" style="zoom:80%;" /><p>服务端接收参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里controller方法的形参负责接收来自客户端的请求参数（<font color="blue">注意形参名要和请求参数名一致！</font>）</p><p><img src="image-20230606120718965.png" alt="image-20230606120718965"></p><p>客户端接收到的返回数据：</p><p><img src="image-20230606120053621.png" alt="image-20230606120053621"></p><p><strong>GET发送多个参数</strong></p><p>发送请求与参数：</p><img src="image-20230606122327297.png" alt="image-20230606122327297" style="zoom:80%;" /><p>服务端接收参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name, Integer age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 age =====&gt;&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230606122229281.png" alt="image-20230606122229281"></p><p><strong>GET请求中文乱码问题</strong></p><p>如果我们传递的请求参数中有中文，你会发现接收到的参数会出现中文乱码问题。</p><p>出现乱码的原因相信大家都清楚（忘了的话回去看JavaWeb的博客），Tomcat8以后的版本已经处理了中文乱码的问题，但是IDEA中的Tomcat插件目前只更新到Tomcat7，所以需要修改pom.xml中<strong>tomcat插件的配置</strong>来解决<font color="red">GET请求</font>中文乱码问题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span>  <span class="comment">&lt;!--访问路径编解码字符集--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="image-20230606122858098.png" alt="image-20230606122858098"></p><p><strong>POST发送参数</strong></p><p>发送请求与参数：post的请求参数在请求体上</p><img src="image-20230606123252732.png" alt="image-20230606123252732" style="zoom:80%;" /><p>接收参数和GET完全一致！</p><p><strong>POST请求中文乱码问题</strong></p><p>解决方案：在ServletInitConfig中配置过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 乱码处理 */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Filter[] getServletFilters()&#123;</span><br><span class="line">      <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">      filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230606161430634.png" alt="image-20230606161430634"></p><blockquote><p>CharacterEncodingFilter是在spring-web包中，而spring-web包又在SpringMVC包里。</p></blockquote><h3 id="五种类型的参数传递"><a href="#五种类型的参数传递" class="headerlink" title="五种类型的参数传递"></a>五种类型的参数传递</h3><p>前面我们已经能够使用GET或POST来发送请求和数据，所携带的数据都是比较简单的数据，接下来在这个基础上，我们来研究一些比较复杂的参数传递：普通参数、POJO类型参数、嵌套POJO类型参数、数组类型参数、集合类型参数。</p><h4 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h4><p>普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数。</p><p>能接收到参数的前提是：这两个值必须一致！</p><img src="image-20230606162700080.png" alt="image-20230606162700080" style="zoom:80%;" /><p>那如果方法形参和请求参数名不一致怎么办？</p><p><img src="image-20230606163422184.png" alt="image-20230606163422184"></p><p>使用<code>@RequestParam</code>注解：写上<code>@RequestParam</code>注解框架就不需要自己去解析注入，能提升框架处理性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username, Integer age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 name =====&gt;&quot;</span> + username);</span><br><span class="line">        System.out.println(<span class="string">&quot;来自浏览器的普通参数传递 age =====&gt;&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="POJO类型参数"><a href="#POJO类型参数" class="headerlink" title="POJO类型参数"></a>POJO类型参数</h4><p>简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候我们可以考虑使用POJO数据类型。</p><p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）。</p><p>先看看前面封装的pojo类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="comment">// ...后部分省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求和参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）：</p><img src="image-20230606164837627.png" alt="image-20230606164837627" style="zoom:80%;" /><p>服务器接收参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的pojo参数传递 user =====&gt;&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230606165101676.png" alt="image-20230606165101676"></p><h4 id="嵌套POJO类型参数"><a href="#嵌套POJO类型参数" class="headerlink" title="嵌套POJO类型参数"></a>嵌套POJO类型参数</h4><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数。</p><p>发送请求和参数（<font color="red">请求参数key的名称要和POJO中属性的名称一致，否则无法封装</font>）：</p><img src="image-20230606171638166.png" alt="image-20230606171638166" style="zoom:80%;" /><p>服务器接收参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/containPojoParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">containPojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的嵌套pojo参数传递 user =====&gt;&quot;</span> + user.toString());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230606171728620.png" alt="image-20230606171728620"></p><h4 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h4><p>数组参数：请求参数名与形参对象属性名<strong>相同</strong>且请求参数为多个，定义数组类型即可接收参数。</p><p>发送请求和参数（请求参数名必须一致才能封装到一个数组当中）：</p><img src="image-20230606172710261.png" alt="image-20230606172710261" style="zoom:80%;" /><p>服务器接收参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的数组参数传递 likes =====&gt;&quot;</span> + Arrays.toString(likes));</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;arrayParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230606172647070.png" alt="image-20230606172647070"></p><h4 id="集合类型数据"><a href="#集合类型数据" class="headerlink" title="集合类型数据"></a>集合类型数据</h4><p>发送请求和参数：</p><p><img src="image-20230606184441837.png" alt="image-20230606184441837"></p><p>服务器接收参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的列表参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;arrayParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>出现报错：</p><p><img src="image-20230606184417780.png" alt="image-20230606184417780"></p><p>错误的原因是：SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错。</p><p>解决方案：<code>RequestParam</code>注解（对于简单数据类型使用数组会比集合更简单些）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的列表参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p><code>RequestParam</code>注解用在SpringMVC控制器方法形参定义前面：情况1——简单数据类型参数名和请求参数名不一致时进行映射；情况2——对于List列表形参前要加该注释将其标明为非POJO对象。</p><h3 id="JSON数据传输参数"><a href="#JSON数据传输参数" class="headerlink" title="JSON数据传输参数"></a>JSON数据传输参数</h3><p>前面我们说过，现在比较流行的开发方式为异步调用。前后端以异步方式进行交换，传输的数据使用的是JSON，所以前端如果发送的是JSON数据，后端该如何接收。</p><p>SpringMVC接收JSON数据的实现步骤为：</p><ul><li>导入jackson包；</li><li>客户端发送JSON数据；</li><li>开启SpringMVC注解驱动，在SpringMvcConfig配置类上添加<code>@EnableWebMvc</code>注解；</li><li>Controller方法的参数前添加<code>@RequestBody</code>注解.</li></ul><h4 id="JSON普通数组"><a href="#JSON普通数组" class="headerlink" title="JSON普通数组"></a>JSON普通数组</h4><p>步骤1：pom.xml添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">2.15</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>步骤2：PostMan发送JSON数据</p><img src="image-20230606201238403.png" alt="image-20230606201238403" style="zoom:80%;" /><p>步骤3：开启SpringMVC注解支持</p><p>​    在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4：参数前添加<code>@RequestBody</code>将外部传递的json数组数据映射到形参的集合对象中作为数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/listParamForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON普通数组参数传递 likes =====&gt;&quot;</span> + likes);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listParamForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为json数据是异步请求，参数和数据在表单中，所以不能用<code>@RequestParam</code>，而用<code>@RequestBody</code>.</p></blockquote><p><img src="image-20230606201541316.png" alt="image-20230606201541316"></p><h4 id="JSON对象数据"><a href="#JSON对象数据" class="headerlink" title="JSON对象数据"></a>JSON对象数据</h4><p>请求和数据的发送：</p><img src="image-20230606202729677.png" alt="image-20230606202729677" style="zoom:80%;" /><p>后端接收数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pojoForJson</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON实体类对象参数传递 User =====&gt;&quot;</span> + user);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;pojoForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="blue">这里也不要忘记在controller方法形参对象前加上<code>@RequestBody</code>进行json类型转换。</font></p></blockquote><p><img src="image-20230606202648795.png" alt="image-20230606202648795"></p><h4 id="JSON对象数组"><a href="#JSON对象数组" class="headerlink" title="JSON对象数组"></a>JSON对象数组</h4><p>json对象数组即为在集合中保存多个POJO。</p><p>请求和数据的发送：</p><img src="image-20230606204127055.png" alt="image-20230606204127055" style="zoom:80%;" /><p>后端接收数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listPojoForJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">listPojoForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的JSON对象数组参数传递 users =====&gt;&quot;</span> + users);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;listPojoForJson&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230606204104084.png" alt="image-20230606204104084"></p><blockquote><p><strong><code>@RequestBody</code>与<code>@RequestParam</code>的区别：</strong></p><p><code>@RequestParam</code>用于接收url地址传参，表单传参【application/x-www-form-urlencoded】；<code>@RequestBody</code>用于接收json数据【application/json】.</p><p>后期开发中，发送json格式数据为主，<code>@RequestBody</code>应用较广；如果发送非json格式数据，选用<code>@RequestParam</code>接收请求参数。</p></blockquote><h3 id="日期类型参数传递"><a href="#日期类型参数传递" class="headerlink" title="日期类型参数传递"></a>日期类型参数传递</h3><p>前面我们处理过简单数据类型、POJO数据类型、数组和集合数据类型以及JSON数据类型，接下来我们还得处理一种开发中比较常见的一种数据类型：日期类型。</p><p>日期的格式有N多中输入方式，比如：2088-08-18、2088/08/18、08/18/2088……这么多日期格式，SpringMVC如何接收。</p><p>步骤1：编写方法接收日期数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dataParam&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dataParam</span><span class="params">(Date date,</span></span><br><span class="line"><span class="params">                          <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date1,</span></span><br><span class="line"><span class="params">                          <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> Date date2)</span></span><br><span class="line">  &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date =====&gt;&quot;</span> + date);</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date1(YYYY-MM-dd) =====&gt;&quot;</span> + date1);</span><br><span class="line">      System.out.println(<span class="string">&quot;来自浏览器的日期参数传递 date2(YYYY-MM-dd HH:mm:ss)&quot;</span> + date2);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;,&#x27;dataParam&#x27;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>步骤2：客户端发送请求</p><img src="image-20230606225853557.png" alt="image-20230606225853557" style="zoom:80%;" /><blockquote><p>SpringMVC默认支持的字符串转日期的格式为yyyy/MM/dd ，而如果传递的不符合其默认格式，SpringMVC就无法进行格式转换，所以报错：<img src="image-20230606205513452.png" alt="image-20230606205513452"></p><p>所以使用<code>@DateTimeFormat</code>注解的<code>pattern</code>值来解决这个问题。</p></blockquote><p><img src="image-20230606225051826.png" alt="image-20230606225051826"></p><h3 id="参数传递的内部实现原理"><a href="#参数传递的内部实现原理" class="headerlink" title="参数传递的内部实现原理"></a>参数传递的内部实现原理</h3><p>前端传递字符串，后端使用日期Date接收；前端传递JSON数据，后端使用对象接收；前端传递字符串，后端使用Integer接收。在数据的传递过程中存在很多类型的转换，那么谁来做这个类型转换——是<strong>SpringMVC</strong>提供的很多类型转换接口和实现类。</p><p>在框架中，有一些类型转换接口，其中有：</p><ul><li> Converter接口：convert方法就是将从页面上接收的数据(S)转换成我们想要的数据类型(T)返回，框架中有提供很多对应Converter接口的实现类，用来实现不同数据类型之间的转换，如：请求参数年龄数据（String→Integer）、日期格式转换（String → Date）。</li><li>HttpMessageConverter接口：该接口是实现对象与JSON之间的转换工作（配置<code>@EnableWebMvc</code>）。</li></ul><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>SpringMVC接收到请求和数据后，进行一些了的处理，当然这个处理可以是转发给Service，Service层再调用Dao层完成的，不管怎样，处理完以后都需要将结果告知给用户。对于响应，主要就包含两部分内容：响应页面、响应数据（文本数据、json数据），因为异步调用是目前常用的主流方式，所以我们需要更关注的就是如何返回JSON数据。</p><h4 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230607100531074.png" alt="image-20230607100531074" style="zoom:80%;" /><h4 id="响应页面（了解）"><a href="#响应页面（了解）" class="headerlink" title="响应页面（了解）"></a>响应页面（了解）</h4><p>响应页面时不能使用<code>@responseBody</code>注解，否则会把”page.jsp”当做字符串返回，这里需要返回页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用@responseBody，否则会把&quot;page.jsp&quot;当做字符串返回，这里需要返回页面</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/jumpToPage&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">jumpToPage</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;跳转页面&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230607101201195.png" alt="image-20230607101201195"></p><h4 id="响应文本数据"><a href="#响应文本数据" class="headerlink" title="响应文本数据"></a>响应文本数据</h4><p>响应文本时一定要使用<code>@responseBody</code>注解，返回纯文本字符串类型数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回纯文本数据&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;response text&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="image-20230607101757278.png" alt="image-20230607101757278" style="zoom:80%;" /><h4 id="响应JSON数据"><a href="#响应JSON数据" class="headerlink" title="响应JSON数据"></a>响应JSON数据</h4><p><strong>响应POJO对象</strong></p><p>返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖<code>@ResponseBody</code>注解和<code>@EnableWebMvc</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toPojoJson&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">toPojoJson</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回json格式的对象类型&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setName(<span class="string">&quot;李嘉诚123&quot;</span>);</span><br><span class="line">      user.setAge(<span class="number">22</span>);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="image-20230607103941400.png" alt="image-20230607103941400" style="zoom:80%;" /><p><strong>响应POJO集合对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;返回json对象列表的类型&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      u1.setName(<span class="string">&quot;李嘉诚&quot;</span>);</span><br><span class="line">      u1.setAge(<span class="number">21</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      u2.setName(<span class="string">&quot;廖梓汀&quot;</span>);</span><br><span class="line">      u2.setAge(<span class="number">22</span>);</span><br><span class="line">      List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">      users.add(u1);</span><br><span class="line">      users.add(u2);</span><br><span class="line">      <span class="keyword">return</span> users;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="image-20230607104901315.png" alt="image-20230607104901315" style="zoom:80%;" /><p> <strong><code>@ResponseBody</code>总结</strong></p><p>位置：SpringMVC控制器方法定义上方和控制类上，写在类上则该类的所有方法都有该注解功能；</p><p>作用：设置当前控制器返回值作为响应体（除了返回页面之外都要加该注释）：① 方法的返回值为字符串，会将其作为文本内容直接响应给前端；② 方法的返回值为对象，会将对象转换成JSON响应给前端（通过Converter接口）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringMVC是隶属于Spring框架的一部分吗，是对Servlet进行了封装。SpringMVC是处于Web层的框架，所以其主要的作用就是用来接收前端发过来的请求和数据然后经过处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringMVC" scheme="https://kicheng.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>ChatGPT本地安装</title>
    <link href="https://kicheng.github.io/2023/06/05/ChatGPT%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85/"/>
    <id>https://kicheng.github.io/2023/06/05/ChatGPT%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85/</id>
    <published>2023-06-05T00:24:52.000Z</published>
    <updated>2023-06-05T01:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本地搭建ChatGPT，无需API、 免翻墙使用纯正OpenAI的全部功能。</p><span id="more"></span><h2 id="和官网的比较"><a href="#和官网的比较" class="headerlink" title="和官网的比较"></a>和官网的比较</h2><p>优点：</p><ul><li>不需要挂代理就可以访问</li><li>相比官网而言速度更快</li></ul><p>缺点：</p><ul><li>后台要挂Docker</li><li>和使用API不同，并不是真正意义上的本地部署，只是通过自己的Access TOKEN避免了网络代理</li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1、下载并安装Docker（<a href="https://www.docker.com/products/docker-desktop/">官网链接</a>）</p><p>2、使用开源项目：潘多拉 (Pandora) </p><p>​    一键安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull pengzhile/pandora</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora</span><br></pre></td></tr></table></figure><p>3、获取自己的Access TOKEN：<a href="http://chat.openai.com/api/auth/session">http://chat.openai.com/api/auth/session</a> 14天内免代理登录</p><p>4、访问本地链接：<a href="http://127.0.0.1:8899/">http://127.0.0.1:8899</a> 可以实现与官网的同步</p><img src="image-20230605085358793.png" alt="image-20230605085358793" style="zoom:67%;" /><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本地搭建ChatGPT，无需API、 免翻墙使用纯正OpenAI的全部功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Others" scheme="https://kicheng.github.io/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>05-Spring事务管理</title>
    <link href="https://kicheng.github.io/2023/06/04/05-Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>https://kicheng.github.io/2023/06/04/05-Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2023-06-04T04:06:46.000Z</published>
    <updated>2023-06-04T10:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库的事务在数据库还有JavaWeb中也多次提到了，事务管理保障了一系列的数据库操作同成功同失败，事务管理非常重要。下面就来讲一下Spring是如何进行事务管理的。</p><span id="more"></span><h2 id="Spring事务简介"><a href="#Spring事务简介" class="headerlink" title="Spring事务简介"></a>Spring事务简介</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>事务作用：在数据层保障一系列的数据库操作同成功同失败；</li><li>Spring事务作用：在数据层或<strong>业务层</strong>保障一系列的数据库操作同成功同失败；</li></ul><p>为什么业务层需要进行事务管理？举个例子来说，转账业务会有两次数据层的调用，一次是加钱一次是减钱；把事务放在数据层，加钱和减钱就有两个事务；没办法保证加钱和减钱同时成功或者同时失败；这个时候就需要将事务放在业务层进行处理。</p><p>Spring为了管理事务，提供了一个平台事务管理器（接口）<code>PlatformTransactionManager</code>：</p><img src="image-20230604122146529.png" alt="image-20230604122146529" style="zoom:67%;" /><p>除此之外，Spring还为其提供了一个具体的实现（类）：<code>DataSourceTransactionManager</code>.</p><p>我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个DataSourceTransactionManager事务管理器。</p><h3 id="Spring事务转账案例"><a href="#Spring事务转账案例" class="headerlink" title="Spring事务转账案例"></a>Spring事务转账案例</h3><p>需求：实现任意两个账户间转账操作（账户A加钱，账户B减钱）</p><p>实现：基于Spring整合MyBatis环境，实现转账操作。忘记如何整合Mybatis环境的去看<a href="https://kicheng.github.io/2023/06/01/03-Spring%E6%95%B4%E5%90%88%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/">03-Spring整合三方框架</a>。</p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><img src="image-20230604161234419.png" alt="image-20230604161234419" style="zoom:80%;" /><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>如果在转账过程中出现了异常，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String in, String out, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">      accountDao.outMoney(out, money);</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;  <span class="comment">// 模拟异常</span></span><br><span class="line">      accountDao.inMoney(in, money);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败：</p><p><img src="image-20230604161633065.png" alt="image-20230604161633065"></p><p>正常来说，Tom账户应该收到来自Jerry账户转账的100元，但是由于在转出之后程序出现异常，后面的转入操作根本没有进行，这在现实中是肯定不允许出现的。这就体现出事务管理的重要性，程序出现异常时要进行事务回滚，这个事务应该是在业务层（Service），Spring事务管理就是做这个的：</p><p>步骤1：在需要被事务管理的方法上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String in, String out, <span class="type">double</span> money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <code>@Transactional</code>可以写在接口类上、接口方法上、实现类上和实现类方法上，建议（标准）写在接口或接口的方法上。</p></blockquote><p>步骤2：在JdbcConfig类中配置事务管理器（mybatis使用的是jdbc事务）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dataSourceTransactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用DataSourceTransactionManager。</p></blockquote><p>步骤3：SpringConfig开启事务注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br></pre></td></tr></table></figure><p>发现在转换的业务出现错误后，事务就可以控制回滚，保证数据的正确性：</p><p><img src="image-20230604163037324.png" alt="image-20230604163037324"></p><p><strong>Spring事务管理总结</strong></p><p>注意两个注释：</p><ul><li>配置类注释：<code>@EnableTransactionManagement</code>设置当前Spring环境中开启注解式事务支持；</li><li>业务层接口注释：<code>@Transactional</code>为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）。</li></ul><h2 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h2><p>重点要理解两个概念，分别是事务管理员和事务协调员。</p><p>1、未开启Spring事务之前：</p><img src="image-20230604163420737.png" alt="image-20230604163420737" style="zoom:50%;" /><p>AccountDao的outMoney因为是修改操作，会开启一个事务T1；AccountDao的inMoney因为是修改操作，会开启一个事务T2；<br>AccountService的transfer没有事务。</p><p>如果运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确；如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行，就会出现数据错误。</p><p>2、开启Spring事务后</p><img src="image-20230604163558148.png" alt="image-20230604163558148" style="zoom:50%;" /><p>transfer上添加了<code>@Transactional</code>注解，在该方法上就会有一个事务T，AccountDao的outMoney方法的事务T1加入到transfer的事务T中，AccountDao的inMoney方法的事务T2加入到transfer的事务T中。这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。</p><ul><li>事务管理员：发起事务方，在Spring中通常指业务层开启事务的方法；</li><li>事务协调员：加入事务方，在Spring中通常指数据层方法，也可以是业务层方法；</li></ul><blockquote><p>注意：目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个DataSource数据源。</p></blockquote><h2 id="Spring事务属性"><a href="#Spring事务属性" class="headerlink" title="Spring事务属性"></a>Spring事务属性</h2><h3 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h3><p>这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p><ul><li><p>readOnly：true只读事务，false读写事务，增删改要设为false（默认），查询设为true。</p></li><li><p>timeout：设置超时时间（单位秒），在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</p></li><li><p><strong>rollbackFor：</strong>当出现指定异常进行事务回滚</p></li><li><p>noRollbackFor：当出现指定异常不进行事务回滚</p></li></ul><blockquote><p>关于Spring事务异常回滚的问题，Spring的事务只会对Error异常和RuntimeException异常及其子类（运行时异常）进行事务回滚，其他的异常类型是不会回滚的，比如IOException不符合上述条件所以不回滚。</p></blockquote><p>此时就可以使用<code>rollbackFor</code>属性来设置IOException异常回滚。</p><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>为了讲解事务传播行为属性<code>propagation</code>的设置，我们需要完成下面的案例。</p><h4 id="转账业务追加日志案例"><a href="#转账业务追加日志案例" class="headerlink" title="转账业务追加日志案例"></a>转账业务追加日志案例</h4><p>需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕（数据库记录日志），<strong>无论转账操作是否成功，均进行转账操作的日志留痕</strong>。</p><p><strong>环境准备</strong></p><p>步骤1：数据库创建日志表</p><p>步骤2：添加LogDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_log (info,createDate) values(#&#123;info&#125;,now())&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String info)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤3：添加LogService接口与实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,<span class="type">double</span> money)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,<span class="type">double</span> money)</span>&#123;</span><br><span class="line">        logDao.log(<span class="string">&quot;转账操作由 &quot;</span> + out + <span class="string">&quot;到&quot;</span> + in + <span class="string">&quot;，金额：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4：在转账的业务中添加记录日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> LogService logService;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String in, String out, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          accountDao.outMoney(out, money);</span><br><span class="line">          accountDao.inMoney(in, money);</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          logService.log(out,in,money);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功；当转账业务之间出现异常（int i =1/0），转账失败，tbl_account成功回滚，但是tbl_log表未添加数据。而我们希望无论转账操作是否成功，日志都必须保留。</p><p>失败原因：日志的记录与转账操作隶属同一个事务，同成功同失败。</p><h4 id="事务传播行为-1"><a href="#事务传播行为-1" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><img src="image-20230604174004771.png" alt="image-20230604174004771" style="zoom: 50%;" /><p>log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1、T2、T3，<code>@Transactional</code>注释开启事务T，把T1、T2、T3都加入到事务T中来，当转账失败后，所有事务都回滚，所以日志没有记录下来。如果要想让log方法单独开启一个事务，就用到了事务传播行为。</p><p>事务传播行为是指事务协调员对事务管理员所携带事务的处理态度，用到了<code>@propagation</code>属性。</p><p>修改logSevice的<code>@Transactional</code>属性值，改变事务传播行为（当前操作需要新事务）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br></pre></td></tr></table></figure><p><strong>事务传播行为的可选值</strong></p><img src="image-20230604174832710.png" alt="image-20230604174832710" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库的事务在数据库还有JavaWeb中也多次提到了，事务管理保障了一系列的数据库操作同成功同失败，事务管理非常重要。下面就来讲一下Spring是如何进行事务管理的。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://kicheng.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>网页调试工具PostMan</title>
    <link href="https://kicheng.github.io/2023/06/04/%E7%BD%91%E9%A1%B5%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7PostMan/"/>
    <id>https://kicheng.github.io/2023/06/04/%E7%BD%91%E9%A1%B5%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7PostMan/</id>
    <published>2023-06-04T01:58:21.000Z</published>
    <updated>2023-06-11T03:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>PostMan是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件，常用于进行接口测试。</p><span id="more"></span><h2 id="PostMan简介"><a href="#PostMan简介" class="headerlink" title="PostMan简介"></a>PostMan简介</h2><p>代码编写完后，我们要想测试，只需要打开浏览器直接输入地址发送请求即可。发送的是GET请求可以直接使用浏览器，但是如果要发送的是POST请求呢？如果要求发送的是post请求，我们就得准备页面在页面上准备form表单，测试起来比较麻烦。所以我们就需要借助一些第三方工具，如PostMan。</p><h2 id="PostMan安装"><a href="#PostMan安装" class="headerlink" title="PostMan安装"></a>PostMan安装</h2><p><a href="https://www.postman.com/downloads/">官网链接下载</a></p><p>注册一个账号直接来到这个界面：</p><img src="image-20230606092337492.png" alt="image-20230606092337492" style="zoom:67%;" /><h2 id="PostMan使用"><a href="#PostMan使用" class="headerlink" title="PostMan使用"></a>PostMan使用</h2><h3 id="创建WorkSpace工作空间"><a href="#创建WorkSpace工作空间" class="headerlink" title="创建WorkSpace工作空间"></a>创建WorkSpace工作空间</h3><img src="image-20230606092805094.png" alt="image-20230606092805094" style="zoom:67%;" /><img src="image-20230606092858754.png" alt="image-20230606092858754" style="zoom:67%;" /><img src="image-20230606092948897.png" alt="image-20230606092948897" style="zoom:67%;" /><img src="image-20230606093406445.png" alt="image-20230606093406445" style="zoom:67%;" /><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><img src="image-20230606093645158.png" alt="image-20230606093645158" style="zoom:67%;" /><p>也可以请求访问我们在Tomcat返回的页面：</p><p><img src="image-20230606094044962.png" alt="image-20230606094044962"></p><img src="image-20230606094234798.png" alt="image-20230606094234798" style="zoom:77%;" /><h3 id="保存当前请求"><a href="#保存当前请求" class="headerlink" title="保存当前请求"></a>保存当前请求</h3><img src="image-20230606094500001.png" alt="image-20230606094500001" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;PostMan是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件，常用于进行接口测试。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringMVC" scheme="https://kicheng.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>04-AOP</title>
    <link href="https://kicheng.github.io/2023/06/02/04-AOP/"/>
    <id>https://kicheng.github.io/2023/06/02/04-AOP/</id>
    <published>2023-06-02T03:33:15.000Z</published>
    <updated>2023-06-04T04:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面对Spring介绍时说过，Spring有两个核心的概念，一个是IOC/DI，另一个就是AOP。接下来要学习AOP了，AOP总的来说就是在不改变原有代码的前提下对其进行增强。</p><span id="more"></span><h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><p>AOP(Aspect Oriented Programming)面向切面编程，是一种编程范式，指导开发者组织程序结构。（熟知的oop也是一种编程范式）</p><h3 id="AOP作用"><a href="#AOP作用" class="headerlink" title="AOP作用"></a>AOP作用</h3><p>在不惊动原始设计的基础上为其进行功能增强。（前面有技术可以实现这样的功能，即代理模式）</p><h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p>Spring的AOP的核心就是在不改动原始代码的前提下，想给谁添加功能就给谁添加，这个也是Spring的理念：无侵入式。</p><p>那Spring是如何做到的呢？</p><p><img src="image-20230602170709205.png" alt="image-20230602170709205"></p><ul><li><p>连接点：Spring的AOP是对一个类的方法在不进行任何修改前提下进行增强。对于save, update, delete, select方法，叫做<strong>连接点</strong>。</p></li><li><p>切入点：update和delete只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能；那也就是说update和delete方法都已经被增强，所以对于需要增强的方法我们给起了一个名字叫<strong>切入点</strong>（匹配连接点进行数据增强的式子）。</p></li><li><p>通知：执行update和delete方法时都被添加了一个计算执行万次消耗时间的功能，将这个功能抽取到一个方法中，也就是一个存放共性功能的方法中，我们叫这个方法为<strong>通知</strong>（在切入点处执行的操作）；方法存在的类叫做<strong>通知类</strong>。</p></li><li><p>切面：通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，需要对通知和切入点的关系有一个明确的描述，这个关系描述我们叫做<strong>切面</strong>。</p></li></ul><h2 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h2><p>需求分析：使用SpringAOP的注解方式完成在方法执行前打印出系统当前时间。</p><h3 id="AOP操作思路"><a href="#AOP操作思路" class="headerlink" title="AOP操作思路"></a>AOP操作思路</h3><p>1、导入坐标（pom.xml）</p><p>2、制作连接点（原始操作，比如Dao接口和实现类）</p><p>3、制作共性功能（通知类与通知）</p><p>4、定义切入点（那些连接点需要被增强）</p><p>5、绑定切入点和通知的关系（切面）</p><h3 id="AOP实现步骤"><a href="#AOP实现步骤" class="headerlink" title="AOP实现步骤"></a>AOP实现步骤</h3><ul><li><p>导入<code>spring</code>和<code>aspectj</code>依赖坐标</p><p>aop依赖是spring的子包，所以不需要单独导入了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>制作连接点——添加Dao接口和Impl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;Book dao save...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book dao upodate...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringConfig配置类和App主程序运行类</p></li><li><p>定义通知类和通知</p><p>通知就是将共性功能抽取出来形成的方法，类名和方法名都自定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 将共性抽取出来形成的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义切入点（连接点中的哪些方法需要增强）</p><p>我们要增强连接点中的update方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">  <span class="comment">/* ======================================================== */</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="comment">/* ======================================================== */</span></span><br><span class="line">    <span class="comment">// 将共性抽取出来形成的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​    ① 切入点定义依托一个不具有实际意义的方法（无参数、无返回值、方法体无逻辑）进行；</p><p>​    ② <code>Pointcut</code>后面<code>execution</code>内的内容，是连接点的返回值+具体的连接点方法。</p><ul><li><p>制作切面（切面用来描述通知和切入点之间的联系）</p><p>指定通知添加到原始连接点的具体执行位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="comment">/* ======================================================== */</span></span><br><span class="line">  <span class="meta">@Before(&quot;fn()&quot;)</span>  <span class="comment">// 通知会在切入点方法执行之前执行</span></span><br><span class="line">  <span class="comment">/* ======================================================== */</span></span><br><span class="line">    <span class="comment">// 将共性抽取出来形成的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将通知类配给容器并标识其为切面类</p><p>将通知类通过<code>@Component</code>注释配置为一个Bean；再通过<code>@Aspect</code>注释将其配置为可以使用AOP的通知类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启注释格式AOP功能（<code>@EnableAspectJAutoProxy</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng&quot;)</span>  <span class="comment">// 默认会扫描该类所在的包下所有的配置类</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  <span class="comment">// 配置类中开启AOP功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAOP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现在执行update方法前打印了系统的时间戳，说明对原始update方法进行了功能增强，AOP编程成功。</p></li></ul><h3 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h3><p>1、配置类注解<code>@EnableAspectJAutoProxy</code>：开启注释格式的AOP功能；</p><p>2、通知类注解<code>@Aspect</code>：设置当前类为AOP切面类；</p><p>3、切入点方法注解<code>@Pointcut</code>，设置切入点方法；</p><p>4、通知方法注解<code>@Before</code>，设置当前通知方法与切入点之间的绑定关系。</p><h2 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h2><p>由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起。</p><h3 id="AOP流程"><a href="#AOP流程" class="headerlink" title="AOP流程"></a>AOP流程</h3><ul><li>流程1：Spring容器启动</li></ul><p>​        容器启动就需要去加载bean：像需要被增强的类、通知类等都需要被加载。（此时bean对象还没有被创建成功）</p><ul><li><p>流程2：读取所有切面配置中的切入点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.save())&quot;)</span>  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fnx</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;fn()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码有两个切入点的配置，但是第一个<code>fnx()</code>并没有被使用，所以不会被读取。</p></li><li><p>流程3：初始化bean</p><p>判定bean对应的类中的方法是否匹配到任意切入点：</p><img src="image-20230602194257798.png" alt="image-20230602194257798" style="zoom:67%;" /><ul><li>匹配失败：创建原始对象，如UserDao（匹配失败则说明不需要增强，直接调用原始对象的方法即可）；</li><li>匹配成功：创建原始对象的<strong>代理对象</strong>，如BookDao（匹配成功则说明需要增强，；对哪个类进行增强，这个类对应的对象就叫做目标对象；由于要对目标对象进行功能增强，而采用的是动态代理技术，所以会为其创建一个代理对象；最终运行的是代理对象的方法，该方法对原始方法进行了功能增强）。</li></ul></li><li><p>流程4：获取bean执行方法</p><ul><li>获取的bean是原始对象，调用方法并执行，完成操作；</li><li>获取的bean是代理对象，根据代理对象的运行模式运行原始方法和增强内容，完成操作。</li></ul></li></ul><blockquote><p>验证IOC容器中创建的对象是原始对象还是代理对象：通过<code>.getClass()</code>实现：</p><p><img src="image-20230602195821441.png" alt="image-20230602195821441"></p><p>值得注意的是：不能直接打印对象，因为直接打印对象走的是对象的toString()方法，内部对该方法进行了重写，无论是否是代理方法打印的结果都相同。</p></blockquote><h3 id="AOP核心概念-1"><a href="#AOP核心概念-1" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p>这里主要讲一下前面提到的目标对象和代理：</p><p>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的。</p><p>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象来实现。</p><p>目标对象就是要增强的类（比如说BookServiceImpl类）对应的对象，也叫原始对象，不是说他不能运行而是他在运行过程中对于要增强的内容是缺失的；SpringAOP是在不改变原有设计的前提下进行内容增强，他底层采用的是代理模式实现的，所以要对原始对象创建代理对象，在代理对象中的方法把通知内容（如MyAdvice类中的method方法）加进去，实现了增强，这就是我们所说的代理。</p><h2 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a>AOP配置管理</h2><h3 id="AOP切入点表达式"><a href="#AOP切入点表达式" class="headerlink" title="AOP切入点表达式"></a>AOP切入点表达式</h3><img src="image-20230602202402159.png" alt="image-20230602202402159" style="zoom:67%;" /><p>切入点：要进行增强的方法；切入点表达式：要进行增强的方法的描述方式。对于切入点表达式，需要掌握三块内容：语法格式、通配符、书写技巧。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><p>因为调用接口方法的时候最终运行的还是其实现类的方法，所以有两种表达式的描述方式：</p><p>描述方式1：执行BookDao接口下的无参update方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br></pre></td></tr></table></figure><p>描述方式2：执行BookDaoImpl实现类中的无参update方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.impl.BookDaoImpl.update())&quot;)</span></span><br></pre></td></tr></table></figure><p>所以切入点表达式的语法是：<code>动作关键词([访问修饰符] 返回值 包名.类/接口名.方法名(参数) [异常名])</code>，（”[]”表示可省略）</p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>切入点表达式就是要找到具体增强的方法，但是需要增强的方法有很多，如果每一个方法都要对应一个切入点表达式就比较繁琐，所以用通配符来描述切入点，简化之前的配置。</p><ul><li><p><code>*</code>：单个独立的任意符号，可以独立出现，也可以作为前缀或后缀的匹配符出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * com.Lijiacheng.*.UserService.find*(*))</span><br></pre></td></tr></table></figure><p>匹配com.Lijiacheng包下任意包中的UserService类或接口中所有find开头的带有一个方法参数的方法；</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> User com..UserService.findById(..))</span><br></pre></td></tr></table></figure><p>匹配com包下任意包中的UserService类或接口中所有名称为findById的方法；</p></li><li><p><code>+</code>：专用于匹配子类类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure><p>这个使用率很低。<code>*Service+</code>表示所有以Service结尾的接口的子类。</p></li></ul><h4 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h4><p>1、描述切入点通常描述接口，而不描述实现类，如果描述到实现类，就出现紧耦合；</p><p>2、访问控制修饰符针对接口开发均采用public（可省略）；</p><p>3、返回值类型对于增删改查使用精准匹配，对于查询类使用<code>*</code>快速匹配；</p><p>4、包名书写尽量不使用<code>..</code>匹配，效率过低；常使用<code>*</code>做单个包描述匹配，或精准匹配；</p><p>5、接口名/类名采用<code>*</code>匹配，例如UserService书写成*Service，绑定业务层接口；</p><p>6、方法名书写以动词精准匹配，例如getById书写成getBy*，selectAll书写成selectAll。</p><h3 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h3><p>AOP通知描述了抽取的共性功能，AOP需要将通知和切入点进行绑定，并指定增强内容的执行位置。</p><h4 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h4><p>1、前置通知：追加功能到方法执行前；</p><p>2、后置通知：追加功能到方法执行后，不论方法执行过程中有没有抛出异常都会执行；</p><p>3、返回后通知：追加功能到方法执行后，但是只有方法正常执行结束后才进行，如果方法执行抛出异常，返回后通知将不被执行；</p><p>4、抛出异常后通知：追加功能到方法抛出异常后，只有方法抛出异常后才会被添加；</p><p>5、环绕通知：可以追加到方法执行的前后，最常用的方式。</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>具体就不展开了，创建好的项目结构如下：</p><img src="image-20230603105052343.png" alt="image-20230603105052343" style="zoom:67%;" /><h4 id="通知类型的使用"><a href="#通知类型的使用" class="headerlink" title="通知类型的使用"></a>通知类型的使用</h4><ul><li><p>前置通知：修改MyAdvice，在before方法上加<code>@Before</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;before advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-20230603105857801.png" alt="image-20230603105857801"></p><ul><li><p>后置通知：修改MyAdvice，加<code>@After</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;after advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230603110109029.png" alt="image-20230603110109029"></p></li><li><p>环绕通知：修改MyAdvice，加<code>@Around</code>注解</p><p>相比于前置和后置通知，环绕通知需要在原始内容的前后进行内容增强，所以我们需要指定哪些内容在原始内容前执行，哪些内容在原始内容后执行，所以必须能对原始操作进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.Lijiacheng.dao.BookDao.update())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;around before advice...&quot;</span>);</span><br><span class="line">      pjp.proceed();  <span class="comment">// 对原始操作进行调用</span></span><br><span class="line">      System.out.println(<span class="string">&quot;around after advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-20230603112123746.png" alt="image-20230603112123746"></p><p>​    刚才针对的是原始方法无返回值的情况，原始方法有返回值的情况如何处理呢？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* =================实现类中的原始方法=============== */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Book dao select is running...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    修改通知，返回值设置为通用的Object基类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* =================通知类======================== */</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(int com.Lijiacheng.dao.BookDao.select())&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Around(&quot;pt2()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;around before advice...&quot;</span>);</span><br><span class="line">      <span class="comment">// 对原始操作进行调用</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">      System.out.println(<span class="string">&quot;around after advice...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    当原始方法有返回值时，需要根据原始方法的返回值设置环绕通知的返回值，否则就会报如下的错误：大概意思是空的返回不匹配原始方法的返回值。</p><p><img src="image-20230603112555069.png" alt="image-20230603112555069"></p><ul><li><p>返回后通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;pt2()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;afterReturning advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>​    返回后通知是需要在原始方法select正常执行后才会被执行，如果select方法在执行过程中出现了异常，那么返回后通知是不会被执行的（而后置通知是无论是否抛出异常都会被执行）：</p><p><img src="image-20230603124407104.png" alt="image-20230603124407104"></p><ul><li><p>异常后通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(&quot;pt2()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;afterThrowing advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>异常后通知只有在抛出异常时才会被执行：</p><p><img src="image-20230603124717297.png" alt="image-20230603124717297"></p></li></ul><p>​    <strong>环绕通知总结</strong>：环绕通知可以控制原始方法执行，所以把增强的代码写在调用原始方法的前后位置，就可以实现不同通知类型的功能：</p><img src="image-20230603124957569.png" alt="image-20230603124957569" style="zoom:67%;" /><p>​            （1）环绕通知依赖形参<code>ProceedingJoinPoint</code>才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知；</p><p>​            （2）环绕通知未使用<code>ProceedingJoinPoint</code>调用原始方法，将跳过原始方法的执行；</p><p>​            （3）最好将环绕通知的返回值都设置成Object；</p><p>​            （4）环绕通知无法预知调用的原始方法是否会抛出异常，所以在通知方法要手动抛出Throwable异常。</p><h3 id="业务层接口执行效率"><a href="#业务层接口执行效率" class="headerlink" title="业务层接口执行效率"></a>业务层接口执行效率</h3><p>需求分析：任意业务层接口执行均可显示其执行时长。</p><p>实现思路：开始执行方法前记录一个时间，执行方法结束后记录一个时间，得到的时间差值就是执行效率。要在原始方法前后添加业务，就用到环绕通知。</p><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><p>具体就不展开了，如果不熟悉了要记得复习前面的博客，创建好的项目结构如下：</p><img src="image-20230603170251563.png" alt="image-20230603170251563" style="zoom:80%;" /><h4 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h4><p>步骤1：开启SpringAOP的注释功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br></pre></td></tr></table></figure><p>步骤2：创建AOP的通知类</p><p>① 通知类要被Spring管理，添加<code>@Component</code>注释；② 要标识通知类是个切面类，添加<code>@Aspect</code>注释；③ 配置切入点表达式，需要添加一个方法并添加<code>@Pointcut</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.Lijiacheng.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤3：添加环绕通知（目前没有任何增强）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4：完成核心业务，记录万次执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">    pjp.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;万次执行时间为: &quot;</span> + (endTime-startTime) + <span class="string">&quot; ms&quot;</span>);</span><br></pre></td></tr></table></figure><p>步骤5：运行单元测试类（注意看单元测试类怎么写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTestCase</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Account&gt; acs = accountService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是此时无法知道是哪个接口的哪个方法执行耗时：</p><p><img src="image-20230603225751338.png" alt="image-20230603225751338"></p><p>所以我们要对步骤4的核心业务代码进行优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="comment">// 获取执行签名信息</span></span><br><span class="line">      <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getSignature();</span><br><span class="line">      <span class="comment">// 通过签名获取执行操作名称(接口名)</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">      <span class="comment">// 通过签名获取执行操作名称(方法名)</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">      <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">          pjp.proceed();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;万次执行时间为: &quot;</span> + className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;-----&gt;&quot;</span> + (endTime-startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230603230159251.png" alt="image-20230603230159251"></p><h3 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h3><p>刚才写AOP仅是在原始方法前后追加一些操作，接下来要说一下AOP中数据相关内容，主要有：获取参数、获取返回值、获取异常。</p><ul><li><p>获取切入点方法的参数</p><ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedingJoinPoint：适用于环绕通知</li></ul></li><li><p>获取切入点方法的返回值：主要研究返回后通知和环绕通知；</p></li><li><p>获取切入点方法的异常信息：主要研究抛出异常后通知和环绕通知。</p></li></ul><h4 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h4><p><img src="image-20230603235831233.png" alt="image-20230603235831233"></p><h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><ul><li><p>非环绕通知获取方式：在方法上添加JoinPoint，通过JoinPoint来获取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;fn()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">      Object[] args = jp.getArgs();</span><br><span class="line">      System.out.println(Arrays.toString(args));  <span class="comment">// 将数组以字符串的形式输出</span></span><br><span class="line">      System.out.println(<span class="string">&quot;before advice...&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知获取方式：环绕通知使用的是ProceedingJoinPoint</p><p>因为ProceedingJoinPoint是JoinPoint类的子类，所以ProceedingJoinPoint一定有getArgs()方法.</p><p><img src="image-20230604095226979.png" alt="image-20230604095226979"></p><p>此外值得注意的是，<code>pjp.proceed</code>有两个方法都可以完成功能：①调用无参数的proceed方法，当原始方法有参数时，会在调用的过程中自动传入参数；②但是当需要修改原始方法的参数时，必须采用带有参数的proceed方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;fn()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span><span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">      Object[] args = pjp.getArgs();</span><br><span class="line">      System.out.println(Arrays.toString(args));</span><br><span class="line">      args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);  <span class="comment">// 将args作为参数传回原始调用方法</span></span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>有了这个特性后，我们就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，保证代码的健壮性。</p></blockquote></li></ul><h4 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h4><p>对于返回值只有返回后AfterReturing和环绕Around这两个通知类型可以获取。</p><ul><li><p>环绕通知获取返回值</p><p>和环绕通知获取参数一样，ret就是方法的返回值，我们是可以直接获取，不但可以获取，如果需要还可以进行修改。</p></li><li><p>返回后通知获取返回值（注意<code>returning</code>的值与通知方法的形参名一定要一致！）</p></li></ul><p><img src="image-20230604100651690.png" alt="image-20230604100651690"></p><p>​    根据以下代码分析一下程序执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ===================主程序执行======================= */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> bookDao.findName(<span class="number">100</span>, <span class="string">&quot;hfut&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">/* ===================实现类======================== */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;lijiacheng&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    首先调用bookDao接口中的切入点方法findName，由于切面是返回后通知，所以优先执行原始方法；原始方法将返回值“lijiacheng”赋值给name变量后，执行返回后通知的增强内容，也就是获取返回值并将返回值修改为”liaoziting”并打印；最后一步再打印出第一步得到的name变量值。如下结果所示：</p><p><img src="image-20230604101417654.png" alt="image-20230604101417654"></p><blockquote><p>有一个非常关键的点，当AfterReturning有JoinPoint参数时，必须将其放在第一位，否则将会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint jp, Object ret)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="获取异常（了解）"><a href="#获取异常（了解）" class="headerlink" title="获取异常（了解）"></a>获取异常（了解）</h4><p>对于获取抛出异常，只有抛出异常后AfterThrowing和环绕Around这两个通知可以获取。</p><ul><li><p>环绕通知获取异常：以前我们是抛出异常，现在只需要将异常捕获，就可以获取到原始方法的异常信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;fn()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">      Object[] args = pjp.getArgs();</span><br><span class="line">      System.out.println(Arrays.toString(args));</span><br><span class="line">      args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ret = pjp.proceed(args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>抛出异常后通知获取异常：也是要注意<code>throwing</code>的值和通知方法的形参值要一致！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;fn()&quot;, throwing = &quot;t&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;afterThrowing advice... ----&gt;&quot;</span> + t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="image-20230604102743788.png" alt="image-20230604102743788"></p><h3 id="AOP案例：百度网盘密码数据兼容处理"><a href="#AOP案例：百度网盘密码数据兼容处理" class="headerlink" title="AOP案例：百度网盘密码数据兼容处理"></a>AOP案例：百度网盘密码数据兼容处理</h3><p>需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理。</p><p>以后涉及到需要去除前后空格的业务可能会有很多，这个去空格的代码是每个业务都写么？当功能的泛化性很强时，我们考虑使用AOP来统一处理。要做到这一点，我们先要在业务方法执行之前对所有的输入参数进行格式处理、再使用处理后的参数调用原始方法。</p><p>因为要先获取原始方法的参数，进行处理后再将参数传回给原始方法，所以必须用到<code>ProceedingJoinPoint</code>中的proceed方法，也就是只能使用环绕通知来实现。</p><h4 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h4><img src="image-20230604105322777.png" alt="image-20230604105322777" style="zoom:80%;" /><p>当输入密码为”root”控制台打印为true,如果密码改为” root “（前后有空格）控制台打印的是false。需求是使用AOP将参数进行统一处理，不管输入的密码前后包含多少个空格，最终控制台打印的都是true。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>不多叨叨，直接展示业务核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;fn()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">passwordTrim</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 核心业务 1、获取参数并格式处理  2、交还给原始方法</span></span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 判断是否为字符串</span></span><br><span class="line">        <span class="keyword">if</span>(args[i].getClass().equals(String.class))&#123;</span><br><span class="line">            args[i] = args[i].toString().trim();  <span class="comment">// toString()返回对象的字符串形式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP总结-1"><a href="#AOP总结-1" class="headerlink" title="AOP总结"></a>AOP总结</h2><p><strong>AOP（Aspect Oriented Programming）面向切面编程</strong></p><p>AOP是一种编程范式，作用是在不惊动原始设计的基础上为方法进行功能增强。</p><p>（1）代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的</p><p>（2）连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行</p><p>（3）切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述</p><p>（4）通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法</p><p>（5）切面（Aspect）：描述通知与切入点的对应关系</p><p>（6）目标对象（Target）：被代理的原始对象称为目标对象</p><p><strong>切入点表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([访问修饰符] 返回值 包名.类/接口名.方法名（参数）[异常名])</span><br></pre></td></tr></table></figure><p>三种通配符：<code>*</code>, <code>..</code>, <code>+</code>.</p><p><strong>五种通知类型</strong></p><p>前置通知、后置通知、环绕通知（重点）、返回后通知、抛出异常后通知.</p><p>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用；它可以隔离原始方法的执行；它可以获取原始方法的参数或返回值并进行修改再交还给原始方法；它可以对原始方法的异常进行处理。</p><p><strong>通知中获取参数</strong></p><ul><li><p>获取切入点方法的参数：JoinPoint和ProceedingJoinPoint</p></li><li><p>获取切入点方法返回值<code>Returning</code>：返回后通知、环绕通知</p></li><li><p>获取切入点方法运行异常信息<code>Throwing</code>：抛出异常后通知、环绕通知</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面对Spring介绍时说过，Spring有两个核心的概念，一个是IOC/DI，另一个就是AOP。接下来要学习AOP了，AOP总的来说就是在不改变原有代码的前提下对其进行增强。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://kicheng.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>03-Spring整合三方框架</title>
    <link href="https://kicheng.github.io/2023/06/01/03-Spring%E6%95%B4%E5%90%88%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    <id>https://kicheng.github.io/2023/06/01/03-Spring%E6%95%B4%E5%90%88%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/</id>
    <published>2023-06-01T03:33:15.000Z</published>
    <updated>2023-06-04T04:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring有一个容器，叫做IoC容器，里面保存bean。在进行企业级开发的时候，除了将自己写的类让Spring管理之外，还有一部分重要的工作就是使用第三方的技术。前面已经讲了如何管理第三方Bean了，下面结合IoC和DI，整合Mybatis框架，加深对Spring的理解。</p><span id="more"></span><h2 id="Spring整合Mybatis（2）"><a href="#Spring整合Mybatis（2）" class="headerlink" title="Spring整合Mybatis（2）"></a>Spring整合Mybatis（2）</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring有一个容器，叫做IoC容器，里面保存bean。在进行企业级开发的时候，除了将自己写的类让Spring管理之外，还有一部分重要的工作就是使用第三方的技术。前面已经讲了如何管理第三方Bean了，下面结合IoC和DI，整合Mybatis框架，加深对Spring的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://kicheng.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Git实现多台电脑同步工作</title>
    <link href="https://kicheng.github.io/2023/05/26/git/"/>
    <id>https://kicheng.github.io/2023/05/26/git/</id>
    <published>2023-05-26T08:56:31.000Z</published>
    <updated>2023-06-30T11:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年新买了一台mac台式机放在宿舍，就不用每天回到宿舍还要把笔记本插上各种线再启动了。有时候在外面写的代码想要回到宿舍继续用台式机写，所以我需要在两台电脑之间实现无缝协作，即需求：<strong>两台电脑里同一个文件夹的内容可以相互同步</strong>。</p><span id="more"></span><p>首先说一下，我下面总结的只是我使用git的一个小应用，git的功能强大作用远远不止这些，更多的功能仍然等待着去挖掘呢。</p><blockquote><p>安装Git：下载地址 <a href="https://git-scm.com/download">https://git-scm.com/download</a> ，安装一路点next即可。</p></blockquote><img src="image-20230516105819093.png" alt="image-20230516105819093" style="zoom: 50%;" /><h2 id="构建本地仓库"><a href="#构建本地仓库" class="headerlink" title="构建本地仓库"></a>构建本地仓库</h2><p>1、在本地建立一个目录，在该目录里防止需要同步的文件。</p><img src="image-20230516104922621.png" alt="image-20230516104922621" style="zoom:67%;" /><p>2、在当前目录下打开git控制台</p><p>界面为：</p><img src="image-20230516105212427.png" alt="image-20230516105212427" style="zoom: 50%;" /><p>3、初始化本地仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>输出<code>Initialized empty Git repository in C:/Users/13668/Desktop/git/.git/</code> 即成功。</p><p>4、Add文件到暂存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>上述命令是添加所有文件到暂存区，但不包含已删除的。或者使用<code>git add xxx(文件名)</code>来添加指定文件。</p><p>5、commit文件到本地仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交注释&quot;</span><br></pre></td></tr></table></figure><p>提交注释为本次提交的说明，这里我直接使用提交的日期作为提交注释。</p><h2 id="将本地仓库推送到github上"><a href="#将本地仓库推送到github上" class="headerlink" title="将本地仓库推送到github上"></a>将本地仓库推送到github上</h2><p>1、在github上创建新仓库</p><p><img src="image-20230516110734048.png" alt="image-20230516110734048"></p><p><strong>2、将本地仓库与远程仓库关联</strong></p><p>一个新建的空仓库会有一个提示页面，对应不同情况的操作命令。我们现在已经创建好本地仓库，需要做的就是将本地仓库推送到远程，也就是情况2。直接复制提示页面给出的命令即可。</p><p><img src="image-20230516110844342.png" alt="image-20230516110844342"></p><ul><li><p>添加远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:KiCheng/Git.git</span><br></pre></td></tr></table></figure><p><img src="D:\spring\image-20230516111217156.png" alt="image-20230516111217156"></p><p>可以通过如下命令查看与本地仓库关联的远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><blockquote><p>输出如下：</p><p>origin  <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;</a>:KiCheng/Git.git (fetch)<br>origin  <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;">&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a>:KiCheng/Git.git (push)</p></blockquote><p>删除与远程仓库的关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li><li><p>推送到远程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><img src="image-20230516111627417.png" alt="image-20230516111627417" style="zoom:67%;" /><p>再次刷新github中的仓库，本地仓库的内容已经推送到远程了。</p><p><img src="image-20230516111723812.png" alt="image-20230516111723812"></p></li></ul><h2 id="将远程仓库clone到本地"><a href="#将远程仓库clone到本地" class="headerlink" title="将远程仓库clone到本地"></a>将远程仓库clone到本地</h2><p>在另一台安装好了git的电脑上，在文件夹目录下打开git控制台。输入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:账户名/仓库名.git</span><br></pre></td></tr></table></figure><p>将上述替换成自己的github账户名和仓库名：</p><p><img src="image-20230526165230679.png" alt="image-20230526165230679"></p><p>这就说明clone成功了，在当前文件夹就可以找到远程备份的文件了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年新买了一台mac台式机放在宿舍，就不用每天回到宿舍还要把笔记本插上各种线再启动了。有时候在外面写的代码想要回到宿舍继续用台式机写，所以我需要在两台电脑之间实现无缝协作，即需求：&lt;strong&gt;两台电脑里同一个文件夹的内容可以相互同步&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://kicheng.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>02-Spring注解开发</title>
    <link href="https://kicheng.github.io/2023/04/05/02-Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    <id>https://kicheng.github.io/2023/04/05/02-Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</id>
    <published>2023-04-04T16:08:54.000Z</published>
    <updated>2023-06-04T03:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Part1记录了关于IOC/DI的配置开发，但是使用起来相对来说还是比较复杂的，要想真正简化开发，就需要用到Spring的注解开发。</p><span id="more"></span><p>关于Spring的注解开发，从Spring2.0开始支持注解，Spring3.0已经支持纯注解开发。关于注解开发，主要学习两块内容：注解开发定义bean和纯注解开发。</p><h2 id="IOC-DI注解开发"><a href="#IOC-DI注解开发" class="headerlink" title="IOC/DI注解开发"></a>IOC/DI注解开发</h2><p>使用注解开发，也就意味着我们需要通过注解的方式，来取代Spring配置文件中的内容。</p><h3 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h3><p>注解定义bean和纯注解开发是有本质区别的，后者完全摒弃了Spring配置文件，而注解定义bean还需要配置文件来做一些工作（包扫描）。</p><ul><li><p>步骤1：配置Spring的注解包扫描</p><p>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描（在配置文件中定义<code>context</code>的命名空间）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.Lijiacheng&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>步骤2：在Dao类和Service类上添加<code>@Component</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行注解取代了在配置文件中通过<code>&lt;bean&gt;</code>中的<code>id</code>和<code>class</code>属性定义bean。</p><blockquote><p>@Component注解不可以添加在接口上，因为接口是无法创建对象的。</p></blockquote></li><li><p>步骤3：在App类中，从IOC容器中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">System.out.println(userDao);</span><br><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> ctx.getBean(UserServiceImpl.class);  <span class="comment">// 按类型获取bean</span></span><br><span class="line">System.out.println(userService);</span><br></pre></td></tr></table></figure><p><code>@Component</code>注解如果不起名称，要么通过类型获取bean；要么有一个默认值就是当前类名首字母小写，所以也可以按照名称获取。</p></li></ul><p><strong>@Component的作用是设置该类为spring管理的bean。</strong>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>，这三个注解和@Component注解的作用是一样的，只是方便我们后期在编写类的时候能很好的区分出这个类是属于表现层、业务层、数据层的类。</p><h3 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h3><p>Spring3.0开启了纯注解开发模式，使用Java类替代Spring配置文件。</p><ul><li><p>创建一个类，并将其用注解配置为配置类：替换<code>applicationContext.xml</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用注解替换包扫描配置：<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code>（多个数据用数组格式）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>创建运行类并执行：new一个<code>AnnotationConfigApplicationContext</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">System.out.println(userDao);</span><br></pre></td></tr></table></figure></li></ul><p><strong>@Configuration作用是设置该类为spring配置类；@ComponentScan作用是设置spring配置类扫描路径，用于加载使用注解格式定义的bean。</strong></p><h3 id="注解开发Bean作用范围与生命周期管理"><a href="#注解开发Bean作用范围与生命周期管理" class="headerlink" title="注解开发Bean作用范围与生命周期管理"></a>注解开发Bean作用范围与生命周期管理</h3><h4 id="Bean作用范围"><a href="#Bean作用范围" class="headerlink" title="Bean作用范围"></a>Bean作用范围</h4><p>要想将UserDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span>  <span class="comment">// //@Scope设置bean的作用范围</span></span><br></pre></td></tr></table></figure><p>设置该类创建对象的作用范围，可用于设置创建出的bean是否为单例对象。默认值singleton（单例），可选值prototype（非单例）。</p><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><ul><li><p>为了使用@PostConstruct和@PreDestroy注解，导入<code>annotation</code>的坐标依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在响应bean类中添加初始化和销毁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注解开发 小结</strong></p><img src="image-20230404162053485.png" alt="image-20230404162053485" style="zoom: 50%;" /><h3 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h3><p>Spring为了使用注解简化开发，并没有提供构造函数注入、setter注入对应的注解，只提供了自动装配的注解实现。</p><h4 id="注解实现按照类型注入"><a href="#注解实现按照类型注入" class="headerlink" title="注解实现按照类型注入"></a>注解实现按照类型注入</h4><p>在UserServiceImpl类的userDao属性上添加<code>@Autowired</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired写在属性上，并将setter方法删除掉。</p><p>由于@Autowired是按照类型注入，那么对应UserDao接口如果有多个实现类，这时候运行类就会报错，因为按类型注入就不知道注入哪个对象了，所以要用按名称注入。</p><p>还一种解决方案是可以给两个Dao实现类分别起名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;&#125;</span><br><span class="line"><span class="meta">@Component(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>此时就可以注入成功！@Autowired是按照类型注入的，尽管它还是有两个bean对象，但是由于：@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫userDao而容器中也有一个userDao，所以可以成功注入。</p><p>但是这种情况就找不到响应的Bean对象，因为容器中没有名称为userDao1或者userDao2的对象：</p><img src="image-20230404172257071.png" alt="image-20230404172257071" style="zoom:67%;" /><h4 id="注解实现按照名称注入"><a href="#注解实现按照名称注入" class="headerlink" title="注解实现按照名称注入"></a>注解实现按照名称注入</h4><p>当根据类型在容器中找到多个bean，注入参数的属性名又和容器中bean的名称不一致（如上图情况），这个时候该如何解决？就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在依赖注入自动装配时，在属性名上用<code>@Qualifier</code>来指定注入名称为 UserDao2 的bean对象（一定要配合<code>Autowired</code>注解使用）。</p><h4 id="简单数据类型注入"><a href="#简单数据类型注入" class="headerlink" title="简单数据类型注入"></a>简单数据类型注入</h4><p>因为Spring只提供了自动装配注入的注解，而自动装配只能注入引用类型的数据。简单类型注入的是基本数据类型或者字符串类型，下面在<code>UserDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;lijiacheng&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><p>注释从<code>@Autowire</code>换成了<code>@Value()</code>，在括号内对属性进行赋值，注意数据格式要匹配。</p><h4 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h4><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用.</p><ul><li><p>使用注解加载properties配置文件：在配置类上添加<code>@PropertySource</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>@Value</code>读取配置文件中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上，代表从当前项目的根路径找文件（但不支持使用通配符<code>*</code>）。</p></blockquote><p><strong>注解开发依赖注入 小结</strong></p><ul><li><p><code>@Autowired</code>：为引用类型属性设置值；</p></li><li><p><code>@Qualifier</code>：为引用类型属性指定注入的bean id；</p></li><li><p><code>@Value</code>：为基本数据类型或字符串类型属性依赖注入并设置值；</p></li><li><p><code>@PropertySource</code>：加载properties文件中的属性值。</p></li></ul><h2 id="IOC-DI注解开发管理第三方Bean"><a href="#IOC-DI注解开发管理第三方Bean" class="headerlink" title="IOC/DI注解开发管理第三方Bean"></a>IOC/DI注解开发管理第三方Bean</h2><h3 id="注解开发管理第三方Bean"><a href="#注解开发管理第三方Bean" class="headerlink" title="注解开发管理第三方Bean"></a>注解开发管理第三方Bean</h3><p>前面定义Bean的时候都是在自己开发的类上面写个注解就完事，但如果是第三方的类，这些类都是在jar包中，我们没有办法在类上面添加注解，第三方的Bean该如何管理？下面以Druid数据源来举例。</p><ul><li><p>导入对应的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在SpringConfig配置类中添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>);</span><br><span class="line">    ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    ds.setPassword(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的返回值就是要创建的Bean对象类型；但new的时候不能new这个<code>DataSource</code>类型，因为DataSource接口中没有对应的setter方法来设置属性。</p></li><li><p>在方法上添加<code>@Bean</code>注解</p></li><li><p>从IOC容器中获取对象并打印：按类型获取bean对象</p></li></ul><blockquote><p>如果有多个bean要被Spring管理，直接在配置类中多些几个方法，方法上添加@Bean注解即可。</p></blockquote><h3 id="引入外部配置类"><a href="#引入外部配置类" class="headerlink" title="引入外部配置类"></a>引入外部配置类</h3><p>如果把所有的第三方bean都配置到Spring的配置类SpringConfig中，虽然可以，但是不利于代码阅读和分类管理，所以我们就想能不能按照类别将这些bean配置到不同的配置类中?</p><p>对于数据源的bean,我们新建一个<code>JdbcConfig</code>配置类，并把数据源配置到该类下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类如何能被Spring配置类加载到，并在IOC容器中创建DataSource对象？对此有两个解决方案。</p><h4 id="使用包扫描引入"><a href="#使用包扫描引入" class="headerlink" title="使用包扫描引入"></a>使用包扫描引入</h4><p>使用包扫描引入的两个关键点，如果前面书写的代码规范，则这里不需要添加或修改代码：① 在每一个bean的配置类上加注释将其配置为配置类<code>@Configuration</code>； ② 在<code>SpringConfig</code>配置类中添加包扫描<code>@ComponentScan(&quot;com.itheima.config&quot;)</code>.</p><p>这种方式虽然能够扫描到，但是不能很快的知道都引入了哪些配置类，所以这种方式不推荐使用。</p><h4 id="使用-Import引入"><a href="#使用-Import引入" class="headerlink" title="使用@Import引入"></a>使用<code>@Import</code>引入</h4><p>这种方案可以不用在每一个bean的配置类加<code>@Configuration</code>注解，但是必须在<code>SpringConfig</code>配置类上使用<code>@Import</code>注解手动引入需要加载的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>通过@Import引入配置类，不需要在每一个bean配置类加配置注解，而且Spring配置类中的扫描注解可以移除；</li><li>@Import参数需要的是一个数组，可以引入多个配置类。</li></ul></blockquote><p><strong>引入外部配置类 小结</strong></p><ul><li><code>@Bean</code>是一种方法注解，作用是设置该方法的返回值作为spring管理的bean；</li><li><code>@Import</code>是一种类注解，作用是在SpringConfig配置类中定义导入的配置类类名。</li></ul><h3 id="注解开发为第三方Bean注入资源"><a href="#注解开发为第三方Bean注入资源" class="headerlink" title="注解开发为第三方Bean注入资源"></a>注解开发为第三方Bean注入资源</h3><p>在使用<code>@Bean</code>创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办？这些资源分为简单数据类型和引用数据类型。</p><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><p>对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JdbcConfig配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc.url&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc.username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc.password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将连接数据库的四要素定义成属性，并通过<code>@Value()</code>设置值注入简单数据类型的依赖，并从<code>jdbc.properties</code>配置中读取相应的属性值进行设置（配置类需要使用<code>@PropertySource(&quot;properties配置文件&quot;)</code>注解）。</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>假设在构建DataSource对象的时候，需要用到UserDao对象，该如何把BookDao对象注入进方法内让其使用呢？</p><ul><li><p>在SpringConfig中扫描UserDao（扫描Dao包）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.Lijiacheng.dao&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>在JdbcConfig类的方法上添加形参参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(driver);</span><br><span class="line">    ds.setUrl(url);</span><br><span class="line">    ds.setUsername(userName);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。</p></blockquote></li></ul><h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><p>前面我们已经完成了XML配置和注解的开发实现，至于两者之间的差异，咱们放在一块去对比回顾下：</p><img src="image-20230404194721834.png" alt="image-20230404194721834" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;Part1记录了关于IOC/DI的配置开发，但是使用起来相对来说还是比较复杂的，要想真正简化开发，就需要用到Spring的注解开发。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://kicheng.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>01-IOC/DI</title>
    <link href="https://kicheng.github.io/2023/04/05/01-IOC_DI/"/>
    <id>https://kicheng.github.io/2023/04/05/01-IOC_DI/</id>
    <published>2023-04-04T16:02:48.000Z</published>
    <updated>2023-06-04T03:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架主要的优势是在<strong>简化开发</strong>和<strong>框架整合</strong>上，针对特点Spring的学习主线就是IOC、AOP、声明式事务和整合MyBais框架。Part1主要学习IOC容器中的bean、依赖注入以及核心容器。</p><span id="more"></span><h1 id="Spring相关概念"><a href="#Spring相关概念" class="headerlink" title="Spring相关概念"></a>Spring相关概念</h1><h2 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h2><p>在 <a href="https://spring.io/">Spring官网 </a>中提供了所有项目统称为Spring全家桶，我们主要需要掌握以下比较流行的技术：</p><img src="image-20230402153559808.png" alt="image-20230402153559808" style="zoom:50%;" /><ul><li>Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li><li>SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li><li>SpringCloud：这个是用来做分布式微服务架构的相关开发。</li></ul><h2 id="Spring系统架构"><a href="#Spring系统架构" class="headerlink" title="Spring系统架构"></a>Spring系统架构</h2><p>至今Spring已经更新到6.x版本，而下面的是4.x版本的架构图。Spring Framework 的系统架构图只是一种概念上的表示，具体实现和细节可能会根据具体应用场景进行调整和优化，所以我们以4.x版本为例来研究。</p><img src="image-20230402153914329.png" alt="image-20230402153914329" style="zoom:67%;" /><p>（1）核心层</p><ul><li>Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块；</li></ul><p>（2）AOP层</p><ul><li>AOP：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强；</li><li>Aspects：AOP是思想，Aspects是对AOP思想的具体实现；</li></ul><p>（3）数据层</p><ul><li>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术；</li><li>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis；</li><li>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容；</li></ul><p>（4）Web层</p><ul><li>这一层的内容将在SpringMVC框架具体学习；</li></ul><p>（5）Test层</p><ul><li>Spring主要整合了Junit来完成单元测试和集成测试。</li></ul><h2 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h2><p>这部分内容中主要包含 <code>IOC/DI</code> 、<code>IOC容器</code> 和 <code>Bean</code>。</p><h3 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h3><p>业务层需要调用数据层的方法，就需要在业务层new数据层的对象；如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署，导致项目代码的<strong>耦合度偏高</strong>。</p><img src="image-20230402154840495.png" alt="image-20230402154840495" style="zoom: 67%;" /><p>从上图我们也可以看到，业务层是通过new数据层的对象调用数据层的方法，从而造成耦合度高的问题。如果能把框中的内容给去掉，不就可以降低依赖了，但是如果直接去掉不做任何改动，会造成对象的NullPointer报错 。针对这个问题，Spring就提出了一个解决方案：在使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象，这种实现思想就是Spring的一个核心概念。</p><h3 id="IOC、IOC容器、Bean、DI"><a href="#IOC、IOC容器、Bean、DI" class="headerlink" title="IOC、IOC容器、Bean、DI"></a>IOC、IOC容器、Bean、DI</h3><p>1、IOC（Inversion of Control）控制反转</p><p>（1）控制反转：使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</p><p>（2）Spring和IOC的关系：Spring提供了一个容器，称为IOC容器，IOC思想中的“提供对象的外部”指的就是Spring的IOC容器。</p><p>（3）IOC容器：</p><ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象；</li><li>被创建或被管理的对象在IOC容器中统称为Bean，IOC容器中放的就是一个个的Bean对象；</li></ul><p>（4）在IOC容器中创建好service对象和dao对象后，要将service对象建立对dao对象的依赖关系，在容器中建立对象与对象之间的绑定关系就要用到 <strong>DI</strong>。</p><p>2、DI（Dependency Injection）依赖注入</p><img src="image-20230402155903628.png" alt="image-20230402155903628" style="zoom:67%;" /><p>依赖注入：在容器中建立bean与bean之间的依赖关系的整个过程称为依赖注入。如业务层需要依赖数据层，service就要和dao建立依赖关系。</p><p>使用<code>IOC</code>和<code>DI</code>到达最终解耦的目的，最终结果是使用对象可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系。</p><h2 id="IOC、DI入门案例"><a href="#IOC、DI入门案例" class="headerlink" title="IOC、DI入门案例"></a>IOC、DI入门案例</h2><p> 步骤1：在pom.xml导入<code>spring</code>依赖坐标；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤1.5：创建数据层和业务层代码</p><p>步骤2：在<code>resource</code>目录下创建spring的配置文件——<code>applicationContext.xml</code>，配置对应类作为Spring管理的Bean；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Bean定义时，id属性在同一个配置文件中不能重复。</p></blockquote><p>步骤3：使用Spring提供的接口<code>ApplicationContext</code>完成IOC容器的创建；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>步骤4：从IOC容器中获取对象进行方法调用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">userDao.save();</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.save();</span><br></pre></td></tr></table></figure><p>p.s. 标准的项目架构如下：</p><img src="image-20230402161011022.png" alt="image-20230402161011022" style="zoom:50%;" /><p>这时候在业务层仍然是用new创建了数据层的<code>UserDaoImpl</code>对象，为了实现IOC，还需要用到DI依赖注入。</p><p>步骤5：删除业务层中通过new方式创建的dao对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private UserDao userDao = new UserDaoImpl();</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><p>步骤6：提供对应的setter方法<em>（快捷键：Fn+Alt+Insert）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为不再程序中使用new对对象<code>UserDao</code>进行赋值操作，所以要为<code>UserDao</code>对象提供一个赋值的入口，就是setter方法，什么时候调用，谁来调用它会在后续提到。</p><p>步骤7：修改配置完成DI注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 7.配置service与dao的关系--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">               property标签表示配置当前的bean属性</span></span><br><span class="line"><span class="comment">               name属性表示配置的是哪一个具体的属性</span></span><br><span class="line"><span class="comment">               ref属性表示参照的是哪一个bean</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="image-20230402163443276.png" alt="image-20230402163443276"></p><h1 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h1><p>前面的入门案例尝试了bean如何定义配置、DI如何定义配置以及容器对象如何获取，接下来主要是把这三块内容展开进行详细的讲解。</p><h2 id="Bean基础配置"><a href="#Bean基础配置" class="headerlink" title="Bean基础配置"></a>Bean基础配置</h2><ul><li><p>Bean基础配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id：使用id可以获取对应的bean，在一个容器中id值是唯一的</li><li>class：bean的类型，配置的bean的全路径类名</li></ul></li><li><p>Bean别名配置：<code>name</code>属性</p><p>为bean指定别名，别名可以有多个，可以使用逗号、分号、空格进行分隔。这样从容器中获取bean对象时就可以使用name里的别名了（<code>ref</code>属性里指定的bean也可以使用别名，但正规写法是使用id属性）。</p><blockquote><p>如果抛出NoSuchBeanDefinitionException的异常，表示从IOC容器中找不到该bean，这时候要去检查配置文件bean中的id属性和name属性，是否和getbean中的参数对应一致。    </p></blockquote></li><li><p>Bean作用范围配置：<code>scope</code>属性</p><ul><li><code>singleton</code>：单例（默认）</li><li><code>prototype</code>：非单例</li></ul><p>将同一个bean获取两次，打印看地址输出是否一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="image-20230402170626816.png" alt="image-20230402170626816"></p><p>将<code>UserDao</code>这个bean配置为非单例模式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="image-20230402170741177.png" alt="image-20230402170741177"></p><blockquote><p>① bean默认为单例是在Spring的IOC容器中只会有该类的一个对象，避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高。</p><p>② 单例模式的bean：如果对象是有状态对象，即该对象有成员变量可以用来存储数据的；因为所有请求线程共用一个bean对象，所以会存在线程安全问题。反之则不存在线程安全问题。</p><p>③ 像表现层、业务层、数据层、工具类对象，这样的bean对象适合交给容器进行管理，它们在单例模式下不会存在线程安全问题，且对bean对象进行复用；而示例对象则不适合交给容器进行管理。</p></blockquote></li></ul><h2 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h2><p>现在bean已经放在了IOC容器中，那容器是如何进行bean的创建的呢？bean本质上是对象，通过new创建对象是调用类的构造方法，所以创建bean也是通过构造方法来完成的。</p><h3 id="构造方法实例化"><a href="#构造方法实例化" class="headerlink" title="构造方法实例化"></a>构造方法实例化</h3><p>在<code>UserDaoImpl</code>类中创建一个无参构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;userDaoImpl Constructor is running...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数：</p><img src="image-20230402190214395.png" alt="image-20230402190214395" style="zoom:80%;" /><p>每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，我们什么也不需要做，这也是我们以后比较常用的一种方式。</p><h3 id="静态工厂实例化"><a href="#静态工厂实例化" class="headerlink" title="静态工厂实例化"></a>静态工厂实例化</h3><p>1、工厂方式创建bean</p><p>（1）准备一个OrderDao和OrderDaoImpl类</p><p>（2）创建一个工厂类OrderDaoFactory并提供一个静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）编写AppForInstanceOrder运行类，在类中通过工厂获取对象</p><p>2、静态工厂实例化</p><p>现在bean对象已经创建好了，如何将bean交给Spring来管理呢？</p><p>（1）在spring的配置文件applicationContext.properties中添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.OrderDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>class：工厂类的类全名；</li><li>factory-mehod：具体工厂类中创建对象的方法名；</li></ul><p>（2）在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试（跟前面一致）。</p><blockquote><p>这种方式一般是用来兼容早期的一些老系统，过去使用工厂类创建对象，是为了在new基础上添加一些其他的业务内容。</p></blockquote><h3 id="实例工厂与FactoryBean"><a href="#实例工厂与FactoryBean" class="headerlink" title="实例工厂与FactoryBean"></a>实例工厂与FactoryBean</h3><p>1、实例工厂方式创建bean</p><p>（1）准备一个BookDao和BookDaoImpl类</p><p>（2）创建一个工厂类OrderDaoFactory并提供一个普通方法（注意此处和静态工厂的工厂类不同之处是方法不是静态方法）</p><p>（3）编写AppForInstanceBook运行类，在类中通过工厂获取对象</p><p>2、实例工厂实例化</p><p>（1）在spring的配置文件中添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.factory.BookDaoFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例化工厂的运行顺序：</p><ul><li><p>创建实例化工厂对象，对应的是第一行配置；</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置：</p><ul><li><p>factory-bean：工厂的实例对象（对应bean的id属性）</p></li><li><p>factory-method：工厂对象中的具体创建对象的方法名，对应关系如下:</p><img src="image-20230402194515616.png" alt="image-20230402194515616" style="zoom:67%;" /></li></ul></li></ul><p>（2）在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试。</p><p>3、FactoryBean</p><p>Spring为了简化实例工厂进行bean实例化的配置方式就提供了<code>FactoryBean</code>来简化开发。</p><p>（1）创建一个BookDaoFactoryBean的类，实现<code>FactoryBean</code>接口，重写接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;BookDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BookDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> BookDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>FactoryBean</code>接口中还有一个方法，默认是不需要重写的，就是<code>isSingleton()</code>，默认是单例模式<code>return true</code>.</p></blockquote><p>（2）在Spring的配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.factory.BookDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Bean实例化 小结</strong></p><ul><li>bean本质是对象，所以它是通过构造方法来创建的；</li><li>Spring的IOC实例化对象的三种方式分别是：构造方法、静态工厂、实例工厂，这些方式中主要掌握构造方法和实例工厂中的<code>FactoryBean</code>方法即可；</li><li>在使用构造方法实例化对象时，如果重写了构造方法，建议把无参默认构造方法也重写。</li></ul><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>bean的生命周期就是bean对象从创建到销毁的整体过程。</p><h3 id="生命周期设置"><a href="#生命周期设置" class="headerlink" title="生命周期设置"></a>生命周期设置</h3><ul><li>bean创建之后添加内容，比如用来初始化需要用到资源</li><li>bean销毁之前添加内容，比如用来释放用到的资源</li></ul><p>1、在配置文件添加method方式进行生命周期设置</p><p><strong>步骤1：</strong>添加初始化和销毁的方法（方法名任意）</p><p><strong>步骤2：</strong>配置生命周期</p><p>在配置文件中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>从执行结果来看，init方法执行了，但destroy方法没有执行。</p><blockquote><p>因为Spring的IOC容器是运行在JVM中，运行main方法后，JVM启动，Spring加载配置文件生成IOC容器，从容器获取bean对象，然后调方法执行main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了，所以没有调用对应的destroy方法。</p></blockquote><p>所以我们需要手动关闭容器来销毁bean。</p><ul><li><p>方式1：close关闭容器</p><p>ApplicationContext中没有close方法，需要把ApplicationContext换成它是实现类ClassPathXmlApplicationContext，再调用<code>close()</code>方法即可。</p></li><li><p>方式2：注册钩子关闭容器</p><p>提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.registerShutdownHook();  <span class="comment">// JVM退出前调用关闭，可以放在任意位置</span></span><br></pre></td></tr></table></figure></li></ul><p>2、实现接口方式进行生命周期设置</p><p>添加初始化和销毁方法，既需要编码也需要配置，实现起来步骤比较多也比较乱，Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code>。</p><p>修改UserServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><img src="image-20230402203450419.png" alt="image-20230402203450419" style="zoom:80%;" /><blockquote><p>Bean的声明周期和是否<code>getBean</code>没有关系，bean随着加载配置文件生成IOC容器而被创建出来，随着IOC的关闭而销毁。</p></blockquote><p>对于业务层的UserServiceImpl来说，userDao是它的一个属性，setUserDao方法是Spring的IOC容器为其注入属性的方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="comment">&lt;!-- setter为其注入name属性 --&gt;</span></span><br></pre></td></tr></table></figure><p>而<code>afterPropertiesSet()</code>意为”属性创建之后“，所以bean的初始化方法会在类中属性设置之后执行。</p><img src="image-20230402204437779.png" alt="image-20230402204437779" style="zoom:67%;" /><p><strong>bean的生命周期 小结</strong></p><p>（1）关于Spring中对bean生命周期控制提供了两种方式：</p><ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性；</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口（了解即可）。</li></ul><p>（2）bean的生命周期</p><ul><li>初始化容器<ul><li>创建对象（new内存分配）</li><li>执行构造方法</li><li>执行属性注入（setter操作）</li><li>执行bean初始化方法（init操作，生命周期开启）</li></ul></li><li>使用bean：执行业务操作</li><li>关闭/销毁容器：执行bean销毁方法（destroy）</li></ul><p>（3）关闭容器的两种方式：</p><ul><li><code>close()</code> 方法</li><li><code>registerShutdownHook()</code> 方法</li></ul><h1 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h1><p>向一个类中传递数据有2种方式：普通set方法、构造方法；依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，但有时bean运行需要的是数字或字符串。Spring基于上述为我们提供了2种注入方式：</p><ul><li>setter注入：引用类型、简单类型（这里将String归类到基本类型的注入中，但实际上String是个类，是引用数据类型）</li><li>构造器注入：引用类型、简单类型</li></ul><h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><h3 id="setter注入引用类型"><a href="#setter注入引用类型" class="headerlink" title="setter注入引用类型"></a>setter注入引用类型</h3><ul><li><p>在bean中声明引用类型属性，并提供可访问的set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置中使用<code>property</code>标签<code>ref</code>属性注入引用类型对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><img src="image-20230403094212301.png" alt="image-20230403094212301" style="zoom:80%;" /><p>现在userDao、userService、bookDao对象都已经被注入成功。</p><h3 id="setter注入简单类型"><a href="#setter注入简单类型" class="headerlink" title="setter注入简单类型"></a>setter注入简单类型</h3><ul><li><p>在bean中声明简单类型属性，并提供可访问的set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String databaseName;  <span class="comment">// 注入时把String看作简单类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDatabaseName</span><span class="params">(String databaseName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionNum</span><span class="params">(<span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置中使用<code>property</code>标签注入简单类型对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="image-20230403095128187.png" alt="image-20230403095128187" style="zoom:80%;" /></li></ul><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><h3 id="构造器注入引用数据类型"><a href="#构造器注入引用数据类型" class="headerlink" title="构造器注入引用数据类型"></a>构造器注入引用数据类型</h3><ul><li><p>删除属性的setter方法并提供构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置中使用<code>constructor-arg</code>标签注入引用类型对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>constructor-arg</code>标签中，name属性对应的值为<strong>构造函数中方法形参</strong>的参数名，必须要保持一致。</p></li></ul><img src="image-20230403101307018.png" alt="image-20230403101307018" style="zoom:80%;" /><h3 id="构造器注入简单数据类型"><a href="#构造器注入简单数据类型" class="headerlink" title="构造器注入简单数据类型"></a>构造器注入简单数据类型</h3><ul><li><p>删除属性的setter方法并提供构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String databaseName;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">    <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：添加完构造方法后在配置文件中出现bean中class属性的报错：</p><p><img src="image-20230403103009826.png" alt="image-20230403103009826"></p><p>意思是找不到匹配的构造函数，说明在使用构造函数创建bean的时候，默认的无参构造被覆盖了，只要重写一遍无参构造即可。</p></blockquote><ul><li><p>配置中使用<code>constructor-arg</code>标签注入简单类型对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="image-20230403103438223.png" alt="image-20230403103438223" style="zoom:80%;" /></li></ul><p><strong>依赖注入 小结</strong></p><ul><li><p>强制依赖（强制依赖指对象在创建的过程中必须要注入指定的参数）使用构造器进行；可选依赖（可选依赖指对象在创建过程中注入的参数可有可无）使用setter注入进行，灵活性强。</p></li><li><p>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨；实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入。</p></li><li><p>自己开发的模块推荐使用setter注入（推荐setter）。</p></li></ul><h2 id="依赖自动装配"><a href="#依赖自动装配" class="headerlink" title="依赖自动装配"></a>依赖自动装配</h2><p>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配，从而简化配置文件的配置编写。</p><p>自动装配只需要修改applicationContext.xml配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.dao.Impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- autowire属性：开启自动装配，通常使用按类型装配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Lijiacheng.service.Impl.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用自动装配需要注意的点：① 需要注入属性的类中对应属性的setter方法不能省略；② 被注入的对象必须要被Spring的IOC容器管理；③ 按照类型装配在Spring的IOC容器中只能有该类型的唯一对象。</p></blockquote><p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入：<code>autowire=&quot;byName&quot;</code>.</p><p><strong>自动装配</strong></p><ul><li><p>自动装配用于引用类型依赖注入，不能对简单类型进行操作。</p></li><li><p>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用；使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用。</p></li><li><p>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效。</p></li></ul><h2 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h2><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型集合，集合中既可以装简单数据类型也可以装引用数据类型，在Spring中该如何注入呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line">       System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//setter....方法省略，自己使用工具生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的所以配置方式，都是在userDao的bean标签中使用<property>进行注入：</p><p>注入数组类型数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注入List类型数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>zhongguo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>shandong<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>qingdao<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注入Set类型数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>zhongguo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>shandong<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>qingdao<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>qingdao<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注入Map类型数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kaifeng&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注入Properties类型数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="image-20230403112041440.png" alt="image-20230403112041440" style="zoom:80%;" /><blockquote><ul><li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li><li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li></ul></blockquote><h1 id="IOC-DI配置管理第三方bean"><a href="#IOC-DI配置管理第三方bean" class="headerlink" title="IOC/DI配置管理第三方bean"></a>IOC/DI配置管理第三方bean</h1><p>前面的配置都是基于我们自己写的类，那么该如何管理第三方jar包中的类？</p><h2 id="数据源对象管理"><a href="#数据源对象管理" class="headerlink" title="数据源对象管理"></a>数据源对象管理</h2><p>以后我们会用到很多第三方的bean，下面将使用数据源Druid和C3P0来学习配置。</p><h3 id="实现Druid管理"><a href="#实现Druid管理" class="headerlink" title="实现Druid管理"></a>实现Druid管理</h3><ul><li><p>导入最新版的Druid依赖坐标和mysql坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置第三方bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 管理Druid对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- setter配置属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Druid对象通过setter注入依赖，是因为在对象的上层类DruidDataSource中提供了属性的set方法。</p></blockquote><ul><li>从IOC容器中获取对应的bean对象(DruidDataSource)</li></ul><h3 id="实现C3P0管理"><a href="#实现C3P0管理" class="headerlink" title="实现C3P0管理"></a>实现C3P0管理</h3><ul><li><p>导入最新版的C3P0坐标和mysql坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置第三方bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 管理c3p0对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Druid和C3P0在没有导入mysql驱动包的前提下虽然没有报错，说明在初始化的时候没有去加载驱动，但是在获取数据库连接的时候，也会报找不到驱动类的错误，所以在导入依赖坐标的时候除了导入数据库连接池的坐标外还要导入mysql的坐标。</p></blockquote><h2 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h2><p>这两个数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护，需要将这些值提取到一个外部的properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。</p><ul><li><p>resources下创建一个<code>jdbc.properties</code>文件（名字任意），并添加对应的属性键值对：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/mybatis</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">12345</span></span><br></pre></td></tr></table></figure></li><li><p>开启 <code>context</code> 命名空间</p><img src="image-20230404102716578.png" alt="image-20230404102716578" style="zoom:67%;" /><p>直接copy配置文件中bean的命名空间并修改这5处为：<code>context</code>即可。</p></li><li><p>加载properties配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用context命名空间下的标签来加载properties配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>完成属性注入</p><img src="image-20230404103018660.png" alt="image-20230404103018660" style="zoom: 50%;" /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>&lt;context:property-placeholder/&gt;</code>标签会加载系统的环境变量，而且环境变量的值会被优先加载，可以在该标签上增添属性<code>system-properties-mode=&quot;NEVER&quot;</code>避免加载系统环境变量。</p></blockquote><p><strong>加载多个properties文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>方式三是标准的写法，<code>classpath:</code>代表的是从根路径下开始查找，但是只能查询当前项目的根路径；方式四不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件。</p><h1 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h1><p>讲完bean与依赖注入，接下来我们主要学习的是IOC容器中的核心容器。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="创建核心容器"><a href="#创建核心容器" class="headerlink" title="创建核心容器"></a>创建核心容器</h3><ul><li><p>类路径下的XML配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure></li><li><p>文件系统下的XML配置文件（从项目路径下开始查找，不推荐使用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;applicationContext.xml的绝对路径&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取Bean的三种方式"><a href="#获取Bean的三种方式" class="headerlink" title="获取Bean的三种方式"></a>获取Bean的三种方式</h3><ul><li><p>方式1：每次获取的时候都需要进行类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;UserDao&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>方式2：可以解决类型强转问题，但是加了一个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;UserDao&quot;</span>，BookDao.class);</span><br></pre></td></tr></table></figure></li><li><p>方式3：按class类型获取bean，必须要确保IOC容器中该类型对应的bean对象只能有一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure></li></ul><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>容器的最上级的父接口为<code>BeanFactory</code>，可以使用BeanFactory来创建IOC容器。</p><p>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建；ApplicationContext是立即加载，容器加载的时候就会创建bean对象。ApplicationContext要想成为延迟加载，只需要在配置文件中配置<code>lazy-init=&quot;true&quot;</code>。</p><h2 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h2><p><strong>容器</strong></p><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载；ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载。</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口常用初始化类：<code>ClassPathXmlApplicationContext</code></li></ul><p><strong>bean</strong></p><img src="image-20230404113815759.png" alt="image-20230404113815759" style="zoom: 50%;" /><p>整个配置最常用的就两个属性：<code>id</code>和<code>class</code>。</p><p><strong>依赖注入</strong></p><img src="image-20230404113923632.png" alt="image-20230404113923632" style="zoom: 67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring框架主要的优势是在&lt;strong&gt;简化开发&lt;/strong&gt;和&lt;strong&gt;框架整合&lt;/strong&gt;上，针对特点Spring的学习主线就是IOC、AOP、声明式事务和整合MyBais框架。Part1主要学习IOC容器中的bean、依赖注入以及核心容器。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://kicheng.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>07-Filter_Listener_Ajax</title>
    <link href="https://kicheng.github.io/2023/04/01/07-Filter-Listener-Ajax/"/>
    <id>https://kicheng.github.io/2023/04/01/07-Filter-Listener-Ajax/</id>
    <published>2023-04-01T10:30:31.000Z</published>
    <updated>2023-04-01T10:32:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>这块知识点比较杂，而且Ajax是代替jsp的前端技术，了解即可。</p><span id="more"></span><h1 id="Filter-amp-Listener-amp-Ajax"><a href="#Filter-amp-Listener-amp-Ajax" class="headerlink" title="Filter&amp;Listener&amp;Ajax"></a>Filter&amp;Listener&amp;Ajax</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。Servlet 我们之前都已经学习过了，Filter和Listener我们今天都会进行学习。过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。</p><p>正常情况下浏览器可以访问服务器上的所有的资源，而在访问到这些资源之前可以使过滤器拦截来下，也就是说在访问资源之前会先经过 Filter：</p><img src="image-20230330163113415.png" alt="image-20230330163113415" style="zoom:67%;" /><p>过滤器一般完成一些通用的操作：比如每个资源都要写一些代码完成某个功能，我们总不能在每个资源中写这样的代码，而此时我们可以将这些代码写在过滤器中，因为请求每一个资源都要经过过滤器。</p><p>我们之前做的品牌数据管理就已经做了登录的功能，但不登录的时候也可以通过首页的超链接访问到全部数据，这显然不符合我们的要求。我们希望如果登录过就跳转到品牌数据展示的页面，没有登录就跳转到登录界面，但如果要实现这个效果就要在每个资源中写上这段逻辑。像这种通用的操作，就可以用过滤器来实现，这就是过滤器的权限控制。</p><h3 id="Filter快速开发"><a href="#Filter快速开发" class="headerlink" title="Filter快速开发"></a>Filter快速开发</h3><ul><li><p>定义类，实现Filter接口，并重写其中的所有方法；</p></li><li><p>配置Filter拦截资源的路径：在类上定义 <code>@WebFilter</code> 注解。而注解的 <code>value</code> 属性值 <code>/*</code> 表示拦截所有的资源；</p></li><li><p>在doFilter方法中执行通用业务，并放行（<code>chain.doFilter(req,resp);</code> 就是放行，也就是让其访问本该访问的资源）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FilterDemo01...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);  <span class="comment">// 放行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Filter执行流程"><a href="#Filter执行流程" class="headerlink" title="Filter执行流程"></a>Filter执行流程</h3><img src="image-20230330165523793.png" alt="image-20230330165523793" style="zoom: 67%;" /><p>可以总结Filter的执行流程如下：</p><img src="image-20230330165658889.png" alt="image-20230330165658889" style="zoom:80%;" /><p>以后我们可以将对请求进行处理的代码在放行之前进行处理，而如果请求完资源后还要对响应的数据进行处理时可以在放行后进行处理。</p><h3 id="Filter拦截路径配置"><a href="#Filter拦截路径配置" class="headerlink" title="Filter拦截路径配置"></a>Filter拦截路径配置</h3><p>拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 <code>@WebFilter</code> 注解进行配置。</p><ul><li>拦截具体的资源：<code>/index.jsp</code>：只有访问index.jsp时才会被拦截；</li><li>目录拦截：<code>/user/*</code>：访问/user下的所有资源，都会被拦截；</li><li>后缀名拦截：<code>*.jsp</code>：访问后缀名为jsp的资源，都会被拦截；</li><li>拦截所有：<code>/*</code>：访问所有资源，都会被拦截。</li></ul><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。</p><img src="image-20230330171958846.png" alt="image-20230330171958846" style="zoom: 50%;" /><p>在<code>FilterDemo01</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;1.FilterDemo...&quot;</span>);</span><br><span class="line">filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">System.out.println(<span class="string">&quot;5.FilterDemo...&quot;</span>);</span><br></pre></td></tr></table></figure><p>在<code>FilterDemo2</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;2.FilterDemo...&quot;</span>);</span><br><span class="line">   filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">   System.out.println(<span class="string">&quot;4.FilterDemo...&quot;</span>);</span><br></pre></td></tr></table></figure><p>在服务器动态资源<code>hello.jsp</code>中：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  System.out.println(<span class="string">&quot;3.hello jsp...&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>访问服务器中的jsp资源，可以根据打印的信息看到web请求和响应是如何通过过滤器链执行的：</p><img src="image-20230330172922401.png" alt="image-20230330172922401" style="zoom:67%;" /><blockquote><p>但是为什么，我们配置的<code>FilterDemo1</code>和<code>FilterDemo2</code>的拦截路径是一致的，为什么会先执行1再执行2呢？使用的是注解配置Filter，这种配置方式的优先级是按照过滤器类名（字符串）的自然排序。</p></blockquote><h3 id="Filter应用——登录校验"><a href="#Filter应用——登录校验" class="headerlink" title="Filter应用——登录校验"></a>Filter应用——登录校验</h3><img src="image-20230330173546835.png" alt="image-20230330173546835" style="zoom: 67%;" /><p>这块应用在上一个project<code>JavaWeb_06_Cookie_Session</code>里补充代码。在<code>web</code>目录下创建<code>filter</code>目录新建<code>LoginFilter</code>过滤器即可，通过判断session中是否有user对象就可以判断用户是否登录，代码很简单就不记录了。</p><img src="image-20230330175255343.png" alt="image-20230330175255343" style="zoom: 50%;" /><p>但是我们看到的效果是这样的（先删除浏览器缓存的记录），这是为什么呢？因为登陆页面需要 <code>css/login.css</code> 文件进行样式渲染，但是这个文件在filter中被拦截了，导致没有加载到样式文件，为了解决这个问题，<strong>需要对所有的登陆相关的资源进行放行</strong>。<strong>还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行</strong>。</p><p>过滤器<code>LoginFilter</code>的完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 在数组中存储登陆和注册相关的资源路径，优先将他们放行</span></span><br><span class="line">        String[] urls = &#123;<span class="string">&quot;/login.jsp&quot;</span>,<span class="string">&quot;/imgs/&quot;</span>,<span class="string">&quot;/css/&quot;</span>,<span class="string">&quot;/loginServlet&quot;</span>,<span class="string">&quot;/register.jsp&quot;</span>,<span class="string">&quot;/registerServlet&quot;</span>,<span class="string">&quot;/checkCodeServlet&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURL</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line">        <span class="keyword">for</span>(String url: urls)&#123;</span><br><span class="line">            <span class="keyword">if</span>(requestURL.contains(url))&#123;</span><br><span class="line">                <span class="comment">// 需要放行的资源url</span></span><br><span class="line">                filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放行前 -- 判断用户是否登录</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 已经登录过 -- 放行</span></span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 未登录 -- 跳转到登录界面</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;login_msg&quot;</span>,<span class="string">&quot;未登录，请先登录！&quot;</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).forward(servletRequest,servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>Listener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。监听器可以监听在 <code>application</code>，<code>session</code>，<code>request</code> 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p><p>request和session我们学习过。而 <code>application</code> 是 <code>ServletContext</code> 类型的对象（<code>ServletContext</code> 代表整个web应用，在服务器启动的时候，tomcat会自动创建该对象。在服务器关闭时会自动销毁该对象）。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>JavaWeb 提供了8个监听器，只有 <code>ServletContextListener</code> 这个监听器后面会用到，<code>ServletContextListener</code> 是用来监听 <code>ServletContext</code> 对象的创建和销毁。</p><p><code>ServletContextListener</code> 接口中有以下两个方法：</p><ul><li><code>void contextInitialized(ServletContextEvent sce)</code>：<code>ServletContext</code> 对象被创建了会自动执行的方法；</li><li><code>void contextDestroyed(ServletContextEvent sce)</code>：<code>ServletContext</code> 对象被销毁时会自动执行的方法。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>对于 <code>ServletContextListener</code> 监听器：</p><ul><li>定义一个类，实现<code>ServletContextListener</code> 接口，重写所有的抽象方法</li><li>使用 <code>@WebListener</code> 进行配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//加载资源</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ContextLoaderListener...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>AJAX (Asynchronous JavaScript And XML)是异步的 JavaScript 和 XML。</p><h3 id="AJAX概述"><a href="#AJAX概述" class="headerlink" title="AJAX概述"></a>AJAX概述</h3><h4 id="AJAX作用"><a href="#AJAX作用" class="headerlink" title="AJAX作用"></a>AJAX作用</h4><p>1、<strong>与服务器进行数据交换</strong>：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。</p><p>之前我们是这样做功能：</p><p><img src="image-20230330213503973.png" alt="image-20230330213503973"></p><p>Servlet 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 jsp 页面，在页面上使用 EL表达式 和 JSTL标签库 进行数据的展示。</p><p>而我们学习了AJAX 后，就可以使用AJAX和服务器进行通信，以达到使用 HTML+AJAX 来替换JSP页面了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。</p><p><img src="image-20230330213640794.png" alt="image-20230330213640794"></p><p>2、<strong>异步交互</strong>：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术（搜索联想、用户名是否可用校验）。</p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><ul><li>同步发送请求</li></ul><img src="image-20230330214009570.png" alt="image-20230330214009570" style="zoom:67%;" /><p>浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。</p><ul><li><p>异步发送请求过程如下</p><img src="image-20230330214043364.png" alt="image-20230330214043364" style="zoom:67%;" /></li></ul><p>浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><strong>服务端实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/ajaxServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;hello ajax~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//1. 创建核心对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> xhttp;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="language-javascript">    xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//2. 发送请求</span></span></span><br><span class="line"><span class="language-javascript">  xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/ajaxServlet&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  xhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//3. 获取响应</span></span></span><br><span class="line"><span class="language-javascript">  xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="image-20230330220341705.png" alt="image-20230330220341705"></p><p>查看异步请求：</p><p><img src="image-20230330220604851.png" alt="image-20230330220604851"></p><h3 id="Ajax应用"><a href="#Ajax应用" class="headerlink" title="Ajax应用"></a>Ajax应用</h3><p>需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在。</p><img src="image-20230330220940894.png" alt="image-20230330220940894" style="zoom:67%;" /><h4 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 接收用户名数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;username&quot;</span>).toString();</span><br><span class="line">    <span class="comment">// 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 响应标记</span></span><br><span class="line">    response.getWriter().write(<span class="string">&quot;&quot;</span> + flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 给用户名输入框绑定 失去焦点事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2. 发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取用户名的值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> username = <span class="variable language_">this</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.1. 创建核心对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> xhttp;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="language-javascript">            xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.2. 发送请求</span></span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/selectUserServlet?username=&quot;</span> + username);</span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.3. 获取响应</span></span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//判断</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">responseText</span> == <span class="string">&quot;true&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//用户名存在，显示提示信息</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//用户名不存在 ，清楚提示信息</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 对原生的AJAX进行封装，简化书写。</p><blockquote><p>Axios官网：<a href="https://www.axios-http.cn/">https://www.axios-http.cn</a></p></blockquote><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><p>引入 axios 的 js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用axios发送请求，并获取响应结果</p><ul><li><p>get请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>post请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;  </span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON概述"><a href="#JSON概述" class="headerlink" title="JSON概述"></a>JSON概述</h3><p>JSON是JavaScript对象的表示法。</p><ul><li><p>JavaScript对象的定义格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line"><span class="attr">city</span>:<span class="string">&quot;北京&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JSON格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">name<span class="punctuation">:</span><span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">age<span class="punctuation">:</span><span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">city<span class="punctuation">:</span><span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p> js对象中的属性名可以使用引号（单引号或双引号）；而json格式中的键要求必须使用双引号括起来，这是 json格式的规定。</p><p><strong>作用</strong>：由于其语法格式简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。像通过<code>response.getWriter()</code>就是服务端给浏览器响应的数据，有些数据比较简单，如果现需要将 JAVA 对象中封装的数据响应回给浏览器的话，应该怎么做呢？</p><p>以前是通过xml进行数据传递：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><p>json描述（ 格式数据的简单、所占的字节数少）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="JSON基础语法"><a href="#JSON基础语法" class="headerlink" title="JSON基础语法"></a>JSON基础语法</h3><h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h4><p>JSON本质就是一个字符串，但是该字符串内容是有一定的格式要求的：键要求必须使用双引号括起来，而值根据要表示的类型确定。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 = &#x27;<span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span>value<span class="punctuation">,</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span>value<span class="punctuation">,</span>...<span class="punctuation">&#125;</span>&#x27;;</span><br></pre></td></tr></table></figure><p>value的数据类型如下：数字（整数或浮点数）、字符串（双引号）、逻辑值（true或false）、数组（在方括号中）、对象（在花括号中）、null。</p><p>如果需要获取到该 JSON串中的属性值，应该怎么处理呢？</p><p>如果它是一个 js 对象，我们就可以通过 <code>js对象.属性名</code> 的方式来获取数据。JS 提供了一个对象<code>JSON</code>，该对象有如下两个方法：</p><ul><li><code>parse(str)</code> ：将 JSON串转换为 js 对象。使用方式是：<code>var jsObject = JSON.parse(jsonStr);</code></li><li><code>stringify(obj)</code> ：将 js 对象转换为 JSON 串。使用方式是：<code>var jsonStr = JSON.stringify(jsObject)</code></li></ul><p>代码演示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//1. 定义JSON字符串</span></span><br><span class="line">    <span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27;</span></span><br><span class="line">    <span class="title function_">alert</span>(jsonStr);</span><br><span class="line">    <span class="comment">//2. 将 JSON 字符串转为 JS 对象</span></span><br><span class="line">    <span class="keyword">let</span> jsObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr);</span><br><span class="line">    <span class="title function_">alert</span>(jsObject)</span><br><span class="line">    <span class="title function_">alert</span>(jsObject.<span class="property">name</span>)</span><br><span class="line">    <span class="comment">//3. 将 JS 对象转换为 JSON 字符串</span></span><br><span class="line">    <span class="keyword">let</span> jsonStr2 = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(jsObject);</span><br><span class="line">    <span class="title function_">alert</span>(jsonStr2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="发送异步请求携带参数"><a href="#发送异步请求携带参数" class="headerlink" title="发送异步请求携带参数"></a>发送异步请求携带参数</h4><p>使用 axios 发送请求时，如果要携带复杂的数据时都会以 JSON格式进行传递。可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 <code>JSON.stringify(js对象)</code> 转换为JSON串，再将该 JSON串作为 axios 的 data 属性值进行请求参数的提交（axios会自动将 js 对象转换为JSON串进行提交）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObject = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/JavaWeb_07_Filter_Listener_Ajax/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:jsObject  <span class="comment">//这里 axios 会将该js对象转换为 json 串的</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>发送异步请求时，如果请求参数是JSON格式，那请求方式必须是POST。因为JSON串需要放在请求体中。</p></blockquote><h3 id="JSON串和Java对象的相互转换"><a href="#JSON串和Java对象的相互转换" class="headerlink" title="JSON串和Java对象的相互转换"></a>JSON串和Java对象的相互转换</h3><p>以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。</p><img src="image-20230330233339635.png" alt="image-20230330233339635" style="zoom:50%;" /><p>在后端我们就需要重点学习以下两部分操作：</p><ul><li>请求数据：JSON字符串转为Java对象；</li><li>响应数据：Java对象转为JSON字符串；</li></ul><h4 id="Fastjson-概述"><a href="#Fastjson-概述" class="headerlink" title="Fastjson 概述"></a>Fastjson 概述</h4><p>阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库，可以实现 Java对象和 JSON字符串的相互转换。</p><p><strong>基本使用</strong></p><ul><li><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>JSON对象转换成Java对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(jsonStr, User.class);</span><br></pre></td></tr></table></figure></li><li><p>Java对象转换成JSON对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(obj);</span><br></pre></td></tr></table></figure></li></ul><p>JSON对象和Java对象的相互转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Java对象转换成Json对象</span></span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">   user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">   System.out.println(jsonString);</span><br><span class="line">   <span class="comment">// 将Json对象转换城Java对象</span></span><br><span class="line">   <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> JSON.parseObject(jsonString,User.class);</span><br><span class="line">   System.out.println(u);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这块知识点比较杂，而且Ajax是代替jsp的前端技术，了解即可。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>06-会话技术</title>
    <link href="https://kicheng.github.io/2023/04/01/06-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
    <id>https://kicheng.github.io/2023/04/01/06-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</id>
    <published>2023-04-01T10:27:23.000Z</published>
    <updated>2023-04-01T10:29:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>会话跟踪是web程序中常用的技术，常用的<em>会话跟踪</em>技术是Cookie 和Session。</p><span id="more"></span><h1 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h1><p>对于会话跟踪，首先要理解什么是会话，然后再去理解什么是会话跟踪：</p><ul><li><p>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</p><ul><li>从浏览器发出请求到服务端响应数据给前端之后，一次会话（在浏览器和服务器之间）就被建立了；</li><li>会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着；</li><li>浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程就被称为会话。</li></ul></li><li><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p><ul><li>服务器会收到多个请求，这多个请求可能来自多个浏览器；</li><li>服务器需要识别请求是否来自同一个浏览器，这个过程就是会话跟踪；</li><li>服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据。</li></ul></li></ul><blockquote><p>多次请求间的数据共享：购物网站的购物车结算；页面展示用户登录信息（发送多次请求都显示信息）；网站登录的”记住我“功能；登录页面的验证码功能（声明验证码和点击登录也是两次请求，需要进行比对才能登陆成功）</p></blockquote><p>但是目前的浏览器和服务器之间不支持数据共享：浏览器和服务器之间使用的是HTTP请求来进行数据传输，而<strong>HTTP协议是无状态的</strong>，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求（HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响），请求与请求之间独立后，就无法实现多次请求之间的数据共享。</p><p>会话跟踪分为客户端的会话跟踪和服务端的会话跟踪技术。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie的基本使用"><a href="#Cookie的基本使用" class="headerlink" title="Cookie的基本使用"></a>Cookie的基本使用</h3><p>Cookie是一种客户端会话技术，将数据保存到<strong>客户端</strong>，以后每次请求都携带Cookie数据进行访问。</p><h4 id="Cookie的工作流程"><a href="#Cookie的工作流程" class="headerlink" title="Cookie的工作流程"></a>Cookie的工作流程</h4><img src="image-20230329175917166.png" alt="image-20230329175917166" style="zoom: 50%;" /><ul><li>服务端提供了两个Servlet，分别是ServletA和ServletB；</li><li>浏览器发送HTTP请求1给服务端，服务端ServletA接收请求并进行业务处理；</li><li>服务端ServletA在处理的过程中可以创建一个Cookie对象并将<code>name=zs</code>的数据存入Cookie；</li><li>服务端ServletA在响应数据的时候，会把Cookie对象响应给浏览器；</li><li>浏览器接收到响应数据，会把Cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就建立了一次会话；</li><li><strong>在同一次会话中</strong>浏览器再次发送HTTP请求2给服务端ServletB，浏览器会携带Cookie对象中的所有数据；</li><li>ServletB接收到请求和数据后，就可以获取到存储在Cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享。</li></ul><h4 id="Cookie的基本使用-1"><a href="#Cookie的基本使用-1" class="headerlink" title="Cookie的基本使用"></a>Cookie的基本使用</h4><p>1、发送Cookie</p><ul><li><p>创建Cookie对象，并设置数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);</span><br></pre></td></tr></table></figure></li><li><p>发送Cookie到客户端：使用response对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></li></ul><p>通过Servlet向客户端发送一个Cookie：</p><p><img src="image-20230329181624169.png" alt="image-20230329181624169"></p><p>2、获取Cookie</p><ul><li><p>获取客户端携带的所有Cookie，使用request对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br></pre></td></tr></table></figure></li><li><p>遍历数组获取每一个Cookie对象，使用Cookie对象方法获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.getName();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.getValue();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>在访问AServlet后关闭浏览器，重启浏览器后访问BServlet就无法获取到Cookie中的数据，因为重启浏览器之后就不是一次会话了。</p></blockquote><h3 id="Cookie原理分析"><a href="#Cookie原理分析" class="headerlink" title="Cookie原理分析"></a>Cookie原理分析</h3><p>对于Cookie的实现原理是基于HTTP协议的，其中涉及到HTTP协议中的两个请求头信息：响应头 set-cookie、请求头 cookie</p><img src="image-20230329183559500.png" alt="image-20230329183559500" style="zoom:67%;" /><ul><li>对于AServlet响应数据的时候，Tomcat服务器都是基于HTTP协议来响应数据；当Tomcat发现后端要返回的是一个Cookie对象之后，Tomcat就会在<strong>响应头</strong>中添加一行数据<code>Set-Cookie:username=zs</code>；</li><li>浏览器获取到响应结果后，从响应头中就可以获取到<code>Set-Cookie</code>对应值<code>username=zs</code>,并将数据存储在浏览器的内存中；</li><li>浏览器再次发送请求给BServlet的时候，浏览器会自动在<strong>请求头</strong>中添加<code>Cookie: username=zs</code>发送给服务端BServlet；</li><li>Request对象会把请求头中cookie对应的值封装成一个个Cookie对象，最终形成一个数组，BServlet通过Request对象获取Cookie。</li></ul><p>可以验证一下：</p><p><img src="image-20230329210416050.png" alt="image-20230329210416050"></p><h3 id="Cookie的使用细节"><a href="#Cookie的使用细节" class="headerlink" title="Cookie的使用细节"></a>Cookie的使用细节</h3><h4 id="Cookie的存活时间"><a href="#Cookie的存活时间" class="headerlink" title="Cookie的存活时间"></a>Cookie的存活时间</h4><p>正像前面提到的，在访问AServlet后关闭浏览器，重启浏览器后访问BServlet就无法获取到Cookie中的数据。在默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁。那么如何将Cookie持久化存储？</p><ul><li><p>设置Cookie存活时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setMaxAge(int seconds)</span><br></pre></td></tr></table></figure><p>参数为：</p><ul><li>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储，到时间自动删除；</li><li>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁；</li><li>0：删除对应Cookie。</li></ul></li></ul><h4 id="Cookie存储中文"><a href="#Cookie存储中文" class="headerlink" title="Cookie存储中文"></a>Cookie存储中文</h4><p>Cookie不能直接存储中文，当cookie里存储中文时访问服务器资源时会报错。所以我们可以用URL编解码的方式，在cookie中存字节数据。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session的基本使用"><a href="#Session的基本使用" class="headerlink" title="Session的基本使用"></a>Session的基本使用</h3><p>Session是一种服务端会话跟踪技术，将数据保存到<strong>服务端</strong>。</p><blockquote><ul><li>Session是存储在服务端而Cookie是存储在客户端；</li><li>存储在客户端的数据容易被窃取和截获，存在很多不安全的因素存储在服务端的数据相比于客户端来说就更安全。</li></ul></blockquote><h4 id="Session的工作流程"><a href="#Session的工作流程" class="headerlink" title="Session的工作流程"></a>Session的工作流程</h4><img src="image-20230329212652378.png" alt="image-20230329212652378" style="zoom:67%;" /><ul><li>在服务端的AServlet获取一个Session对象，把数据存入其中；</li><li>在服务端的BServlet获取到相同的Session对象<em>（如何保证使用的是同一个Session对象）</em>，从中取出数据；</li><li>就可以实现一次会话中多次请求之间的数据共享了。</li></ul><h4 id="Session的基本使用-1"><a href="#Session的基本使用-1" class="headerlink" title="Session的基本使用"></a>Session的基本使用</h4><ul><li><p>获取Session对象，使用的是request对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure></li><li><p>Session对象提供的功能</p><ul><li><p>存储数据到session域中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setAttribute(String name, Object o)</span><br></pre></td></tr></table></figure></li><li><p>根据 key，获取值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object getAttribute(String name)  // Session中是一个Object类型的数据，也就是说Session中可以存储任意数据类型</span><br></pre></td></tr></table></figure></li><li><p>根据 key，删除该键值对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void removeAttribute(String name)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>可以自己写个Servlet就能看到Session是能够在一次会话中两次请求之间共享数据的。</p><h3 id="Session的原理分析"><a href="#Session的原理分析" class="headerlink" title="Session的原理分析"></a>Session的原理分析</h3><p>Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个；我们可以在Session 的两个Servlet中分别print出创建的Session对象：</p><p><img src="image-20230329214508736.png" alt="image-20230329214508736"></p><p>那么如果关闭浏览器再重新打开呢？这时候就不是同一个session对象了，所以Session实现的也是一次会话中多次请求之间的数据共享。</p><img src="image-20230329214604582.png" alt="image-20230329214604582" style="zoom:67%;" /><p><img src="image-20230329215505220.png" alt="image-20230329215505220"></p><p><strong>Session保证在一次会话中获取的Session对象是同一个（基于Cookie）</strong></p><p><img src="image-20230329215911579.png" alt="image-20230329215911579"></p><ul><li>demo1在第一次获取session对象的时候，session对象会有一个唯一的标识，假如是<code>id:10</code>；</li><li>demo1在session中存入其他数据并处理完成所有业务后，需要通过Tomcat服务器响应结果给浏览器；</li><li>Tomcat服务器发现业务处理中使用了session对象，就会把session的唯一标识<code>id:10</code>当做一个cookie，添加<code>Set-Cookie:JESSIONID=10</code>到响应头中，并响应给浏览器；</li><li>浏览器接收到响应结果后，会把响应头中的coookie数据存储到浏览器的内存中；</li><li>浏览器在同一会话中访问demo2的时候，会把cookie中的数据按照<code>Cookie: JESSIONID=10</code>的格式添加到请求头中并发送给服务器Tomcat；</li><li>demo2获取到请求后，从请求头中就读取cookie中的JSESSIONID值为10，然后就会到服务器内存中寻找<code>id:10</code>的session对象，如果找到了，就直接返回该对象，如果没有则新创建一个session对象；</li><li>关闭打开浏览器后，因为浏览器的cookie已被销毁，所以就没有JESSIONID的数据，服务端获取到的session就是一个全新的session对象。</li></ul><p>可以看一下在同一会话的两次请求中的Cookie数据：</p><p><img src="image-20230329221834266.png" alt="image-20230329221834266"></p><p><img src="06-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/image-20230329221909633.png" alt="image-20230329221909633"></p><h3 id="Session的使用细节"><a href="#Session的使用细节" class="headerlink" title="Session的使用细节"></a>Session的使用细节</h3><h4 id="Session的钝化和活化"><a href="#Session的钝化和活化" class="headerlink" title="Session的钝化和活化"></a>Session的钝化和活化</h4><p>服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中；当服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了。但是对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对——服务器就是通过<strong>Session的钝化和活化</strong>做到的。</p><img src="image-20230329222619158.png" alt="image-20230329222619158" style="zoom:67%;" /><ul><li>钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中</li><li>活化：再次启动服务器后，从文件中加载数据到Session中（数据加载到Session中后，路径中的文件会被删除掉）</li></ul><blockquote><p>小结：</p><ul><li>session数据存储在服务端，服务器重启后，session数据会被保存；</li><li>浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象；</li><li><strong>session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据；cookie是存储在客户端，可以长期保存。</strong></li></ul></blockquote><h4 id="Session销毁"><a href="#Session销毁" class="headerlink" title="Session销毁"></a>Session销毁</h4><ul><li><p>默认情况下，无操作，30分钟自动销毁；对于这个失效时间，是可以通过在<code>web.xml</code>配置进行修改的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-timeout&gt;100&lt;/session-timeout&gt;  &lt;!-- 单位是mins --&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></li><li><p>调用Session对象的<code>invalidate()</code>进行销毁</p></li></ul><h2 id="Cookie和Session小结"><a href="#Cookie和Session小结" class="headerlink" title="Cookie和Session小结"></a>Cookie和Session小结</h2><p>Cookie 和 Session 都是来完成一次会话内多次请求间的数据共享。</p><ul><li>区别：<ul><li>存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端；</li><li>安全性：Cookie不安全，Session安全；</li><li>数据大小：Cookie最大3KB，Session无大小限制；</li><li>存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟；</li><li>服务器性能：Cookie不占服务器资源，Session占用服务器资源；</li></ul></li><li>应用场景（不绝对）：<ul><li>购物车：使用Cookie来存储；</li><li>以登录用户的名称展示：使用Session来存储；</li><li>记住我功能：使用Cookie来存储；</li><li>验证码：使用Session来存储；</li></ul></li></ul><h2 id="会话跟踪在登陆注册中的应用"><a href="#会话跟踪在登陆注册中的应用" class="headerlink" title="会话跟踪在登陆注册中的应用"></a>会话跟踪在登陆注册中的应用</h2><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p>登录功能做完了，很无语…本来几分钟就能搞定的事花了俩小时，一直识别不到xml映射文件，我反复检查<code>namespace</code>和核心配置文件无果，偶然发现我竟然将mapper下的xml映射文件放在了<code>webapp</code>目录而不是<code>resource</code>目录……欲哭无泪……</p><p>登录功能的业务逻辑是：在登录时（第一次请求）将用户数据存入session中，并进行数据共享到登陆成功页面以及其他页面（第二次请求）。由于是一次会话的多次请求，所以共享session中的数据不能用请求转发只能用重定向，这里值得注意一下。</p><h3 id="”记住我“功能"><a href="#”记住我“功能" class="headerlink" title="”记住我“功能"></a>”记住我“功能</h3><p>在服务器端创建Cookie对象分别存储<code>username</code>和<code>password</code>，add到客户端，这时候可以看到response的响应头中存在<code>Set-Cookie</code>：</p><p><img src="image-20230330111257163.png" alt="image-20230330111257163"></p><p>下一步是在客户端页面获取Cookie，将数据设置到登陆页面的用户名和密码框中。在页面可以使用EL表达式获取Cookie：</p><img src="image-20230330111714218.png" alt="image-20230330111714218" style="zoom:50%;" /><p>在jsp页面中修改代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; value=&quot;$&#123;cookie.username.value&#125;&quot; type=&quot;text&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; value=&quot;$&#123;cookie.password.value&#125;&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="用户注册功能"><a href="#用户注册功能" class="headerlink" title="用户注册功能"></a>用户注册功能</h3><p>业务逻辑是：前端通过表单将注册的用户名和密码传给<code>RegisterServlet</code>，调用Service层register，如果注册成功则跳转到登录界面并给提示；如果注册失败则重新跳转到注册界面并给提示。</p><h3 id="验证码的生成和校验"><a href="#验证码的生成和校验" class="headerlink" title="验证码的生成和校验"></a>验证码的生成和校验</h3><blockquote><p>验证码的作用：防止机器自动注册，攻击服务器</p></blockquote><p>这段业务比较陌生是第一次见到，记录下详细的实现过程。</p><ul><li>生成二维码</li></ul><p>验证码的生成是通过工具类来实现的，具体的工具类参考<code>CheckCodeUtil.java</code>，编写main方法进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    //生成验证码的图片位置</span><br><span class="line">    OutputStream fos = new FileOutputStream(&quot;d://a.jpg&quot;);</span><br><span class="line">    //checkCode为最终验证码的数据</span><br><span class="line">    String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, fos, 4);</span><br><span class="line">    System.out.println(checkCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现流程分析</strong></p><img src="image-20230330151138981.png" alt="image-20230330151138981" style="zoom:50%;" /><p>测试类是通过<code>OutputStream</code>流将图片生成到磁盘，可以通过reponse对象的<code>getOutputStream()</code>字节输出流将图片响应给页面。</p><p><strong>具体实现</strong></p><p>（1）修改Register.jsp页面，将验证码图片从后台获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;td class=&quot;inputs&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;checkCode&quot; type=&quot;text&quot; id=&quot;checkCode&quot;&gt;</span><br><span class="line">    &lt;!-- 将验证码的图片从后台获取 --&gt;</span><br><span class="line">    &lt;img id=&quot;checkCodeImg&quot; src=&quot;/JavaWeb_06_Cookie_Session/checkCodeServlet&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;&quot; id=&quot;changeImg&quot;&gt;看不清？&lt;/a&gt;</span><br><span class="line">&lt;/td&gt;</span><br></pre></td></tr></table></figure><p>（2）CheckCodeServlet用来接收请求生成验证码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/checkCodeServlet&quot;)</span><br><span class="line">public class CheckCodeServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 生成验证码</span><br><span class="line">        ServletOutputStream os = response.getOutputStream();</span><br><span class="line">        String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>校验二维码</li></ul><p>判断<strong>生成的验证码</strong>和<strong>用户输入的验证码</strong>是否一样，如果不一样，则阻止注册。验证码图片访问和提交注册表单是<strong>两次</strong>请求，所以要将程序生成的验证码存入Session中。</p><p><strong>实现流程分析</strong></p><img src="image-20230330151923006.png" alt="image-20230330151923006" style="zoom:50%;" /><p>（1）在CheckCodeServlet中生成验证码的时候，将验证码数据存入Session对象；</p><p>（2）前端将验证码和注册数据提交到后台，交给RegisterServlet类；</p><p>（3）RegisterServlet类接收到请求和数据后，其中就有验证码，和Session中的验证码进行对比；</p><p>（4）如果一致，则完成注册，如果不一致，则提示错误信息。</p><p><strong>具体实现</strong></p><p>（1）修改CheckCodeServlet类，将验证码存入Session对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将生成的验证码存入Session对象</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(&quot;checkCode&quot;,checkCode);</span><br></pre></td></tr></table></figure><p>（2）在RegisterServlet中，获取页面的和session对象中的验证码，进行对比</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取用户输入的验证码</span><br><span class="line">String checkCode = request.getParameter(&quot;checkCode&quot;);</span><br><span class="line">// 获取Session中的验证码</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">Object s_checkCode = session.getAttribute(&quot;checkCode&quot;);</span><br><span class="line">// 将二者进行比对</span><br><span class="line">if(!s_checkCode.equals(checkCode))&#123;</span><br><span class="line">     // 验证码错误，无法注册 -- 跳转到注册jsp并给予提示</span><br><span class="line">     request.setAttribute(&quot;register_msg&quot;,&quot;验证码错误，请重新输入！&quot;);</span><br><span class="line">     request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request,response);</span><br><span class="line">     return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;会话跟踪是web程序中常用的技术，常用的&lt;em&gt;会话跟踪&lt;/em&gt;技术是Cookie 和Session。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>05-JSP</title>
    <link href="https://kicheng.github.io/2023/04/01/05-JSP/"/>
    <id>https://kicheng.github.io/2023/04/01/05-JSP/</id>
    <published>2023-04-01T10:21:03.000Z</published>
    <updated>2023-04-01T10:26:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>JSP（全称：Java Server Pages），Java 服务端页面。是一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java代码的动态内容， <code>JSP = HTML + Java</code>。虽然说JSP技术早已过时了，但是在很多国企银行还在使用它，可以把JSP当作javaweb的发展史来学习一下。</p><span id="more"></span><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>JSP到底是什么作用呢？在前面我们使用Servlet在网页端进行动态展示，当时使用了<code>writer.write()</code>向前端写html标签内容进行展示，这样我们的代码就显得很麻烦。在JSP中，用html展示静态页面，用java代码展示动态数据，从而简化开发，避免了在Servlet中直接输出HTML标签。</p><h2 id="JSP快速入门"><a href="#JSP快速入门" class="headerlink" title="JSP快速入门"></a>JSP快速入门</h2><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, JSP!&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a>JSP原理</h2><p>JSP 本质上就是一个 Servlet，看一看访问JSP时的流程：</p><img src="image-20230329100053695.png" alt="image-20230329100053695" style="zoom:50%;" /><p>（1）浏览器第一次访问 <code>hello.jsp</code> 页面</p><p>（2）<code>tomcat</code> 会将 <code>hello.jsp</code> 转换为名为 <code>hello_jsp.java</code> 的一个 <code>Servlet</code></p><p>（3）<code>tomcat</code> 再将转换的 <code>servlet</code> 编译成字节码文件 <code>hello_jsp.class</code></p><p>（4）<code>tomcat</code> 会执行该字节码文件，向外提供服务</p><p>在Servlet当中是需要我们编写代码将数据write到页面上去，但是在JSP中通过生成相应的Servlet，tomcat自动帮我们完成了这项工作。</p><blockquote><p>JSP脚本分类：</p><ul><li>&lt;%…%&gt;：内容会直接放到<code>_jspService()</code>方法之中；</li><li>&lt;%=…%&gt;：内容会放到<code>out.print()</code>中，作为out.print()的参数；</li><li>&lt;%!…%&gt;：内容会放到<code>_jspService()</code>方法之外，被类直接包含</li></ul></blockquote><p><strong>JSP缺点</strong></p><ul><li>书写麻烦：既要写 HTML 标签，还要写 Java 代码</li><li>前后端没有分离</li><li>调试困难：出错后，需要找到自动生成的.java文件进行调试</li></ul><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL（Expression Language ）表达式语言，用于简化 JSP 页面内的 Java 代码。</p><p>EL 表达式的主要作用是获取数据：就是从域对象中获取数据，然后将数据展示在页面上。而 EL 表达式的语法也比较简单，语法形式为：<code>$&#123;expression&#125;</code> 。例如：<code>$&#123;brands&#125; </code>就是获取域中存储的 key 为 brands 的数据。</p><p>我们定义一个Servlet，在域对象中存储一些数据，然后通过数据共享（请求转发）的方式令JSP资源获取数据并展示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        List&lt;Brand&gt; brands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Brand&gt;();</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">1</span>,<span class="string">&quot;三只松鼠&quot;</span>,<span class="string">&quot;三只松鼠&quot;</span>,<span class="number">100</span>,<span class="string">&quot;三只松鼠，好吃不上火&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">2</span>,<span class="string">&quot;优衣库&quot;</span>,<span class="string">&quot;优衣库&quot;</span>,<span class="number">200</span>,<span class="string">&quot;优衣库，服适人生&quot;</span>,<span class="number">0</span>));</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">3</span>,<span class="string">&quot;小米&quot;</span>,<span class="string">&quot;小米科技有限公司&quot;</span>,<span class="number">1000</span>,<span class="string">&quot;为发烧而生&quot;</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        req.setAttribute(<span class="string">&quot;brands&quot;</span>,brands);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/index.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>index.jsp</code>资源中通过EL表达式获取数据到页面即可，但是<font color="red">要注意在标签中加入<code>isELIgnored=&quot;false&quot;</code></font>表示不忽略EL表达式。</p><p><strong>域对象</strong></p><p>JavaWeb中有四大域对象，分别是：</p><ul><li>page：当前页面有效</li><li>request：当前请求有效</li><li>session：当前会话有效</li><li>application：当前应用有效</li></ul><img src="image-20230329103637590.png" alt="image-20230329103637590" style="zoom: 50%;" /><p>例如<code>$&#123;brands&#125;</code>el 表达式获取数据，会先从page域对象中获取数据，如果没有再到 requet 域对象中获取数据，如果再没有再到 session 域对象中获取，如果还没有才会到 application 中获取数据。</p><h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><p>JSP标准标签库(Jsp Standarded Tag Library) ，使用标签取代JSP页面上的Java代码。</p><p>JSTL 使用也是比较简单的，分为如下步骤：</p><ul><li><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在JSP页面上引入JSTL标签库</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt; </span><br></pre></td></tr></table></figure></li></ul><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == 1&#125;&quot;</span>&gt;</span><br><span class="line">       启用</span><br><span class="line">   &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">   &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == 0&#125;&quot;</span>&gt;</span><br><span class="line">       禁用</span><br><span class="line">   &lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p><em>用法一：</em></p><ul><li><p>items：被遍历的容器</p></li><li><p>var：遍历产生的临时变量</p></li><li><p>varStatus：遍历状态对象</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;brands&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span> varStatus=<span class="string">&quot;status&quot;</span>&gt;</span><br><span class="line">    &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;$&#123;status.count&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p><strong>用法二</strong></p><ul><li><p>begin：开始数</p></li><li><p>end：结束数</p></li><li><p>step：步长</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;1&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><h2 id="MVC模式和三层架构"><a href="#MVC模式和三层架构" class="headerlink" title="MVC模式和三层架构"></a>MVC模式和三层架构</h2><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><p>MVC 是一种分层开发的模式，其中：</p><ul><li><p>M：Model，业务模型，处理业务</p></li><li><p>V：View，视图，界面展示</p></li><li><p>C：Controller，控制器，处理请求，调用模型和视图</p></li></ul><img src="image-20230329105238249.png" alt="image-20230329105238249" style="zoom:67%;" /><p>控制器（Serlvlet）用来接收浏览器发送过来的请求，控制器调用模型（JavaBean）来获取数据，比如从数据库查询数据；控制器获取到数据后再交由视图（JSP）进行数据展示。</p><p><strong>MVC 好处：</strong></p><ul><li><p>有利于分工协作</p></li><li><p>有利于组件重用</p></li></ul><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>三层架构是将我们的项目分成了三个层面：分别是<strong>表现层</strong>、<strong>业务逻辑层</strong>、<strong>数据访问层</strong>。</p><img src="image-20230329105611759.png" alt="image-20230329105611759" style="zoom:67%;" /><ul><li>数据访问层：对数据库的CRUD基本操作；</li><li>业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能。例如“注册业务功能” ，我们会先调用 <code>数据访问层</code> 的 <code>selectByName()</code> 方法判断该用户名是否存在，如果不存在再调用 <code>数据访问层</code> 的 <code>insert()</code> 方法进行数据的添加操作；</li><li>表现层：接收请求，封装数据，调用业务逻辑层，响应数据。</li></ul><p>整个流程是，浏览器发送请求，表现层的Servlet接收请求并调用业务逻辑层的方法进行业务逻辑处理，而业务逻辑层方法调用数据访问层方法进行数据的操作，依次返回到Serlvet，然后Servlet将数据交由 JSP 进行展示。</p><p>三层架构的每一层都有特有的包名称：</p><ul><li>表现层： <code>com.Lijiacheng.controller</code> 或者 <code>com.Lijiacheng.web</code></li><li>业务逻辑层：<code>com.Lijiacheng.service</code></li><li>数据访问层：<code>com.Lijiacheng.dao</code> 或者 <code>com.Lijiacheng.mapper</code></li></ul><h3 id="MVC和三层架构"><a href="#MVC和三层架构" class="headerlink" title="MVC和三层架构"></a>MVC和三层架构</h3><p>三层架构是对MVC 模式实现架构的思想。 那么我们以后按照要求将不同层的代码写在不同的包下，每一层里功能职责做到单一，将来如果将表现层的技术换掉，而业务逻辑层和数据访问层的代码不需要发生变化。</p><img src="image-20230329110654633.png" alt="image-20230329110654633" style="zoom:67%;" /><h2 id="实现增删改查"><a href="#实现增删改查" class="headerlink" title="实现增删改查"></a>实现增删改查</h2><p>这里使用三层架构做增删改查的基础操作，开发流程总结为：</p><ul><li>分析业务（最重要！）</li><li>写sql映射配置文件</li><li>声明与sql配置文件对应的mapper接口函数</li><li>编写<code>service</code>层代码，调用接口函数进行业务实现</li><li>编写<code>Servlet</code>代码，通常是接收数据并将其请求转发进行数据共享</li></ul><p>1、查询全部数据</p><p>​    这个没什么好说的，在Servlet中将<code>brands</code>集合里的数据共享给相应展示的jsp页面即可。</p><p>2、增加数据</p><p>​    业务逻辑是：在查询全部数据页面中点击链接进入添加数据的jsp页面，将jsp页面的表单数据发送给相应的Servlet，在Servlet中接收数据并封装成brand对象，调用业务逻辑层和数据访问层函数将数据添加到数据库当中；最后不要忘记了请求转发回到”查询所有”的资源。</p><p>3、修改数据</p><p>​    业务逻辑是：①在查询全部数据页面中点击<strong>某行数据</strong>的链接，从数据库中根据id找到对应的数据信息将它们回显到修改数据的jsp页面上。回显的流程是，通过调用”根据用户查询“的函数，将数据封装在一个brand对象中，并请求转发给修改数据的jsp页面来接收。②在前端页面修改数据后，通过将form表单中的数据传递到修改数据的Servlet中，将封装了属性的对象作为参数调用业务逻辑层和数据访问层函数将数据在数据库中进行修改，最后仍然是回到”查询所有”的资源。</p><blockquote><p>在”增加“业务和”修改“业务时，需要将表单的数据通过post请求方式传递给服务器，由于存在中文乱码问题，如果不在Servlet中首先通过<code>setCharacterEncoding</code>进行设置，就会出现get到的参数是乱码的问题，这里特别注意一下。</p></blockquote><p>4、删除数据</p><p>​    根据id删除，跟上面的<code>selectById</code>业务基本一致，就不说了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JSP（全称：Java Server Pages），Java 服务端页面。是一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java代码的动态内容， &lt;code&gt;JSP = HTML + Java&lt;/code&gt;。虽然说JSP技术早已过时了，但是在很多国企银行还在使用它，可以把JSP当作javaweb的发展史来学习一下。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>04-Request_Response</title>
    <link href="https://kicheng.github.io/2023/04/01/04-Request-Response/"/>
    <id>https://kicheng.github.io/2023/04/01/04-Request-Response/</id>
    <published>2023-04-01T10:14:47.000Z</published>
    <updated>2023-04-01T10:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>request和response对象代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行；要向容器输出数据，只需要找response对象就行。</p><span id="more"></span><h1 id="Resquest-amp-Response"><a href="#Resquest-amp-Response" class="headerlink" title="Resquest &amp; Response"></a>Resquest &amp; Response</h1><h2 id="Request和Response的概述"><a href="#Request和Response的概述" class="headerlink" title="Request和Response的概述"></a>Request和Response的概述</h2><p>Request是请求对象，Response是响应对象。这两个对象在我们使用Servlet的时候有看到：</p><img src="image-20230328123304964-0344182.png" alt="image-20230328123304964" style="zoom: 50%;" /><ul><li>request：获取请求数据<ul><li>浏览器会发送HTTP请求到后台服务器(Tomcat)</li><li>HTTP的请求中会包含很多请求数据（请求行+请求头+请求体）</li><li>后台服务器(Tomcat)会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中</li><li>所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数</li><li>获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务</li></ul></li><li>response：设置响应数据<ul><li>业务处理完后，后台就需要给前端返回业务处理的结果即响应数据</li><li>把响应数据封装到response对象中</li><li>后台服务器(Tomcat)会解析response对象,按照（响应行+响应头+响应体）格式拼接结果</li><li>浏览器最终解析结果，把内容展示在浏览器给用户浏览</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 使用request对象，获取请求数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);  <span class="comment">// url?name=lijiacheng</span></span><br><span class="line">        <span class="comment">// 使用response对象，设置响应数据</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;&lt;h1&gt;&quot;</span> + name + <span class="string">&quot;，欢迎您！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230328142421229.png" alt="image-20230328142421229"></p><p><code>request</code>对象用来处理来自客户端的请求数据，比如接收请求参数等；<code>responese</code>对象根据接收的数据进一步设置发送给客户端的响应数据。</p><h2 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h2><h3 id="Request继承体系"><a href="#Request继承体系" class="headerlink" title="Request继承体系"></a>Request继承体系</h3><img src="image-20230328142607415-0344182.png" alt="image-20230328142607415" style="zoom:50%;" /><p><code>ServletRequest</code>和<code>HttpServletRequest</code>都是Java提供的接口，接口无法创建对象。</p><img src="image-20230328142751256-0344182.png" alt="image-20230328142751256" style="zoom:67%;" /><p>这个时候，我们就需要用到Request继承体系中的<code>RequestFacade</code>：</p><ul><li>该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口；</li><li>Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器([Tomcat)来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建。</li></ul><blockquote><p>Tomcat（RequestFacade实现类）需要解析请求数据，封装为request对象,并且创建request对象传递到service方法</p></blockquote><h3 id="Request获取请求数据"><a href="#Request获取请求数据" class="headerlink" title="Request获取请求数据"></a>Request获取请求数据</h3><h4 id="获取请求行数据"><a href="#获取请求行数据" class="headerlink" title="获取请求行数据"></a>获取请求行数据</h4><img src="image-20230328143450032-0344182.png" alt="image-20230328143450032" style="zoom:67%;" /><ul><li>获取请求方式: <code>GET</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getMethod</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li>获取虚拟目录(项目访问路径): <code>/JavaWeb_04_Request_Response</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getContextPath</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li>获取URL(统一资源定位符): <code>http://localhost:8080/JavaWeb_04_Request_Response/req1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer <span class="title function_">getRequestURL</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li>获取URI(统一资源标识符): <code>/JavaWeb_04_Request_Response/req1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getRequestURI</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li>获取请求参数**(GET方式)**: <code>username=zhangsan&amp;password=123</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getQueryString</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>由上到下依次获取的结果：</p><img src="image-20230328144502256-0344182.png" alt="image-20230328144502256" style="zoom: 80%;" /><h4 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取请求头数据</h4><p>根据请求头名称获取对应值的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getHeader</span><span class="params">(String key)</span></span><br></pre></td></tr></table></figure><h4 id="获取请求体数据"><a href="#获取请求体数据" class="headerlink" title="获取请求体数据"></a>获取请求体数据</h4><p>浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为<font color="red">POST</font>，请求体中的数据格式如下：</p><img src="image-20230328144816822-0344182.png" alt="image-20230328144816822" style="zoom:67%;" /><p>请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是：</p><ul><li><p>获取<strong>字节输入流</strong>，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取<strong>字符输入流</strong>，如果前端发送的是纯文本数据，则使用该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader <span class="title function_">getReader</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li></ul><p>在<code>req.html</code>中创建form表单传递请求参数，获取字符输入流读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 获取post的请求体数据</span></span><br><span class="line">    <span class="comment">//1. 获取字符输入流</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">    <span class="comment">//2. 读取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到的POST方法的请求体数据：</p><p><img src="image-20230328145615868-0344182.png" alt="image-20230328145615868"></p><h4 id="获取请求参数的通用方式"><a href="#获取请求参数的通用方式" class="headerlink" title="获取请求参数的通用方式"></a>获取请求参数的通用方式</h4><blockquote><p>请求数据则是包含请求行、请求头和请求体的所有数据。请求参数和请求数据的关系：请求参数是请求数据中的部分内容；如果是GET请求，请求参数在请求行中；如果是POST请求，请求参数一般在请求体中。</p></blockquote><p>GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，是否可以提供一种统一获取请求参数的方式，从而统一doGet和doPost方法内的代码?</p><p><code>request</code>的方法中实现了如下操作：</p><p>（1）根据不同的请求方式获取请求参数，获取的内容如下:</p><p><img src="image-20230328161112744-0344182.png" alt="image-20230328161112744"></p><p>（2）把获取到的内容进行分割：</p><img src="image-20230328161131859-0344182.png" alt="image-20230328161131859" style="zoom: 50%;" /><p>（3）把分割后端数据，存入到一个Map集合中：</p><img src="image-20230328161211660-0344182.png" alt="image-20230328161211660" style="zoom: 50%;" /><p>基于上述操作，<code>request</code>对象为我们提供了如下方法：</p><ul><li><p>获取所有参数Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; getParameterMap()</span><br></pre></td></tr></table></figure></li><li><p>根据名称获取参数值（数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] getParameterValues(String name)</span><br></pre></td></tr></table></figure></li><li><p>根据名称获取参数值（单个值）——使用频率比较高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getParameter</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li></ul><p>下面进行获取请求参数的演示<strong>（后续使用的方法）</strong>：</p><p>（1）创建一个req.html的表单</p><img src="image-20230328162535194-0344182.png" alt="image-20230328162535194" style="zoom: 67%;" /><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/JavaWeb_04_Request_Response/req2&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 游泳</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span> 爬山 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）在Servlet代码中获取页面传递请求的参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/req2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有参数的map集合</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            <span class="keyword">for</span>(String value : values)&#123;</span><br><span class="line">                System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GET方式传递请求参数：</p><p><img src="image-20230328163623631-0344182.png" alt="image-20230328163623631"></p><p>后端接收到的GET方式的请求参数：</p><p><img src="image-20230328163711898-0344182.png" alt="image-20230328163711898"></p><p>剩下两个<code>getParameterValues()</code>和<code>getParameter()</code>一个return类型是<code>String[]</code>，一个return类型是<code>String</code>，按需使用即可，这里就不展示了。</p><p>在传递POST请求的参数也如上述所示，只需要修改前端表单的请求类型为<code>POST</code>即可，在Servlet类的<code>doPost()</code>里只需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.doGet(req,resp);</span><br></pre></td></tr></table></figure><h3 id="请求参数中文乱码问题"><a href="#请求参数中文乱码问题" class="headerlink" title="请求参数中文乱码问题"></a>请求参数中文乱码问题</h3><p>不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。</p><h4 id="POST请求解决方案"><a href="#POST请求解决方案" class="headerlink" title="POST请求解决方案"></a>POST请求解决方案</h4><ul><li><p>分析出现中文乱码的原因：</p><ul><li>POST的请求参数是通过request的getReader()来获取流中的数据</li><li>TOMCAT在获取流的时候采用的编码是ISO-8859-1</li><li>ISO-8859-1编码是不支持中文的，所以会出现乱码</li></ul></li><li><p>解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>但这种方式不适用于GET请求。</p><h4 id="GET请求解决方案"><a href="#GET请求解决方案" class="headerlink" title="GET请求解决方案"></a>GET请求解决方案</h4><p><code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>是设置request处理流的编码，但是GET获取请求参数的方式是<code>request.getQueryString()</code>，它并没有通过流的方式获取参数。</p><p>先分析一下GET请求出现乱码的原因：</p><img src="image-20230328182439642-0344182.png" alt="image-20230328182439642" style="zoom: 50%;" /><p>(1)浏览器通过HTTP协议发送请求和数据给后台服务器(Tomcat)</p><p>(2)浏览器在发送HTTP的过程中会对中文数据进行URL编码</p><p>(3)在进行URL编码的时候会采用页面<code>&lt;meta&gt;</code>标签指定的UTF-8的方式进行编码，“张三”编码后的结果为”%E5%BC%A0%E4%B8%89“</p><p>(4)后台服务器(Tomcat)接收到<code>%E5%BC%A0%E4%B8%89</code>后会默认按照<code>ISO-8859-1</code>进行URL解码</p><p>(5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。</p><p>关于URL编解码，Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.URLEncoder.encode(<span class="string">&quot;需要被编码的内容&quot;</span>,<span class="string">&quot;字符集(UTF-8)&quot;</span>)  <span class="comment">// encode</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.URLDecoder.decode(<span class="string">&quot;需要被解码的内容&quot;</span>,<span class="string">&quot;字符集(UTF-8)&quot;</span>)  <span class="comment">// decode</span></span><br></pre></td></tr></table></figure><p>我们可以发现：在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的<code>%E5%BC%A0%E4%B8%89</code>是一致的，所以具体的解决方案为：① 按照ISO-8859-1编码获取乱码<code>å¼ ä¸</code>对应的字节数组；② 按照UTF-8编码获取字节数组对应的字符串。</p><blockquote><p>Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8。</p></blockquote><h3 id="Request请求转发"><a href="#Request请求转发" class="headerlink" title="Request请求转发"></a>Request请求转发</h3><p>请求转发(forward)是一种在服务器内部的资源跳转方式。</p><img src="image-20230328194558560-0344182.png" alt="image-20230328194558560" style="zoom: 33%;" /><p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求；</p><p>(2)资源A处理完请求后将请求发给资源B；</p><p>(3)资源B处理完后将结果响应给浏览器；</p><p>(4)请求从资源A到资源B的过程就叫<strong>请求转发</strong>。</p><p><strong>请求转发的实现方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;资源B路径&quot;</span>).forward(req,resp);</span><br></pre></td></tr></table></figure><p><strong>请求转发资源间共享数据</strong></p><p>需要使用request对象提供的三个方法：</p><ul><li>存储数据到request域[范围,数据是存储在request对象]中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object o)</span>;</span><br></pre></td></tr></table></figure><ul><li>根据key获取值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><ul><li>根据key删除该键值对</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><p><strong>请求转发的特点</strong></p><ul><li><p>浏览器地址栏路径不发生变化：虽然后台从<code>/req3</code>转发到<code>/req4</code>,但是浏览器的地址一直是<code>/req4</code>，未发生变化</p><p><img src="image-20230328195744977-0344182.png" alt="image-20230328195744977"></p></li><li><p>只能转发到当前服务器的内部资源：不能从一个服务器通过转发访问另一台服务器</p></li><li><p>一次请求，可以在转发资源间使用request共享数据：虽然后台从<code>/req3转发到</code>/req4`，但是这个只有<font color="red">一次请求</font></p></li></ul><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><h3 id="Response继承体系"><a href="#Response继承体系" class="headerlink" title="Response继承体系"></a>Response继承体系</h3><img src="image-20230328200036194-0344182.png" alt="image-20230328200036194" style="zoom: 50%;" /><h3 id="Response设置响应数据"><a href="#Response设置响应数据" class="headerlink" title="Response设置响应数据"></a>Response设置响应数据</h3><ul><li>响应行</li></ul><p>对于响应头，比较常用的就是设置响应状态码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> sc)</span>;</span><br></pre></td></tr></table></figure><ul><li>响应头</li></ul><p>设置响应头键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setHeader</span><span class="params">(String name,String value)</span>;</span><br></pre></td></tr></table></figure><ul><li>响应体</li></ul><p>对于响应体，是通过字符、字节输出流的方式往浏览器写。</p><p>获取字符输出流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter <span class="title function_">getWriter</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>获取字节输出流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="Response请求重定向"><a href="#Response请求重定向" class="headerlink" title="Response请求重定向"></a>Response请求重定向</h3><p>Response重定向(redirect)是另一种资源跳转方式。</p><img src="image-20230328200601634.png" alt="image-20230328200601634" style="zoom:50%;" /><p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求；</p><p>(2)资源A现在无法处理该请求，就会<font color="red">给浏览器响应</font>一个302状态码和location一个访问资源B的路径；</p><p>(3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B；</p><p>(4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向。</p><p><strong>重定向实现方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resposne.setStatus(<span class="number">302</span>);</span><br><span class="line">resposne.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;资源B的访问路径&quot;</span>);  <span class="comment">// &quot;/JavaWeb_04_Request_Response/resp2&quot;</span></span><br></pre></td></tr></table></figure><p>或者用简化后的一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resposne.sendRedirect(<span class="string">&quot;/JavaWeb_04_Request_Response/resp2&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>重定向的特点</strong></p><ul><li><p>浏览器地址栏路径发送变化：当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化；</p><img src="image-20230328201530915.png" alt="image-20230328201530915" style="zoom: 67%;" /></li><li><p>可以重定向到任何位置的资源（服务内容、外部均可）：因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源；</p></li><li><p>两次请求，不能在多个资源使用request共享数据：因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据。</p></li></ul><p>请求转发和重定向的比较：</p><p><img src="image-20230328201650015.png" alt="image-20230328201650015"></p><blockquote><p><strong>什么时候用项目访问路径，什么时候不需要？</strong></p><p>判断的依据很简单，只需要记住下面的规则即可:</p><ul><li>浏览器使用：需要加虚拟目录(项目访问路径)</li><li>服务端使用：不需要加虚拟目录</li></ul></blockquote><p>对于请求转发来说，因为是在服务端进行的，所以不需要加虚拟目录；对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。同时，由于虚拟目录的项目路径是硬编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改。可以在使用虚拟目录时动态配置，降低代码的耦合度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line">   response.sendRedirect(contextPath+<span class="string">&quot;/resp2&quot;</span>);  <span class="comment">// 重定向</span></span><br></pre></td></tr></table></figure><h3 id="Response响应字符数据"><a href="#Response响应字符数据" class="headerlink" title="Response响应字符数据"></a>Response响应字符数据</h3><p>要想将字符数据写回到浏览器，我们需要两个步骤：</p><ul><li><p>通过Response对象获取字符输出流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br></pre></td></tr></table></figure></li><li><p>通过字符输出流写数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.write(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>在之前要记得设置服务器发送给浏览器的数据类型和数据编码格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code>  等于 <code>response.setHeader(&quot;content-type&quot;, &quot;text/html&quot;); </code>和<code>response.setCharacterEncoding(&quot;utf-8&quot;); </code> 两句。</p></blockquote><p>一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。</p><h3 id="Response响应字节数据"><a href="#Response响应字节数据" class="headerlink" title="Response响应字节数据"></a>Response响应字节数据</h3><p>要想将字节数据写回到浏览器，我们需要两个步骤：</p><ul><li><p>通过Response对象获取字节输出流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> resp.getOutputStream();</span><br></pre></td></tr></table></figure></li><li><p>通过字节输出流写数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(字节数据);</span><br></pre></td></tr></table></figure></li></ul><p><strong>实现方式1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            <span class="comment">// 1、读取文件</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/main/webapp/picture.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、获取response字节流</span></span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">            <span class="comment">// 3、完成流的copy</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">                outputStream.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>实现方式2</strong></p><p>我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是：</p><p>（1）pom.xml添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）调用工具类方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOUtils.copy(fis,os);  <span class="comment">// fis:输入流  os:输出流</span></span><br></pre></td></tr></table></figure><p>优化后的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1、读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/main/webapp/picture.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、获取response字节流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">// 3、完成流的copy</span></span><br><span class="line">        IOUtils.copy(fis,outputStream);</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;request和response对象代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行；要向容器输出数据，只需要找response对象就行。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>03_Servlet</title>
    <link href="https://kicheng.github.io/2023/03/28/03-Servlet/"/>
    <id>https://kicheng.github.io/2023/03/28/03-Servlet/</id>
    <published>2023-03-28T02:14:31.000Z</published>
    <updated>2023-03-28T02:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet是JavaWeb最为核心的内容，它是Java提供的一门动态web资源开发技术。</p><span id="more"></span><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul><li><p>使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容</p></li><li><p>Servlet是JavaEE规范之一，其实就是一个<strong>接口</strong>，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p></li></ul><img src="image-20230327190333387.png" alt="image-20230327190333387" style="zoom: 33%;" /><h2 id="Servlet快速入门"><a href="#Servlet快速入门" class="headerlink" title="Servlet快速入门"></a>Servlet快速入门</h2><p>1、导入Servlet依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    provided指的是在编译和测试过程中有效,最后生成的war包时不会加入</span></span><br><span class="line"><span class="comment">    因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、定义一个类，实现Servlet接口，并重写接口中所有方法</p><p>3、在类上使用<code>@WebServlet</code>注解，配置该Servlet的访问路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="Servlet执行流程"><a href="#Servlet执行流程" class="headerlink" title="Servlet执行流程"></a>Servlet执行流程</h2><img src="image-20230327214158461.png" alt="image-20230327214158461" style="zoom:50%;" /><ul><li>浏览器发出<code>http://localhost:8080/JavaWeb_03_Servlet/demo1</code>请求，从请求中可以解析出三部分内容，分别是<code>localhost:8080</code>、<code>JavaWeb_03_Servlet</code>、<code>demo1</code><ul><li>根据<code>localhost:8080</code>可以找到要访问的Tomcat Web服务器</li><li>根据<code>JavaWeb_03_Servlet</code>可以找到部署在Tomcat服务器上的JavaWeb_03_Servlet项目</li><li>根据<code>demo1</code>可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配</li></ul></li><li>找到ServletDemo_01这个类后，Tomcat Web服务器就会<strong>为ServletDemo_01这个类创建一个对象，然后调用对象中的service方法</strong><ul><li>ServletDemo_01实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用</li><li>service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互</li></ul></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期：指一个对象从被创建到被销毁的整个过程</p><p>Servlet运行在Servlet容器（web服务器）中，其生命周期由容器来管理，分为4个阶段：</p><ul><li><p>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</p><p>默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能<strong>把Servlet的创建放到服务器启动的时候来创建</strong>？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)</span></span><br><span class="line"><span class="comment">/* loadOnstartup的取值有两类情况</span></span><br><span class="line"><span class="comment">（1）负整数:第一次访问时创建Servlet对象</span></span><br><span class="line"><span class="comment">（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高 */</span></span><br></pre></td></tr></table></figure></li><li><p>初始化：在Servlet实例化之后，容器将调用Servlet的<code>init()</code>方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作，该方法只调用一次</p></li><li><p>请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的<code>service()</code>方法对请求进行处理</p></li><li><p>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的<code>destroy()</code>方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收。</p></li></ul><h2 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h2><img src="image-20230327220008677.png" alt="image-20230327220008677" style="zoom:50%;" /><p>我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会通过继承<code>HttpServlet</code>的方式代替实现接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo_02</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送GET请求就不说了，发送POST请求需要在html页面中创建一个表单传递请求参数，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/JavaWeb_03_Servlet/demo2&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么HttpServlet中要根据请求方式的不同，调用不同的方法？</p><p>前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理。</p></blockquote><h2 id="urlPattern配置"><a href="#urlPattern配置" class="headerlink" title="urlPattern配置"></a>urlPattern配置</h2><p>Servlet类编写好后，要想被访问到，就需要配置其访问路径。</p><p><strong>urlPattern配置规则：</strong></p><ul><li>精确匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置路径</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/user/select&quot;)</span></span><br></pre></td></tr></table></figure><p>访问路径为 <code>http://localhost:8080/JavaWeb_03_Servlet/user/select</code></p><ul><li>目录匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置路径</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/user/*&quot;)</span></span><br></pre></td></tr></table></figure><p>访问路径 <code>http://localhost:8080/JavaWeb_03_Servlet/user/aaa </code>、<code>http://localhost:8080/JavaWeb_03_Servlet/user/bbb</code> 等等</p><ul><li>扩展名匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置路径</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span></span><br></pre></td></tr></table></figure><p>访问路径为 <code>http://localhost:8080/JavaWeb_03_Servlet/任意.do</code></p><blockquote><p>如果路径配置的不是扩展名，那么在路径的前面就<font color="red">必须要加<code>/</code>否则会报错</font>；</p><p>如果路径配置的是<code>*.do</code>,那么在*.do的前面不能加<code>/</code>,否则会报错！</p></blockquote><ul><li>任意匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置路径</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/&quot;)</span> </span><br></pre></td></tr></table></figure><p>访问路径为 <code>http://localhost:8080/JavaWeb_03_Servlet/任意</code></p><blockquote><p>当我们的项目中的Servlet配置了 “/“,会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet。DefaultServlet是用来处理静态资源，如果配置了”/“会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终<font color="red">导致静态资源不能被访问</font>。</p></blockquote><p>上面这段话如何理解呢？我们在访问静态资源例如html静态页面时，<code>http://localhost:8080/JavaWeb_03_Servlet/a.html</code>，但是由于进行了任意匹配覆盖了DefaultServlet，在访问该路径时就会走这个任意匹配的Servlet，而a.html就访问不到啦。</p><h2 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h2><p>前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。这里只需要了解一下即可，现在几乎不会在web.xml中进行配置了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Servlet 全类名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet的名称，名字任意--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet的类全名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.Lijiacheng.web.ServletDemo_02<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      Servlet 访问路径</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet的名称，要和上面的名称一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet的访问路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Servlet是JavaWeb最为核心的内容，它是Java提供的一门动态web资源开发技术。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP&amp;Tomcat</title>
    <link href="https://kicheng.github.io/2023/03/28/HTTP-Tomcat/"/>
    <id>https://kicheng.github.io/2023/03/28/HTTP-Tomcat/</id>
    <published>2023-03-28T02:10:41.000Z</published>
    <updated>2025-01-10T13:49:04.911Z</updated>
    
    <content type="html"><![CDATA[<p>今天记录一下HTTP协议和一种目前使用最广泛的轻量级web服务器——Tomcat！</p><span id="more"></span><h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><p><strong>什么是Web</strong></p><p>Web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。</p><h2 id="JavaWeb-1"><a href="#JavaWeb-1" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="B-S架构"><a href="#B-S架构" class="headerlink" title="B/S架构"></a>B/S架构</h3><p>Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。</p><img src="image-20230327160756485.png" alt="image-20230327160756485" style="zoom: 50%;" /><blockquote><p>B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。</p></blockquote><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。</p><h3 id="动态资源"><a href="#动态资源" class="headerlink" title="动态资源"></a>动态资源</h3><p>在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容。动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理；动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库(DB)主要负责存储数据。</p><img src="image-20230327161636792.png" alt="image-20230327161636792" style="zoom: 50%;" /><p>整个web访问过程如下图所示：</p><p>(1) 浏览器发送一个请求到服务端，去请求所需要的相关资源;<br>(2) 资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容;<br>(3) 在Java代码可以进行业务处理也可以从数据库中读取数据;<br>(4) 拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好;<br>(5) 服务端将静态资源响应给浏览器;<br>(6) 浏览器将这些资源进行解析;<br>(7) 解析后将效果展示在浏览器，用户就可以看到最终的结果。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议（HTTP）是一个<strong>用于传输超媒体文档（例如HTML）的应用层协议</strong>。 它是为Web 浏览器与Web 服务器之间的通信而设计的，但也可以用于其他目的。 HTTP 遵循经典的客户端—服务端模型，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应。</p><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器。后续我们使用一款轻量级最popular的Tomcat服务器。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><p><strong>HyperText Transfer Protocol</strong>，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><ul><li>数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。</li><li>如果想知道具体的格式，可以打开浏览器，打开开发者工具，点击<code>Network</code>来查看某一次请求的请求数据和响应数据具体的格式内容：</li></ul><img src="image-20230327171036892.png" alt="image-20230327171036892" style="zoom: 33%;" /><p><strong>HTTP协议特点</strong></p><p>HTTP协议有它自己的一些特点，分别是:</p><ul><li><p>基于TCP协议: 面向连接，安全</p><p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。</p></li><li><p>基于请求-响应模型的:一次请求对应一次响应</p><p>请求和响应是一一对应关系</p></li><li><p>HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的</p><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点：</p><ul><li>缺点:多次请求间不能共享数据</li><li>优点:速度快</li></ul><p>请求之间无法共享数据会引发的问题，如:</p><ul><li>京东购物，<code>加入购物车</code>和<code>去购物车结算</code>是两次请求，</li><li>HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li><li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li></ul></li></ul><h3 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a>请求数据格式</h3><ul><li><p>请求行：请求方式</p></li><li><p>请求头：key-value格式</p><p>服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求</p></li><li><p>请求体：POST请求的最后一部分，存储请求参数</p><ul><li>GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中</li><li>GET请求请求参数大小有限制，POST没有</li></ul></li></ul><h3 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h3><ul><li><p>响应行：状态码、状态码描述</p></li><li><p>响应头：key-value</p></li><li><p>响应体：存放响应数据</p><ul><li>200  ok 客户端请求成功</li><li>404  Not Found 请求资源不存在</li><li>500 Internal Server Error 服务端发生不可预期的错误</li></ul></li></ul><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Web服务器-1"><a href="#Web服务器-1" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>Web服务器是一个应用程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。</p><img src="image-20230327172954741.png" alt="image-20230327172954741" style="zoom: 50%;" /><p> Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器中的页面就可以直接通过浏览器来访问了。</p><blockquote><p>Web浏览器的作用：①封装HTTP协议操作，简化开发；②可以将Web项目部署到服务器中，对外提供网上浏览服务。</p></blockquote><p>因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。Tomcat的官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> </p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>（这边暂时先省略不掌握）</p><h3 id="Maven创建Web项目"><a href="#Maven创建Web项目" class="headerlink" title="Maven创建Web项目"></a>Maven创建Web项目</h3><p>新创建好的Web项目结构如下：</p><img src="image-20230327174246976.png" alt="image-20230327174246976" style="zoom: 67%;" /><blockquote><p>要注意pom.xml中的打包方式为<code>&lt;packaging&gt;war&lt;/packaging&gt;</code>，默认为jar。</p></blockquote><h3 id="IDEA使用Tomcat"><a href="#IDEA使用Tomcat" class="headerlink" title="IDEA使用Tomcat"></a>IDEA使用Tomcat</h3><p>Maven Web项目创建成功后，通过Maven的<code>package</code>命令可以将项目打包成war包，将war文件拷贝到Tomcat的<code>webapps</code>目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可，但是这种方式非常不方便。</p><h4 id="集成本地Tomcat"><a href="#集成本地Tomcat" class="headerlink" title="集成本地Tomcat"></a>集成本地Tomcat</h4><p><strong>配置Tomcat属性</strong></p><img src="image-20230327175323649.png" alt="image-20230327175323649" style="zoom:67%;" /><blockquote><p> xxx.war和 xxx.war exploded这两种部署项目模式的区别：war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容；war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署。建议使用war模式进行部署。</p></blockquote><h4 id="Tomcat插件集成"><a href="#Tomcat插件集成" class="headerlink" title="Tomcat插件集成"></a>Tomcat插件集成</h4><p>还有一种更简单的方式，那就是直接使用Maven中的Tomcat插件来部署项目：</p><p>1、在pom.xml中添加Tomcat插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Tomcat插件 集成 Tomcat7--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、使用Maven Helper插件快速启动项目，选中项目，右键–&gt;Run Maven –&gt; tomcat7:run</p><img src="image-20230327190120842.png" alt="image-20230327190120842" style="zoom: 67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;今天记录一下HTTP协议和一种目前使用最广泛的轻量级web服务器——Tomcat！&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>02_Mybatis练习</title>
    <link href="https://kicheng.github.io/2023/03/28/02-Mybatis%E7%BB%83%E4%B9%A0/"/>
    <id>https://kicheng.github.io/2023/03/28/02-Mybatis%E7%BB%83%E4%B9%A0/</id>
    <published>2023-03-28T02:05:29.000Z</published>
    <updated>2023-03-28T02:07:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面记录了mybatis，它是一种简化jdbc开发操作关系型数据库的持久层框架。下面我们用mybatis进行一些简单的业务来操作mysql数据库。基础的操作和代码我就不完整的展示了，我就记录一下比较容易出错的地方和需要注意的细节了。</p><span id="more"></span><h1 id="Mybatis-CRUD"><a href="#Mybatis-CRUD" class="headerlink" title="Mybatis CRUD"></a>Mybatis CRUD</h1><h2 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h2><p><code>selectAll</code>操作很简单，但是我们发现有些数据没有被封装成功，仍然是null：</p><p><img src="image-20230326151900257.png" alt="image-20230326151900257"></p><p>这是为什么呢，原因还要从mapper代理开发的过程来说起。因为在代理开发中通过接口代理对象调用接口中的函数，再在相应的sql映射文件中找sql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_brand;</span><br></pre></td></tr></table></figure><p>找到的sql语句没问题，而它在编译的时候是变成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,brand_name,company_name,ordered,description,status from tb_brand;</span><br></pre></td></tr></table></figure><p>sql语句执行后会从数据库中select出满足条件的数据，将其封装成定义的<code>Brand</code>类的对象并通过<code>List</code>集合的形式返回。但是在mapper代理开发的过程中封装成Brand对象的过程是自动进行的，那么mybatis并不知道<code>brand_name</code>数据应该被set成Brand对象中的<code>brandName</code>属性，这就是问题的关键。</p><p>要解决这个问题的思路就是将二者形成映射关系，让<code>mybatis</code>在封装的时候能将其对应上。目前在mybatis上有两种解决的方案：</p><ul><li><p>给字段起别名</p><ul><li><p>直接在sql语句中用<code>AS</code>起别名即可，但是这样操作非常麻烦！</p></li><li><p>还有一种方法，mybatis提供了sql片段可以提高sql语句的复用性，但仍然非常麻烦而且不灵活：将需要复用的sql片段抽取到<sql>标签中，在sql语句中使用<include refid="sql的id"/>引用即可。</p></li></ul></li><li><p>使用<code>resultMap</code>映射</p><p>在<code>sql映射配置文件</code>中使用<code>resultMap</code>定义属性和字段的映射关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           id：完成主键字段的映射</span></span><br><span class="line"><span class="comment">               column：表的列名</span></span><br><span class="line"><span class="comment">               property：实体类的属性名</span></span><br><span class="line"><span class="comment">           result：完成一般字段的映射</span></span><br><span class="line"><span class="comment">               column：表的列名</span></span><br><span class="line"><span class="comment">               property：实体类的属性名</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><resultMap>标签的<code>id</code>属性，要在下面sql映射文件的sql语句标签中引用，表示在这段sql代码中使用了如上的resultMap映射关系以自动封装数据；而<code>type</code>属性则和sql语句中的<code>type</code>一致即可，都指向pojo中的某个实体类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">       select * from tb_brand;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>现在再看从封装到Brand对象中的数据就没问题了：</p><p><img src="image-20230326154957319.png" alt="image-20230326154957319"></p><h2 id="按照id查询"><a href="#按照id查询" class="headerlink" title="按照id查询"></a>按照id查询</h2><p>在这里记录一下如何在映射配置文件的sql语句中使用<strong>参数占位符</strong>。</p><p>这是在映射文件中的sql语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">       select * from tb_brand where id = #&#123;id&#125;;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis中提供了两种参数占位符：</p><ul><li><p>#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值，可以看出使用#{} 底层使用的是 <code>PreparedStatement</code></p></li><li><p>${} ：拼接SQL。底层使用的是 <code>Statement</code>，会存在SQL注入问题，所以不使用它。</p></li></ul><img src="image-20230326160640669.png" alt="image-20230326160640669" style="zoom: 50%;" /><blockquote><p>对于有参数的mapper接口方法，我们在sql映射配置文件中应该配置 <code>ParameterType</code> 来指定参数类型。只不过该属性都可以省略。</p></blockquote><p>还需要注意的一点是可能会在sql映射文件中的sql语句中用到一些特殊字符，比方说：</p><img src="image-20230326160952157.png" alt="image-20230326160952157" style="zoom:67%;" /><p>xml文件会将sql中的”&lt;”、”&gt;”识别成标签符号，所以需要用相应的转义字符替代，这个用到的时候网上一搜就行了。</p><h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><p><strong>如何编写接口方法：</strong></p><ul><li>使用 <code>@Param(&quot;参数名称&quot;)</code> 标记每一个参数，在映射配置文件中就需要使用 <code>#&#123;参数名称&#125;</code> 进行占位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status, <span class="meta">@Param(&quot;companyName&quot;)</span> String companyName,<span class="meta">@Param(&quot;brandName&quot;)</span> String brandName)</span>;</span><br></pre></td></tr></table></figure><ul><li>将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的内容必须和实体类属性名保持一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure><ul><li>将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的内容必须和map集合中Key的名称一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure><p><strong>如何使用动态SQL：</strong>用户在输入条件时，肯定不会所有的条件都填写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">       select * from tb_brand</span><br><span class="line">       <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">               and brand_name like #&#123;brandName&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">               and company_name like #&#123;companyName&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">               and status = #&#123;status&#125;;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单个条件的动态sql：</p><p>用<choose></choose>里面<when test="条件"></when>标签，相当于<code>switch</code>和<code>case</code>。</p></blockquote><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><ul><li><p><font color="red">注意1：</font>如果要通过add、update等对数据库里的数据进行改动，那需要在测试类中手动使用<code>sqlSession.commit()</code>提交事务。</p></li><li><p><font color="red">注意2：</font>主键返回——在数据添加成功后，有时候需要获取插入数据库数据的主键。</p><ul><li>useGeneratedKeys：是够获取自动增长的主键值。true表示获取</li><li>keyProperty  ：指定将获取到的主键值封装到哪儿个属性里</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>修改肯定不会修改数据所有的属性，&lt;*set*&gt; 标签可以用于动态包含需要更新的列，忽略其它不更新的列。</p><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><p>编写SQL时需要遍历数组来拼接SQL语句，Mybatis 提供了 <code>foreach</code> 标签供我们使用。</p><p><strong>foreach 标签</strong></p><p>用来迭代任何可迭代的对象（如数组，集合）。</p><ul><li>collection 属性：<ul><li>mybatis会将数组参数，封装为一个Map集合。<ul><li>默认：array = 数组</li><li>使用@Param注解改变map集合的默认key的名称</li></ul></li></ul></li><li>item 属性：本次迭代获取到的元素。</li><li>separator 属性：集合项迭代之间的分隔符。<code>foreach</code> 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。</li><li>open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次</li><li>close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">        delete from tb_brand where id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        ;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>接口参数是多个时，在每个参数上都使用 <code>@Param</code> 注解。这样代码的可读性更高。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username,<span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br></pre></td></tr></table></figure><h2 id="注解开发CRUD"><a href="#注解开发CRUD" class="headerlink" title="注解开发CRUD"></a>注解开发CRUD</h2><p>使用注解开发会比使用sql配置文件开发更加方便，使用了注解，就不需要再映射配置文件中书写对应的 <code>statement</code>。</p><p>官方文档是这么说的：</p><p><img src="image-20230327154233410.png" alt="image-20230327154233410"></p><p>所以给出的结论是：简单sql用注解开发，复杂sql仍然用sql映射配置文件。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Delete(&quot;delete from tb_brand where id = #&#123;id&#125;;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面记录了mybatis，它是一种简化jdbc开发操作关系型数据库的持久层框架。下面我们用mybatis进行一些简单的业务来操作mysql数据库。基础的操作和代码我就不完整的展示了，我就记录一下比较容易出错的地方和需要注意的细节了。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>02_Mybatis</title>
    <link href="https://kicheng.github.io/2023/03/28/02-Mybatis/"/>
    <id>https://kicheng.github.io/2023/03/28/02-Mybatis/</id>
    <published>2023-03-28T02:02:05.000Z</published>
    <updated>2023-03-28T02:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis是一款很重要的开发框架！</p><span id="more"></span><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h2><p>​        MyBatis 是一款优秀的<strong>持久层框架</strong>，用于简化 JDBC 开发。</p><blockquote><p><strong>持久层：</strong>负责将数据到保存到数据库的那一层代码。开发中我们会将操作数据库的Java代码作为持久层，而Mybatis就是对jdbc代码进行了封装。（JavaEE三层架构：表现层、业务层、持久层）</p></blockquote><h3 id="JDBC缺点"><a href="#JDBC缺点" class="headerlink" title="JDBC缺点"></a>JDBC缺点</h3><img src="image-20230325185145333.png" alt="image-20230325185145333" style="zoom:67%;" /><ul><li><p>硬编码</p><ul><li><p>注册驱动、获取连接</p><p>上图①的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。</p></li><li><p>SQL语句</p><p>上图②的代码。如果表结构发生变化，SQL语句就要进行更改，这也不方便后期的维护。</p></li></ul></li><li><p>操作繁琐</p><ul><li><p>手动设置参数</p></li><li><p>手动封装结果集</p><p>上图④的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。</p></li></ul></li></ul><h3 id="Mybatis的优化"><a href="#Mybatis的优化" class="headerlink" title="Mybatis的优化"></a>Mybatis的优化</h3><ul><li>硬编码可以配置到配置文件</li><li>操作繁琐的地方mybatis都自动完成</li></ul><h2 id="Mybatis快速入门"><a href="#Mybatis快速入门" class="headerlink" title="Mybatis快速入门"></a>Mybatis快速入门</h2><p>1、在<code>pom.xml</code>中导入依赖坐标</p><p>至少需要：Mybatis、Mysql依赖</p><p>直接去找：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p><p>2、编写<code>Mybatis</code>核心配置文件</p><p>在模块下的<code> resources</code> 目录下创建mybatis的配置文件 <code>mybatis-config.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、编写sql映射文件（统一管理sql语句，解决硬编码问题）</p><p>在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;usermapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.Lijiacheng.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、编码</p><ul><li><p>在<code>pojo</code>包下创建<code>User</code>的javaBean类。</p></li><li><p>创建测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">//2. 获取sqlSession对象，用来执行sql语句</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;usermapper.selectAll&quot;</span>);  <span class="comment">//该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Mybatis的硬编码配置都可以在官方文档中找到：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p></blockquote><h2 id="Mybatis代理开发"><a href="#Mybatis代理开发" class="headerlink" title="Mybatis代理开发"></a>Mybatis代理开发</h2><h3 id="代理开发概述"><a href="#代理开发概述" class="headerlink" title="代理开发概述"></a>代理开发概述</h3><p>之前使用Mybatis的时候也存在硬编码问题：</p><p><img src="image-20230325192705282.png" alt="image-20230325192705282"></p><p>这里调用 <code>selectList()</code> 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式则不存在硬编码问题：</p><img src="image-20230326141250750.png" alt="image-20230326141250750" style="zoom:67%;" /><p>通过上面的描述可以看出 Mapper 代理方式的目的：</p><ul><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ul><h3 id="使用Mapper代理开发"><a href="#使用Mapper代理开发" class="headerlink" title="使用Mapper代理开发"></a>使用Mapper代理开发</h3><ul><li>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</li></ul><img src="image-20230326133634591.png" alt="image-20230326133634591" style="zoom: 67%;" /><ul><li>设置SQL映射文件的namespace属性为<strong>Mapper接口全限定名</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.Lijiacheng.mapper.UserMapper&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在 Mapper 接口中定义方法，方法名就是<strong>SQL映射文件中sql语句的id</strong>，并保持参数类型和返回值类型一致</li></ul><img src="image-20230325194636891.png" alt="image-20230325194636891" style="zoom:67%;" /><p>​    在接口声明相应函数后，点击左侧<code>mapper</code>小图标可以跳转到xml映射文件相应id的sql语句上。</p><img src="image-20230326133752273.png" alt="image-20230326133752273" style="zoom:67%;" /><ul><li>测试类中内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo_Mapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">//2. 获取sqlSession对象，用来执行sql语句</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//3. 获取接口代理对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">usermapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; users = usermapper.selectAll();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另外，使用Mapper代理的方法，在<code>mapper</code>接口和<code>sql映射文件</code>同名的前提下，可以在<code>mybatis</code>核心配置文件中通过包扫描的方式简化sql映射文件的加载。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;mapper resource=&quot;com/Lijiacheng/mapper/UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Mapper代理方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h2><p><strong>类型别名</strong></p><p>在sql映射配置文件中的 <code>resultType</code> 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 <code>类型别名</code>(typeAliases) 可以简化这部分的书写。</p><p>首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），<font color="red">不区分大小写</font>。内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name属性的值是实体类所在包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.pojo&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过上述的配置，我们就可以简化映射配置文件中 <code>resultType</code> 属性值的编写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 如果没配置&lt;typeAliases&gt;的话，必须是类的全限定名 --&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后我们总结一下<code>Mybatis</code>进行代理开发的流程：</p><p>1、首先和入门的开发流程相同，需要进行核心配置文件的配置、以及在<code>resource</code>目录下创建sql映射文件。</p><p>核心配置文件可以从mybatis官网上直接copy：<a href="https://mybatis.org/mybatis-3/zh/%EF%BC%88%E6%88%91%E5%B1%85%E7%84%B6%E5%9C%A8%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%8A%E6%89%BE%E4%B8%8D%E5%88%B0%EF%BC%8C%E8%BF%99%E9%87%8C%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%EF%BC%89">https://mybatis.org/mybatis-3/zh/（我居然在谷歌搜索引擎上找不到，这里记录一下）</a></p><p>配置文件需要注意的两个点，如下图：</p><p><img src="image-20230326142309667.png" alt="image-20230326142309667"></p><ul><li><p>配置类型别名，简化sql映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.pojo&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载sql映射配置时进行包扫描（特别是在以后开发中有多个sql映射文件时）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--Mapper代理方式--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.Lijiacheng.mapper&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>sql映射文件需要注意的几个点：</p><p><img src="image-20230326143114568.png" alt="image-20230326143114568"></p><ul><li><p><code>namespace</code>属性对应的是<code>mapper</code>目录下的mapper接口</p></li><li><p><code>id</code>属性对应的是接口中声明的方法，这里的<font color='red'><code>id</code>属性要和<code>接口方法名</code>一致！</font></p></li><li><p><code>resultType</code>属性可以直接使用别名，习惯上直接用实体类名即可（前提要配置类型别名）</p></li></ul><p>2、在<code>mapper</code>目录下创建和sql映射文件同名的mapper接口，声明方法</p><p>3、实体类一定要有啊，这个不用说了</p><p>4、测试类前面也是一样的，唯一不同的就是需要获取一个接口代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserMapper</span> <span class="variable">usermapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure><p>通过这个对象可以调用接口中声明的函数，接口中的函数和sql映射文件中的id值相同，这样就找到了需要执行的sql语句，这样就可以操作数据库了，并通过你调用的函数返回结果。</p><blockquote><p>还有一个比较重要的点：</p><p>当你Bean类中的成员变量和操作数据库的数据名不同时，如何产生映射关系。这个放在后面的帖子里记录会比较容易懂。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis是一款很重要的开发框架！&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://kicheng.github.io/2023/03/28/Maven/"/>
    <id>https://kicheng.github.io/2023/03/28/Maven/</id>
    <published>2023-03-28T01:53:53.000Z</published>
    <updated>2025-01-10T13:48:33.380Z</updated>
    
    <content type="html"><![CDATA[<p>Maven是专门用于管理和构建Java项目的工具。</p><span id="more"></span><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>他的主要功能有：</p><p>提供一套<strong>标准化的项目结构：</strong></p><p>​        所有的IDE使用Maven构建的项目完全一样，IDE创建的Maven项目可以通用。如下图就是Maven构建的项目结构：</p><img src="image-20230325163946659.png" alt="image-20230325163946659" style="zoom: 50%;" /><p><strong>标准化的构建流程：</strong></p><img src="image-20230325164020995.png" alt="image-20230325164020995" style="zoom: 67%;" /><p>​        代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p><p><strong>依赖管理：</strong></p><p>​        依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包，复制到项目中，还要将jar包加入工作环境这一系列的操作。</p><p>​        而Maven使用标准的 <strong>坐标</strong> 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。</p><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><h3 id="Maven模型"><a href="#Maven模型" class="headerlink" title="Maven模型"></a>Maven模型</h3><img src="image-20230325165659563.png" alt="image-20230325165659563" style="zoom:67%;" /><p>​        紫色框框起来的部分，他就是用来完成<strong>标准化构建流程</strong> 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。</p><p>​                                           <img src="image-20230325165737480.png" alt="image-20230325165737480" style="zoom: 67%;" /></p><p>​        上图中紫色框起来的部分，项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标。依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>​        我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。</p><p><strong>仓库分类：</strong></p><ul><li><p>本地仓库：自己计算机上的一个目录</p></li><li><p>中央仓库：由Maven团队维护的全球唯一的仓库</p><ul><li>地址： <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li></ul></li><li><p>远程仓库(私服)：一般由公司团队搭建的私有仓库</p><p>​        我们在使用坐标指定项目依赖时，如果是之前使用过的依赖，那么它在本地仓库中（你电脑上设置的maven本地仓库目录）就存在，直接从本地拿；如果是第一次导入该依赖，会先从远程仓库中找，再从中央仓库中找，把相应的jar包下载到本地仓库中，再导入maven项目中。</p></li></ul><img src="image-20230328095806245.png" alt="image-20230328095806245" style="zoom: 67%;" /><h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p>1、配置本地仓库</p><p>​        修改 conf/settings.xml 中的 <localRepository> 为一个指定目录作为本地仓库，用来存储jar包。        </p><p><img src="image-20230325170948329.png" alt="image-20230325170948329"></p><p>2、配置私服</p><p>中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p><p>修改 conf/settings.xml 中的 <mirrors>标签。</p><img src="image-20230325171049898.png" alt="image-20230325171049898" style="zoom: 67%;" /><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件。</p><p>Maven 对项目构建的生命周期划分为3套，默认(default)生命周期如下：</p><img src="image-20230325171645821.png" alt="image-20230325171645821" style="zoom: 67%;" /><p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。</p><h2 id="Maven使用"><a href="#Maven使用" class="headerlink" title="Maven使用"></a>Maven使用</h2><h3 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h3><p>坐标是Maven项目资源的唯一标识，用坐标来定义项目或引入项目中需要的依赖。</p><p>Maven坐标组成：</p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写）</li><li>artifactId：定义当前Maven项目名称</li><li>version：定义当前项目版本号</li></ul><img src="image-20230325172258113.png" alt="image-20230325172258113" style="zoom:67%;" /><blockquote><p>上述的资源坐标可以指项目、依赖、插件。当我们的项目被作为其他项目的依赖时，也是需要坐标来导入的。</p></blockquote><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在项目的 pom.xml 中编写 <dependencies> 标签，在子标签 <dependencie> 中定义坐标的 groupId，artifactId，version。具体的坐标可以在<a href="https://mvnrepository.com/%E4%B8%8A%E6%9F%A5%E6%89%BE%E3%80%82">https://mvnrepository.com/上查找。</a></p><blockquote><p>快捷方式：Alt+Fn+Insert导入常用依赖。</p></blockquote><p><strong>依赖范围：</strong> </p><p>通过设置坐标的依赖范围<scope>，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。</p><table><thead><tr><th><strong>依赖范围</strong></th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td><strong>test</strong></td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td><strong>provided</strong></td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td><strong>system</strong></td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table><blockquote><p>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Maven是专门用于管理和构建Java项目的工具。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="https://kicheng.github.io/2023/03/28/JDBC/"/>
    <id>https://kicheng.github.io/2023/03/28/JDBC/</id>
    <published>2023-03-28T01:44:15.000Z</published>
    <updated>2025-01-10T13:48:18.509Z</updated>
    
    <content type="html"><![CDATA[<p>​    现在企业早就不使用这种繁琐的技术了，但是学过了<code>JDBC</code>才能更好的理解后面的开发框架。</p><span id="more"></span><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>​    JDBC是一款使用 Java语言赖操作关系型数据库的一套API；它为不同的关系型数据库提供了一套标准的API接口。</p><img src="image-20230325094653057.png" alt="image-20230325094653057" style="zoom:50%;" /><h2 id="JDBC快速入门"><a href="#JDBC快速入门" class="headerlink" title="JDBC快速入门"></a>JDBC快速入门</h2><p>（1）导入驱动包：操作哪个关系型数据库就需要导入该数据库的驱动包。将mysql驱动包放在模块的<code>lib</code>目录下，并添加为库文件；</p><blockquote><p>mysql驱动jar包下载地址：<a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a></p></blockquote><p>（2）代码步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="comment">// 注册驱动(可省略)</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取链接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">// 定义mysql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update tb_user set password = &#x27;20221&#x27; where username=&#x27;ljc&#x27;;&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取执行sql对象Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">// statement执行sql语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> statement.executeUpdate(sql);  <span class="comment">// 数据库增删改操作返回的都是受影响的行数，int类型</span></span><br><span class="line">        <span class="comment">// 返回处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p>1、<code>DriverManager</code>驱动管理类</p><ul><li><p>注册驱动 （mysql5自动注册）</p></li><li><p>获取数据库的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure></li></ul><p>2、<code>Connection</code>数据库连接对象</p><ul><li><p>获取执行sql的statement对象</p><ul><li><p>普通执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure></li><li><p>预编译执行 – 防止sql注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.prepareStatement(sql);  <span class="comment">// 预编译直接将sql语句传进来</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>事务管理</p><blockquote><p>Mysql事务管理(mysql中默认自动提交): ①开启事务：Begin; 或 Transaction;  ②提交事务：Commit;   ③回滚事务：Rollback;</p></blockquote><p><code>Connection</code>中定义了3个对应的方法：</p><ul><li><p>开启事务：true表示自动提交事务，false表示手动提交事务，而开启事务需要将该参数设为为false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.commit();</span><br></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.rollback();</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>事务管理的意义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ============开启事务==========</span></span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//5. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> stmt.executeUpdate(sql1);</span><br><span class="line">        <span class="comment">//6. 处理结果</span></span><br><span class="line">        System.out.println(count1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//5. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> stmt.executeUpdate(sql2);</span><br><span class="line">        <span class="comment">//6. 处理结果</span></span><br><span class="line">        System.out.println(count2);    </span><br><span class="line">        <span class="comment">// ============提交事务==========</span></span><br><span class="line">        <span class="comment">//程序运行到此处，说明没有出现任何问题，则需求提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ============回滚事务==========</span></span><br><span class="line">        <span class="comment">//程序在出现异常时会执行到这个地方，此时就需要回滚事务</span></span><br><span class="line">        conn.rollback();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>Statement</code>对象</p><p>​        用来执行sql代码。</p><ul><li><p>执行数据增删改以及数据库、表、列的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> statement.excuteUpdate(sql);</span><br></pre></td></tr></table></figure></li><li><p>表中查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br></pre></td></tr></table></figure></li></ul><p>4、<code>ResultSet</code>结果集对象</p><p>​        封装了sql查询语句的结果。</p><p>​        遍历查询结果中所有数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 光标向下移动一行，并且判断当前行是否有数据</span></span><br><span class="line">   <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">       <span class="comment">// 2 获取数据  getXxx()</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">       System.out.println(id);</span><br><span class="line">       System.out.println(name);</span><br><span class="line">       System.out.println(money);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>5、<code>PreparedStatement</code>对象</p><p>​        预编译sql语句并执行，防止sql注入。</p><blockquote><p>sql注入：通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></blockquote><ul><li><p>模拟sql注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;xxxxxx&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面的sql代码是将name和pwd拼接而成的，拼接后的sql代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user <span class="type">where</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&#x27;xxxxxx&#x27;</span> <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> or <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>PreparedStatement</code></p><p>先前使用<code>Statement</code>对象执行sql代码的步骤：</p><p> ① 定义参数以及sql语句</p><p> ② <code>statement.executeUpdate(sql)</code>执行</p><p><strong>使用<code>PreparedStatement</code>预编译执行步骤：</strong></p><p> ① 定义sql语句，占位符用 ‘?’代替</p><p> ② <code>pstmt</code>对象设置 ‘?’ 参数指代的值： <code>pstmt.setString(index,参数);</code></p><p> ③ <code>pstmt.executeUpdate();</code>执行，这里注意不需要传入sql语句了，因为在定义<code>pstmt</code>对象的时候已经传入sql语句进行预编译了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">textPreparedStatement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注册驱动(可省略)</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取链接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line">        pstmt.setString(<span class="number">1</span>,name);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>,pwd);</span><br><span class="line">  </span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        resultSet.close();</span><br><span class="line">        pstmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>6、<code>PreparedStatement</code>原理</p><p>​    开启预编译：在url中加入参数：<code>useServerPrepStmts=true</code>;</p><p>​    好处：① 预编译，性能更高； ② 防止sql注入</p><img src="image-20230325160120135.png" alt="image-20230325160120135" style="zoom:50%;" /><p>​    在获取<code>PreparedStatement</code>对象时，将sql语句发送给mysql服务器进行检查、编译（这些步骤很耗时），执行时就不用再进行这些步骤了，速度更快。</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>​    数据库连接池（Connection Pool）是一种复用 Connection 的组件，它可以避免反复创建新连接，提高JDBC代码的运行效率。</p><p>​    在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池复用已经创建好的连接。</p>  <img src="image-20230325160719950.png" alt="image-20230325160719950" style="zoom:50%;" /><h3 id="数据库连接池的实现"><a href="#数据库连接池的实现" class="headerlink" title="数据库连接池的实现"></a>数据库连接池的实现</h3><p>​    标准接口：<code>DataSource</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">datasource</span> <span class="operator">=</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>​    不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</p><p><code>Druid</code>数据连接池 – alibaba</p><ul><li><p>导入jar包：下载地址 <a href="https://repo1.maven.org/maven2/com/alibaba/druid/">https://repo1.maven.org/maven2/com/alibaba/druid/</a></p></li><li><p>编写配置文件<code>druid.properties</code></p></li></ul><img src="image-20230325162515349.png" alt="image-20230325162515349" style="zoom:50%;" /><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testDruid</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//定义配置文件</span></span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/druid.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据库连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection); <span class="comment">//获取到了连接后就可以继续做其他操作了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(System.getProperty(&quot;user.dir&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Druid</code>连接池配置成功：</p><img src="image-20230325162717690.png" alt="image-20230325162717690" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;​    现在企业早就不使用这种繁琐的技术了，但是学过了&lt;code&gt;JDBC&lt;/code&gt;才能更好的理解后面的开发框架。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="https://kicheng.github.io/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>Android平台JNI开发保姆级教程</title>
    <link href="https://kicheng.github.io/2023/03/12/Android-jni/"/>
    <id>https://kicheng.github.io/2023/03/12/Android-jni/</id>
    <published>2023-03-12T13:41:38.000Z</published>
    <updated>2023-03-12T13:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        最近项目中在Android移动端需要用到音视频处理的部分，这离不开FFmpeg工具。但是FFmpeg源码是C语言，想要在Android java中调用FFmpeg工具，这就需要Android NDK登场了。</p><span id="more"></span><h1 id="Android平台JNI开发保姆级教程"><a href="#Android平台JNI开发保姆级教程" class="headerlink" title="Android平台JNI开发保姆级教程"></a>Android平台JNI开发保姆级教程</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>​        FFmpeg源码：可以在官网下载，目前我是用的是最新版的6.0版本（只下载源代码即可，不要下载已经编译好的在不同平台可以运行的安装包）。</p><p><img src="pic1.png" alt="image-20230312105234096"></p><p>​        Android NDK：可以在官网下载，但更推荐在Android Studio中的Setting中可以直接下载NDK对应版本，我这里使用的是22.1.7171670版本的NDK（建议不要使用太新的NDK，否则可能会出现一些BUG）。</p><img src="pic2.png" alt="image-20230312103532627" style="zoom: 33%;" /><p>​        安装msys2：由于我是在Windows下对FFmpeg源码进行交叉编译，所以需要一个类Unix环境；或者你可以直接使用linux操作系统。</p><p>​        由于第一次接触Android开发，对Android程序调用类库的流程不清楚，导致走了很多弯路。其实总结下来也很简单，我这里引用了雷神的流程图：</p><p><img src="pic3.png" alt="img"></p><blockquote><p><strong>在FFmpeg的最新版本6.0中，已经不需要在源码中修改configure设置了（我记得貌似从4.0版本之后就不需要修改了，记不太清了）。</strong></p></blockquote><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Android-NDK"><a href="#Android-NDK" class="headerlink" title="Android NDK"></a>Android NDK</h3><p>​        NDK 主要提供了一些库和工具，包括交叉编译器、调试器、库文件等，开发者可以使用这些工具将原生代码编译为针对不同 CPU 架构的本地库，然后在 Android 应用中通过 Java Native Interface（JNI）来调用这些本地库，以实现一些高性能、低级别的操作，例如图形处理、音频处理、加密、数据处理等。</p><p>​        Android NDK 是一个允许使用 C、C++ 等本地语言编写 Android 应用的工具包，可以提高应用的运行效率和系统性能。</p><h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>​        JNI（Java Native Interface）是Java平台提供的一种机制，用于在Java虚拟机中运行本地代码。它允许Java应用程序通过调用本地语言编写的函数来使用底层操作系统和硬件资源，从而实现高性能的计算和底层操作。简单来说，JNI提供了一种在Java程序中调用本地代码的方式，可以扩展Java程序的功能和性能。</p><h3 id="so库"><a href="#so库" class="headerlink" title=".so库"></a>.so库</h3><p>​        在Android中，C语言代码需要被编译为.so库的形式才能被Android应用程序调用。这是因为Android系统是基于Linux内核的，而Linux系统下的.so库是一种常见的代码共享形式，可以被多个进程动态链接使用，避免了代码的重复编写和内存占用。通过将C语言代码编译为.so库的形式，Android应用程序可以在运行时动态加载和链接所需的库，从而实现对底层系统和硬件资源的访问和控制。</p><p>​        通过.so库的形式调用C语言代码，可以让Android应用程序更高效地使用底层系统和硬件资源，从而提高程序的性能和可靠性。同时，.so库也方便了代码的管理和维护，可以将公共的代码打包成库，供多个应用程序共享使用。</p><h2 id="开发流程（敲黑板！）"><a href="#开发流程（敲黑板！）" class="headerlink" title="开发流程（敲黑板！）"></a>开发流程（敲黑板！）</h2><h3 id="编译FFmpeg库"><a href="#编译FFmpeg库" class="headerlink" title="编译FFmpeg库"></a>编译FFmpeg库</h3><p>​        首先要把NDK安装好，路径是在你SDK路径下的NDK目录中，最好把你要用到的版本加入到环境变量当中。</p><p>​        在任意目录中新建一个脚本<code>build_ffmpeg.sh</code>，添加内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">SRC_DIR=D:\Android-Studio\ffmpeg-6.0</span><br><span class="line">DST_DIR=D:\Android-Studio\ffmpeg_build_out</span><br><span class="line">NDK=D:/Android/Sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/windows-x86_64</span><br><span class="line">API=23  </span><br><span class="line"> </span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$SRC_DIR</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> build_onearch</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; configure <span class="variable">$CPU</span>&quot;</span></span><br><span class="line">./configure --enable-cross-compile --target-os=android  \</span><br><span class="line">--prefix=<span class="variable">$DST_DIR</span>/<span class="variable">$ANDROID_ABI</span>  --cross-prefix=<span class="variable">$CROSS_PREFIX</span>  \</span><br><span class="line">--cc=<span class="variable">$CLANG_PREFIX</span> --cxx=<span class="variable">$CLANG_PREFIX</span>++  \</span><br><span class="line">--<span class="built_in">arch</span>=<span class="variable">$ARCH</span>  --cpu=<span class="variable">$CPU</span>  --sysroot=<span class="variable">$NDK</span>/sysroot \</span><br><span class="line">--enable-shared --disable-static \</span><br><span class="line">--enable-small --disable-programs --disable-doc \</span><br><span class="line">--enable-asm --enable-neon \</span><br><span class="line">--enable-jni --enable-mediacodec </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;&lt; configure <span class="variable">$CPU</span>&quot;</span></span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ANDROID_ABI=arm64-v8a</span><br><span class="line">ARCH=arm64</span><br><span class="line">CPU=armv8-a</span><br><span class="line">CROSS_PREFIX=<span class="variable">$NDK</span>/bin/aarch64-linux-android-</span><br><span class="line">CLANG_PREFIX=<span class="variable">$NDK</span>/bin/aarch64-linux-android<span class="variable">$API</span>-clang</span><br><span class="line">build_onearch</span><br></pre></td></tr></table></figure><p>​        <font color=red>前面几行要根据自己的电脑路径进行配置，切莫照搬全抄！</font>这里的API的版本是最低版本，注意不要大于自己设备的Android API版本。网上有很多类似的配置脚本，可以对configure响应的修改进行功能增减。</p><p>​        我这里只编译了<code>arm64-v8a</code>的.so库，通常来说64位的CPU架构是对先前的CPU架构是兼容的。</p><p>​        将脚本保存后关闭，然后打开安装好的msys2，在脚本目录下运行脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build_ffmpeg.sh</span><br></pre></td></tr></table></figure><p>​        整个编译过程大概有二十多分钟吧，编译好后的动态库会生成在你前面设置的<code>DST_DIR</code>路径下。</p><p><img src="pic4.png" alt="image-20230312111053279"></p><p>​        <code>include</code>目录下是一些头文件，<code>lib</code>目录下就是相应的.so库了。    </p><h3 id="JNI调用C程序"><a href="#JNI调用C程序" class="headerlink" title="JNI调用C程序"></a>JNI调用C程序</h3><p>使用<code>JNI</code>调用C语言代码需要做以下几步：</p><ul><li>编写带有native方法的Java类和声明要加载的类库</li><li>使用javah命令生成.h头文件（也可以用<strong>JNI_OnLoad</strong>动态注册函数，就不用生成.h头文件了）</li><li>编写C代码实现头文件中的方法</li></ul><h4 id="编写Java端代码"><a href="#编写Java端代码" class="headerlink" title="编写Java端代码"></a>编写Java端代码</h4><p>​        用官方文档中的<code>hello_jni</code>例程修改的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellojni;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJni</span> <span class="keyword">extends</span> <span class="title class_">Activity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** Called when the activity is first created. */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        <span class="type">TextView</span>  <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextView</span>(<span class="built_in">this</span>);</span><br><span class="line">        tv.setText( stringFromJNI() );</span><br><span class="line">        setContentView(tv);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title function_">unimplementedStringFromJNI</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;hellojni&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写C端代码"><a href="#编写C端代码" class="headerlink" title="编写C端代码"></a>编写C端代码</h4><p>1、获取C语言的接口函数声明</p><p>​        根据Java对于C语言接口的定义，生成相应的接口函数声明。说通俗点就是Java层只是用<strong>native</strong>关键词声明了一个C语言的函数，要在Java层的函数和C语言层的函数之间形成一个映射关系，这一步需要用到JDK中的“javac -h”命令。</p><p>​        尴尬的是在生成头文件的时候出现了<strong>程序包XX.XX不存在</strong>的BUG，网上找了一会发现并没有卵用，于是乎就直接定义<code>JNI_Onload</code>方法形成动态函数映射。<font color=red>（跳过第一步生成.h头文件的步骤即可）</font></p><p>下面的第三步就讲讲如何用<code>JNI_Onload</code>：</p><blockquote><p>传统java  JNI方式： 编写带有native方法的Java类 → 使用javah命令生成.h头文件 → 编写代码实现头文件中的方法</p><p>但是上述每次都需要通过javah依据java类的全类名生成对应的native函数全名称，其实我们可以使用RegisterNatives方法把c/c++中的方法隐射到Java中的native方法，这样就可以随意定义你的函数名而不用写那么长的又看不懂的全名类啦！</p></blockquote><p>2、编写C语言代码</p><p>在项目根目录下创建<code>jni</code>目录：<code>jni</code>目录中新建<code>hellojni.c</code>文件，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line"><span class="comment">// 用的雷佬的代码 -- 该函数调用了libavcodec的avcodec_configuration()方法，用于获取FFmpeg的配置信息。</span></span><br><span class="line">jstring <span class="title function_">stringFromJNI</span><span class="params">( JNIEnv* env,jobject thiz )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> info[<span class="number">10000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">   <span class="built_in">sprintf</span>(info, <span class="string">&quot;%s\n&quot;</span>, avcodec_configuration());</span><br><span class="line">   <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义函数<code>JNI_OnLoad</code>动态注册函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM* pVm, <span class="type">void</span>* reserved)</span> &#123;</span><br><span class="line">JNIEnv* env;</span><br><span class="line"><span class="keyword">if</span> ((*pVm)-&gt;GetEnv(pVm, (<span class="type">void</span> **)&amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">JNINativeMethod nm[<span class="number">1</span>];</span><br><span class="line">nm[<span class="number">0</span>].name = <span class="string">&quot;stringFromJNI&quot;</span>;</span><br><span class="line">nm[<span class="number">0</span>].signature = <span class="string">&quot;()Ljava/lang/String;&quot;</span>;</span><br><span class="line">nm[<span class="number">0</span>].fnPtr = (<span class="type">void</span>*)stringFromJNI;</span><br><span class="line">jclass cls = (*env)-&gt;FindClass(env, <span class="string">&quot;com/example/hellojni/HelloJni&quot;</span>);</span><br><span class="line">(*env)-&gt;RegisterNatives(env, cls, nm, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        前后都是固定的模板，不需要修改，只需要更改<code>JNINativeMethod</code>中的字段信息，关于JNI编程的简单语法都很简单，去了解一下就可，不在这里说了。其实就是用这个<code>RegisterNatives</code>注册方法，C语言本地的函数与Java层的类和函数进行动态绑定。</p><p><code>JNINativeMethod</code>结构体的字段信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;     <span class="comment">// java层对应的方法名称  </span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* signature;<span class="comment">// 该方法的返回值类型和参数类型  </span></span><br><span class="line">    <span class="type">void</span>*       fnPtr;    <span class="comment">// native中对应的函数指针  </span></span><br><span class="line">&#125; JNINativeMethod;  </span><br></pre></td></tr></table></figure><p>3、<code>Android.mk</code>和 <code>Application.mk</code>编写</p><p>​        在<code>JNI</code>目录下创建<code>Android.mk</code>和 <code>Application.mk</code>文件。这是NDK官方推荐的<code>ndk-build</code>（是一个命令行工具，它用于构建使用C/C++编写的Android Native库）构建方式的脚本文件（不过yysy现在用的更多的是<code>cmake</code>了，反正ndk-build很好用，管他的呢）。</p><p><code>Android.mk</code>的编写规范可以看NDK的官方文档，<code>Android.mk</code>添加如下代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">LOCAL<span class="emphasis">_PATH := $(call my-dir)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># FFmpeg library</span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avcodec</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavcodec.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avdevice</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavdevice.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avfilter</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavfilter.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avformat</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavformat.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := avutil</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libavutil.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := swresample</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libswresample.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := swscale</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := lib/libswscale.so</span></span><br><span class="line"><span class="emphasis">include $(PREBUILT_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># Program</span></span><br><span class="line"><span class="emphasis">include $(CLEAR_</span>VARS)</span><br><span class="line">LOCAL<span class="emphasis">_MODULE := hellojni</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SRC<span class="emphasis">_FILES := hellojni.c</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>C<span class="emphasis">_INCLUDES += $(LOCAL_</span>PATH)/include</span><br><span class="line">LOCAL<span class="emphasis">_LDLIBS := -llog -lz</span></span><br><span class="line"><span class="emphasis">LOCAL_</span>SHARED<span class="emphasis">_LIBRARIES := avcodec avdevice avfilter avformat avutil swresample swscale</span></span><br><span class="line"><span class="emphasis">include $(BUILD_</span>SHARED<span class="emphasis">_LIBRARY)</span></span><br></pre></td></tr></table></figure><p><code>Application.mk</code>代码如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">APP<span class="emphasis">_ABI := arm64-v8a</span></span><br><span class="line"><span class="emphasis">APP_</span>PLATFORM := android-23  # minAPI</span><br></pre></td></tr></table></figure><p><code>APP_ABI</code> 指定了设备CPU的架构。因为前面编译<code>FFmpeg</code>的时候我只编译了64位版本的，这里就对应上。</p><p>4、NDK-BUILD编译</p><p>​        将先前编译的FFmpeg的<code>include</code>和<code>lib</code>目录复制到<code>jni</code>目录当中来，现在看<code>jni</code>目录结构应该是这样的：</p><img src="pic5.png" alt="image-20230312171910710" style="zoom: 80%;" /><p>​        命令行<code>cd</code>到这一层目录下，执行<code>ndk-build</code>命令即可。</p><img src="pic6.png" alt="image-20230312172026460" style="zoom:80%;" /><p>​        然后你还会发现项目的根目录下生成了这两个目录。</p><p><img src="pic7.png" alt="image-20230312172123920"></p><p>​        <code>libs</code>里面就是根据<code>android.mk</code>脚本编译的.so库了，<code>obj</code>没什么用，里面就是一些编译的过程文件。将<code>libs</code>目录中的内容（应该是cpu架构文件夹，下层目录才是.so库）copy到<code>app/src/main</code>目录的<code>jniLibs</code>目录当中（项目运行时默认就是在<code>jniLibs</code>中寻找加载相应的第三方.so库）。</p><img src="pic8.png" alt="image-20230312172450844" style="zoom: 67%;" /><p>​        接下来就可以在手机上对项目进行测试啦！因为我使用的是<code>arm64-v8a</code>cpu架构，这种架构好像不支持在虚拟机上测试（虚拟机架构是<code>x86</code>和<code>x86_64</code>，但可不可以我也没试过）。</p><p>​        下面是测试的结果啦：</p><img src="result_pic.jpg" alt="result_pic" style="zoom: 33%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;​        最近项目中在Android移动端需要用到音视频处理的部分，这离不开FFmpeg工具。但是FFmpeg源码是C语言，想要在Android java中调用FFmpeg工具，这就需要Android NDK登场了。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://kicheng.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://kicheng.github.io/tags/Android/"/>
    
    <category term="JNI开发" scheme="https://kicheng.github.io/tags/JNI%E5%BC%80%E5%8F%91/"/>
    
    <category term="FFmpeg" scheme="https://kicheng.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV特征检测</title>
    <link href="https://kicheng.github.io/2023/03/10/opencv/"/>
    <id>https://kicheng.github.io/2023/03/10/opencv/</id>
    <published>2023-03-10T07:54:34.000Z</published>
    <updated>2025-01-10T13:42:40.569Z</updated>
    
    <content type="html"><![CDATA[<p>​    前段时间毕设在研究Android开发，以及对第三方库的JNI编程和交叉编译，本想把FFmpeg和JNI先整理成博客发出来，奈何实在太懒了，可能还要过一段时间才能整理完了。正好这几天项目里用到了OpenCV里Detection的一些算法，就去学习了一下。</p><span id="more"></span><h1 id="OpenCV-Canny边缘检测、HoughLinesP直线检测"><a href="#OpenCV-Canny边缘检测、HoughLinesP直线检测" class="headerlink" title="[OpenCV]Canny边缘检测、HoughLinesP直线检测"></a>[OpenCV]Canny边缘检测、HoughLinesP直线检测</h1><h2 id="边缘检测Edge-detection"><a href="#边缘检测Edge-detection" class="headerlink" title="边缘检测Edge detection"></a>边缘检测Edge detection</h2><p>​    边缘检测算法是指利用灰度值的不连续性质，以灰度突变为基础分割出目标区域。大概原理是计算图像中每个像素点的梯度值和梯度方向。使用边缘检测算子计算图像在x和y方向上的一阶导数，然后计算每个像素点的梯度幅值和梯度方向；再利用NMS和阈值检测将边缘点标记和连接。</p><p>​    最后的输出一定是一个二值图像，其中白色像素表示边缘，黑色像素表示非边缘。</p><p>​    Canny边缘检测算法的优点是能够检测到比较细的边缘，且对噪声比较鲁棒。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Canny算法参数：</span><br><span class="line">   InputArray image,  //输入图像，要求为灰度图</span><br><span class="line">   OutputArray edges, //canny检测后的输出图像</span><br><span class="line">   double threshold1, //阈值1,低阈值</span><br><span class="line">   double threshold2, //阈值2，高阈值，低/高=比值1:2~1:3尤佳</span><br><span class="line">   int apertureSize = 3,  //Sobel算子的孔径大小</span><br><span class="line">   bool L2gradient = false  //计算梯度幅度值的标识，默认为false</span><br></pre></td></tr></table></figure><p>​    实验代码，参数可以自行调整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Mat src, dst;</span><br><span class="line">   src = <span class="built_in">imread</span>(<span class="string">&quot;../../pictureRepo/people.jpg&quot;</span>);</span><br><span class="line">   <span class="built_in">Canny</span>(src, dst, <span class="number">50</span>, <span class="number">200</span>, <span class="number">3</span>);</span><br><span class="line">   <span class="built_in">namedWindow</span>(<span class="string">&quot;Orgin&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">imshow</span>(<span class="string">&quot;Orgin&quot;</span>, src);</span><br><span class="line">   <span class="built_in">namedWindow</span>(<span class="string">&quot;Canny&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">imshow</span>(<span class="string">&quot;Canny&quot;</span>, dst);</span><br><span class="line">   <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    网上随便找了一张图，实验结果是这样的。值得注意的是：Canny算法的output是二值图像，其中白色像素表示边缘，黑色像素表示非边缘。</p><img src="result1.png" alt="result1" style="zoom:67%;" /><h2 id="直线检测Line-detection"><a href="#直线检测Line-detection" class="headerlink" title="直线检测Line detection"></a>直线检测Line detection</h2><p>​    霍夫变换直线检测是最基本的算法，也是今天学习和使用到的。他有<code>HoughLines</code>和<code>HoughLinesP</code>两种，后者是前者的优化，但并不意味着<code>HoughLines</code>完全被取代，他们适用于不同的场景，大家可以根据实际需要自行选择。</p><p>​    需要我们注意的是霍夫直线检测是从二值图像中检测直线(线段)，所以在调用<code>HoughLines</code>或<code>HoughLinesP</code>算法前，要先将图像转换成二值图像，通常在之前先使用<code>Canny</code>将其简化成只有边缘特征的二值图像。</p><p>​    这里我使用了OpenCV官方文档提供的示例代码进行测试。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HoughLinesP算法参数：</span><br><span class="line"><span class="code">InputArray image,  //  8位的单通道二值图像。对于其他类型，在进行霍夫变换之前，需要将其修改为这个指定的格式</span></span><br><span class="line"><span class="code">OutputArray lines,  // 输出的直线集合</span></span><br><span class="line"><span class="code">double rho,  // 以像素为单位的距离 r 的精度。一般情况下，使用的精度是 1</span></span><br><span class="line"><span class="code">double theta,  // 角度 θ 的精度。一般情况下，使用的精度是 pi/180，表示要搜索可能的角度</span></span><br><span class="line"><span class="code">int threshold,  // 阈值。该值越小，判定出的直线越多；值越大，判定出的直线就越少</span></span><br><span class="line"><span class="code">double minLineLength = 0,  // 控制「接受直线的最小长度」的值，默认值为 0</span></span><br><span class="line"><span class="code">double maxLineGap = 0  // 控制接受共线线段之间的最小间隔，默认值为 0</span></span><br></pre></td></tr></table></figure><p>​    实验代码，参数可以自行调整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Mat src, dst, color_dst;</span><br><span class="line">   src = <span class="built_in">imread</span>(<span class="string">&quot;../../pictureRepo/building.jpg&quot;</span>);</span><br><span class="line">   <span class="built_in">Canny</span>(src, dst, <span class="number">50</span>, <span class="number">200</span>, <span class="number">3</span>);</span><br><span class="line">   <span class="built_in">cvtColor</span>(dst, color_dst, COLOR_GRAY2BGR);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   COLOR_GRAY2BGR参数表示将灰度图像转换为3通道的BGR彩色图像。</span></span><br><span class="line"><span class="comment">   经过该转换后，color_dst中每个像素的R、G、B三个分量的值都相同，即为该像素的灰度值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   vector&lt;Vec4i&gt; lines;</span><br><span class="line">   <span class="built_in">HoughLinesP</span>(dst, lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">200</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">line</span>(color_dst, <span class="built_in">Point</span>(lines[i][<span class="number">0</span>], lines[i][<span class="number">1</span>]),</span><br><span class="line">           <span class="built_in">Point</span>(lines[i][<span class="number">2</span>], lines[i][<span class="number">3</span>]), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">namedWindow</span>(<span class="string">&quot;Orgin&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">imshow</span>(<span class="string">&quot;Orgin&quot;</span>, src);</span><br><span class="line">   <span class="built_in">namedWindow</span>(<span class="string">&quot;HoughLinesP&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">imshow</span>(<span class="string">&quot;HoughLinesP&quot;</span>, color_dst);</span><br><span class="line">   <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    实验结果如下。</p><p>​    这是一个OpenCV官方文档提供的示例图片:</p><img src="result2_1.png" alt="result2_1" style="zoom: 65%;" /><p>​    这是上述程序在概率霍夫变换后的输出：</p><img src="result2_2.png" alt="result2_2" style="zoom:65%;" /><p>​    这是用<code> HoughLinesP</code>的结果，使用<code>HoughLines</code>进行检测出现比较严重的误判。我猜想的原因是这样的：根据官方文档的描述，<code> HoughLinesP</code>检测出来的是一条条可以控制长短的线段，而<code> HoughLines</code>只能检测出完整的直线。所以除了一些特殊的情景外，使用<code> HoughLinesP</code>的检测结果会更精确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    前段时间毕设在研究Android开发，以及对第三方库的JNI编程和交叉编译，本想把FFmpeg和JNI先整理成博客发出来，奈何实在太懒了，可能还要过一段时间才能整理完了。正好这几天项目里用到了OpenCV里Detection的一些算法，就去学习了一下。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenCV" scheme="https://kicheng.github.io/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://kicheng.github.io/tags/OpenCV/"/>
    
  </entry>
  
</feed>
